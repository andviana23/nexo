// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: despesas_fixas.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const activateDespesaFixa = `-- name: ActivateDespesaFixa :one
UPDATE despesas_fixas
SET
    ativo = true,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, unidade_id, descricao, categoria_id, fornecedor, valor, dia_vencimento, ativo, observacoes, criado_em, atualizado_em
`

type ActivateDespesaFixaParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Ativa uma despesa fixa
func (q *Queries) ActivateDespesaFixa(ctx context.Context, arg ActivateDespesaFixaParams) (DespesasFixa, error) {
	row := q.db.QueryRow(ctx, activateDespesaFixa, arg.ID, arg.TenantID)
	var i DespesasFixa
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnidadeID,
		&i.Descricao,
		&i.CategoriaID,
		&i.Fornecedor,
		&i.Valor,
		&i.DiaVencimento,
		&i.Ativo,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const countDespesasFixas = `-- name: CountDespesasFixas :one
SELECT COUNT(*) FROM despesas_fixas
WHERE tenant_id = $1
`

// Conta total de despesas fixas do tenant
func (q *Queries) CountDespesasFixas(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countDespesasFixas, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDespesasFixasAtivas = `-- name: CountDespesasFixasAtivas :one
SELECT COUNT(*) FROM despesas_fixas
WHERE tenant_id = $1 AND ativo = true
`

// Conta despesas fixas ativas do tenant
func (q *Queries) CountDespesasFixasAtivas(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countDespesasFixasAtivas, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDespesaFixa = `-- name: CreateDespesaFixa :one

INSERT INTO despesas_fixas (
    tenant_id,
    unidade_id,
    descricao,
    categoria_id,
    fornecedor,
    valor,
    dia_vencimento,
    ativo,
    observacoes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, tenant_id, unidade_id, descricao, categoria_id, fornecedor, valor, dia_vencimento, ativo, observacoes, criado_em, atualizado_em
`

type CreateDespesaFixaParams struct {
	TenantID      pgtype.UUID     `json:"tenant_id"`
	UnidadeID     pgtype.UUID     `json:"unidade_id"`
	Descricao     string          `json:"descricao"`
	CategoriaID   pgtype.UUID     `json:"categoria_id"`
	Fornecedor    *string         `json:"fornecedor"`
	Valor         decimal.Decimal `json:"valor"`
	DiaVencimento int32           `json:"dia_vencimento"`
	Ativo         *bool           `json:"ativo"`
	Observacoes   *string         `json:"observacoes"`
}

// ============================================================================
// Queries sqlc: despesas_fixas
// Módulo: Financeiro
// Sprint: 2
// ============================================================================
// Cria uma nova despesa fixa
func (q *Queries) CreateDespesaFixa(ctx context.Context, arg CreateDespesaFixaParams) (DespesasFixa, error) {
	row := q.db.QueryRow(ctx, createDespesaFixa,
		arg.TenantID,
		arg.UnidadeID,
		arg.Descricao,
		arg.CategoriaID,
		arg.Fornecedor,
		arg.Valor,
		arg.DiaVencimento,
		arg.Ativo,
		arg.Observacoes,
	)
	var i DespesasFixa
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnidadeID,
		&i.Descricao,
		&i.CategoriaID,
		&i.Fornecedor,
		&i.Valor,
		&i.DiaVencimento,
		&i.Ativo,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const deactivateDespesaFixa = `-- name: DeactivateDespesaFixa :one
UPDATE despesas_fixas
SET
    ativo = false,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, unidade_id, descricao, categoria_id, fornecedor, valor, dia_vencimento, ativo, observacoes, criado_em, atualizado_em
`

type DeactivateDespesaFixaParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Desativa uma despesa fixa
func (q *Queries) DeactivateDespesaFixa(ctx context.Context, arg DeactivateDespesaFixaParams) (DespesasFixa, error) {
	row := q.db.QueryRow(ctx, deactivateDespesaFixa, arg.ID, arg.TenantID)
	var i DespesasFixa
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnidadeID,
		&i.Descricao,
		&i.CategoriaID,
		&i.Fornecedor,
		&i.Valor,
		&i.DiaVencimento,
		&i.Ativo,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const deleteDespesaFixa = `-- name: DeleteDespesaFixa :exec
DELETE FROM despesas_fixas
WHERE id = $1 AND tenant_id = $2
`

type DeleteDespesaFixaParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Remove uma despesa fixa
func (q *Queries) DeleteDespesaFixa(ctx context.Context, arg DeleteDespesaFixaParams) error {
	_, err := q.db.Exec(ctx, deleteDespesaFixa, arg.ID, arg.TenantID)
	return err
}

const existsDespesaFixaByDescricao = `-- name: ExistsDespesaFixaByDescricao :one
SELECT EXISTS(
    SELECT 1 FROM despesas_fixas
    WHERE tenant_id = $1 
      AND LOWER(descricao) = LOWER($2)
      AND id != COALESCE($3, '00000000-0000-0000-0000-000000000000'::uuid)
) as exists
`

type ExistsDespesaFixaByDescricaoParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Lower    string      `json:"lower"`
	ID       pgtype.UUID `json:"id"`
}

// Verifica se já existe despesa fixa com mesma descrição no tenant
func (q *Queries) ExistsDespesaFixaByDescricao(ctx context.Context, arg ExistsDespesaFixaByDescricaoParams) (bool, error) {
	row := q.db.QueryRow(ctx, existsDespesaFixaByDescricao, arg.TenantID, arg.Lower, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getDespesaFixaByID = `-- name: GetDespesaFixaByID :one
SELECT id, tenant_id, unidade_id, descricao, categoria_id, fornecedor, valor, dia_vencimento, ativo, observacoes, criado_em, atualizado_em FROM despesas_fixas
WHERE id = $1 AND tenant_id = $2
`

type GetDespesaFixaByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Busca despesa fixa por ID (com isolamento de tenant)
func (q *Queries) GetDespesaFixaByID(ctx context.Context, arg GetDespesaFixaByIDParams) (DespesasFixa, error) {
	row := q.db.QueryRow(ctx, getDespesaFixaByID, arg.ID, arg.TenantID)
	var i DespesasFixa
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnidadeID,
		&i.Descricao,
		&i.CategoriaID,
		&i.Fornecedor,
		&i.Valor,
		&i.DiaVencimento,
		&i.Ativo,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const listDespesasFixasAtivas = `-- name: ListDespesasFixasAtivas :many
SELECT id, tenant_id, unidade_id, descricao, categoria_id, fornecedor, valor, dia_vencimento, ativo, observacoes, criado_em, atualizado_em FROM despesas_fixas
WHERE tenant_id = $1 AND ativo = true
ORDER BY dia_vencimento ASC
`

// Lista apenas despesas fixas ativas (usado pelo cron job)
func (q *Queries) ListDespesasFixasAtivas(ctx context.Context, tenantID pgtype.UUID) ([]DespesasFixa, error) {
	rows, err := q.db.Query(ctx, listDespesasFixasAtivas, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DespesasFixa{}
	for rows.Next() {
		var i DespesasFixa
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnidadeID,
			&i.Descricao,
			&i.CategoriaID,
			&i.Fornecedor,
			&i.Valor,
			&i.DiaVencimento,
			&i.Ativo,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDespesasFixasAtivasPorTenants = `-- name: ListDespesasFixasAtivasPorTenants :many
SELECT df.id, df.tenant_id, df.unidade_id, df.descricao, df.categoria_id, df.fornecedor, df.valor, df.dia_vencimento, df.ativo, df.observacoes, df.criado_em, df.atualizado_em, t.nome as tenant_nome
FROM despesas_fixas df
JOIN tenants t ON df.tenant_id = t.id
WHERE df.ativo = true AND t.ativo = true
ORDER BY df.tenant_id, df.dia_vencimento
`

type ListDespesasFixasAtivasPorTenantsRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	UnidadeID     pgtype.UUID        `json:"unidade_id"`
	Descricao     string             `json:"descricao"`
	CategoriaID   pgtype.UUID        `json:"categoria_id"`
	Fornecedor    *string            `json:"fornecedor"`
	Valor         decimal.Decimal    `json:"valor"`
	DiaVencimento int32              `json:"dia_vencimento"`
	Ativo         *bool              `json:"ativo"`
	Observacoes   *string            `json:"observacoes"`
	CriadoEm      pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm  pgtype.Timestamptz `json:"atualizado_em"`
	TenantNome    string             `json:"tenant_nome"`
}

// Lista todas as despesas fixas ativas de todos os tenants
// Usado pelo cron job para geração em massa
func (q *Queries) ListDespesasFixasAtivasPorTenants(ctx context.Context) ([]ListDespesasFixasAtivasPorTenantsRow, error) {
	rows, err := q.db.Query(ctx, listDespesasFixasAtivasPorTenants)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDespesasFixasAtivasPorTenantsRow{}
	for rows.Next() {
		var i ListDespesasFixasAtivasPorTenantsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnidadeID,
			&i.Descricao,
			&i.CategoriaID,
			&i.Fornecedor,
			&i.Valor,
			&i.DiaVencimento,
			&i.Ativo,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.TenantNome,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDespesasFixasByCategoria = `-- name: ListDespesasFixasByCategoria :many
SELECT id, tenant_id, unidade_id, descricao, categoria_id, fornecedor, valor, dia_vencimento, ativo, observacoes, criado_em, atualizado_em FROM despesas_fixas
WHERE tenant_id = $1 AND categoria_id = $2
ORDER BY descricao ASC
`

type ListDespesasFixasByCategoriaParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	CategoriaID pgtype.UUID `json:"categoria_id"`
}

// Lista despesas fixas de uma categoria específica
func (q *Queries) ListDespesasFixasByCategoria(ctx context.Context, arg ListDespesasFixasByCategoriaParams) ([]DespesasFixa, error) {
	rows, err := q.db.Query(ctx, listDespesasFixasByCategoria, arg.TenantID, arg.CategoriaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DespesasFixa{}
	for rows.Next() {
		var i DespesasFixa
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnidadeID,
			&i.Descricao,
			&i.CategoriaID,
			&i.Fornecedor,
			&i.Valor,
			&i.DiaVencimento,
			&i.Ativo,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDespesasFixasByTenant = `-- name: ListDespesasFixasByTenant :many
SELECT id, tenant_id, unidade_id, descricao, categoria_id, fornecedor, valor, dia_vencimento, ativo, observacoes, criado_em, atualizado_em FROM despesas_fixas
WHERE tenant_id = $1
ORDER BY descricao ASC
LIMIT $2 OFFSET $3
`

type ListDespesasFixasByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

// Lista todas as despesas fixas do tenant com paginação
func (q *Queries) ListDespesasFixasByTenant(ctx context.Context, arg ListDespesasFixasByTenantParams) ([]DespesasFixa, error) {
	rows, err := q.db.Query(ctx, listDespesasFixasByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DespesasFixa{}
	for rows.Next() {
		var i DespesasFixa
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnidadeID,
			&i.Descricao,
			&i.CategoriaID,
			&i.Fornecedor,
			&i.Valor,
			&i.DiaVencimento,
			&i.Ativo,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDespesasFixasByUnidade = `-- name: ListDespesasFixasByUnidade :many
SELECT id, tenant_id, unidade_id, descricao, categoria_id, fornecedor, valor, dia_vencimento, ativo, observacoes, criado_em, atualizado_em FROM despesas_fixas
WHERE tenant_id = $1 AND unidade_id = $2
ORDER BY descricao ASC
`

type ListDespesasFixasByUnidadeParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	UnidadeID pgtype.UUID `json:"unidade_id"`
}

// Lista despesas fixas de uma unidade específica
func (q *Queries) ListDespesasFixasByUnidade(ctx context.Context, arg ListDespesasFixasByUnidadeParams) ([]DespesasFixa, error) {
	rows, err := q.db.Query(ctx, listDespesasFixasByUnidade, arg.TenantID, arg.UnidadeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DespesasFixa{}
	for rows.Next() {
		var i DespesasFixa
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnidadeID,
			&i.Descricao,
			&i.CategoriaID,
			&i.Fornecedor,
			&i.Valor,
			&i.DiaVencimento,
			&i.Ativo,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumDespesasFixasAtivas = `-- name: SumDespesasFixasAtivas :one
SELECT COALESCE(SUM(valor), 0)::DECIMAL(15,2) as total
FROM despesas_fixas
WHERE tenant_id = $1 AND ativo = true
`

// Soma o valor total de despesas fixas ativas
func (q *Queries) SumDespesasFixasAtivas(ctx context.Context, tenantID pgtype.UUID) (decimal.Decimal, error) {
	row := q.db.QueryRow(ctx, sumDespesasFixasAtivas, tenantID)
	var total decimal.Decimal
	err := row.Scan(&total)
	return total, err
}

const sumDespesasFixasByUnidade = `-- name: SumDespesasFixasByUnidade :one
SELECT COALESCE(SUM(valor), 0)::DECIMAL(15,2) as total
FROM despesas_fixas
WHERE tenant_id = $1 AND unidade_id = $2 AND ativo = true
`

type SumDespesasFixasByUnidadeParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	UnidadeID pgtype.UUID `json:"unidade_id"`
}

// Soma o valor total de despesas fixas ativas por unidade
func (q *Queries) SumDespesasFixasByUnidade(ctx context.Context, arg SumDespesasFixasByUnidadeParams) (decimal.Decimal, error) {
	row := q.db.QueryRow(ctx, sumDespesasFixasByUnidade, arg.TenantID, arg.UnidadeID)
	var total decimal.Decimal
	err := row.Scan(&total)
	return total, err
}

const toggleDespesaFixa = `-- name: ToggleDespesaFixa :one
UPDATE despesas_fixas
SET
    ativo = NOT ativo,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, unidade_id, descricao, categoria_id, fornecedor, valor, dia_vencimento, ativo, observacoes, criado_em, atualizado_em
`

type ToggleDespesaFixaParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Alterna o status ativo/inativo
func (q *Queries) ToggleDespesaFixa(ctx context.Context, arg ToggleDespesaFixaParams) (DespesasFixa, error) {
	row := q.db.QueryRow(ctx, toggleDespesaFixa, arg.ID, arg.TenantID)
	var i DespesasFixa
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnidadeID,
		&i.Descricao,
		&i.CategoriaID,
		&i.Fornecedor,
		&i.Valor,
		&i.DiaVencimento,
		&i.Ativo,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const updateDespesaFixa = `-- name: UpdateDespesaFixa :one
UPDATE despesas_fixas
SET
    descricao = $3,
    categoria_id = $4,
    fornecedor = $5,
    valor = $6,
    dia_vencimento = $7,
    unidade_id = $8,
    observacoes = $9,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, unidade_id, descricao, categoria_id, fornecedor, valor, dia_vencimento, ativo, observacoes, criado_em, atualizado_em
`

type UpdateDespesaFixaParams struct {
	ID            pgtype.UUID     `json:"id"`
	TenantID      pgtype.UUID     `json:"tenant_id"`
	Descricao     string          `json:"descricao"`
	CategoriaID   pgtype.UUID     `json:"categoria_id"`
	Fornecedor    *string         `json:"fornecedor"`
	Valor         decimal.Decimal `json:"valor"`
	DiaVencimento int32           `json:"dia_vencimento"`
	UnidadeID     pgtype.UUID     `json:"unidade_id"`
	Observacoes   *string         `json:"observacoes"`
}

// Atualiza uma despesa fixa
func (q *Queries) UpdateDespesaFixa(ctx context.Context, arg UpdateDespesaFixaParams) (DespesasFixa, error) {
	row := q.db.QueryRow(ctx, updateDespesaFixa,
		arg.ID,
		arg.TenantID,
		arg.Descricao,
		arg.CategoriaID,
		arg.Fornecedor,
		arg.Valor,
		arg.DiaVencimento,
		arg.UnidadeID,
		arg.Observacoes,
	)
	var i DespesasFixa
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnidadeID,
		&i.Descricao,
		&i.CategoriaID,
		&i.Fornecedor,
		&i.Valor,
		&i.DiaVencimento,
		&i.Ativo,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}
