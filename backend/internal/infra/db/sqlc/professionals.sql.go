// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: professionals.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const checkCpfExistsProfessional = `-- name: CheckCpfExistsProfessional :one
SELECT EXISTS (
    SELECT 1 FROM profissionais
    WHERE tenant_id = $1 
      AND cpf = $2 
      AND ($3::uuid IS NULL OR id != $3)
) as exists
`

type CheckCpfExistsProfessionalParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	Cpf       string      `json:"cpf"`
	ExcludeID pgtype.UUID `json:"exclude_id"`
}

func (q *Queries) CheckCpfExistsProfessional(ctx context.Context, arg CheckCpfExistsProfessionalParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkCpfExistsProfessional, arg.TenantID, arg.Cpf, arg.ExcludeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkEmailExistsProfessional = `-- name: CheckEmailExistsProfessional :one
SELECT EXISTS (
    SELECT 1 FROM profissionais
    WHERE tenant_id = $1 
      AND email = $2 
      AND ($3::uuid IS NULL OR id != $3)
) as exists
`

type CheckEmailExistsProfessionalParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	Email     string      `json:"email"`
	ExcludeID pgtype.UUID `json:"exclude_id"`
}

func (q *Queries) CheckEmailExistsProfessional(ctx context.Context, arg CheckEmailExistsProfessionalParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkEmailExistsProfessional, arg.TenantID, arg.Email, arg.ExcludeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countProfessionals = `-- name: CountProfessionals :one
SELECT COUNT(*) FROM profissionais
WHERE tenant_id = $1
  AND ($2::text IS NULL OR status = $2)
  AND ($3::text IS NULL OR tipo = $3)
  AND (
    $4::text IS NULL 
    OR nome ILIKE '%' || $4 || '%'
    OR email ILIKE '%' || $4 || '%'
    OR cpf ILIKE '%' || $4 || '%'
  )
`

type CountProfessionalsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   *string     `json:"status"`
	Tipo     *string     `json:"tipo"`
	Search   *string     `json:"search"`
}

func (q *Queries) CountProfessionals(ctx context.Context, arg CountProfessionalsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProfessionals,
		arg.TenantID,
		arg.Status,
		arg.Tipo,
		arg.Search,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProfessional = `-- name: CreateProfessional :one
INSERT INTO profissionais (
    tenant_id, user_id, nome, email, telefone, cpf, especialidades,
    comissao, tipo_comissao, foto, data_admissao, status, horario_trabalho,
    observacoes, tipo
) VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    $8, $9, $10, $11, $12, $13,
    $14, $15
)
RETURNING id, tenant_id, user_id, nome, email, telefone, cpf, especialidades, 
          comissao, tipo_comissao, foto, data_admissao, data_demissao, status, 
          horario_trabalho, observacoes, criado_em, atualizado_em, tipo
`

type CreateProfessionalParams struct {
	TenantID        pgtype.UUID    `json:"tenant_id"`
	UserID          pgtype.UUID    `json:"user_id"`
	Nome            string         `json:"nome"`
	Email           string         `json:"email"`
	Telefone        string         `json:"telefone"`
	Cpf             string         `json:"cpf"`
	Especialidades  []string       `json:"especialidades"`
	Comissao        pgtype.Numeric `json:"comissao"`
	TipoComissao    *string        `json:"tipo_comissao"`
	Foto            *string        `json:"foto"`
	DataAdmissao    pgtype.Date    `json:"data_admissao"`
	Status          *string        `json:"status"`
	HorarioTrabalho []byte         `json:"horario_trabalho"`
	Observacoes     *string        `json:"observacoes"`
	Tipo            string         `json:"tipo"`
}

type CreateProfessionalRow struct {
	ID              pgtype.UUID        `json:"id"`
	TenantID        pgtype.UUID        `json:"tenant_id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Nome            string             `json:"nome"`
	Email           string             `json:"email"`
	Telefone        string             `json:"telefone"`
	Cpf             string             `json:"cpf"`
	Especialidades  []string           `json:"especialidades"`
	Comissao        pgtype.Numeric     `json:"comissao"`
	TipoComissao    *string            `json:"tipo_comissao"`
	Foto            *string            `json:"foto"`
	DataAdmissao    pgtype.Date        `json:"data_admissao"`
	DataDemissao    pgtype.Date        `json:"data_demissao"`
	Status          *string            `json:"status"`
	HorarioTrabalho []byte             `json:"horario_trabalho"`
	Observacoes     *string            `json:"observacoes"`
	CriadoEm        pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm    pgtype.Timestamptz `json:"atualizado_em"`
	Tipo            string             `json:"tipo"`
}

func (q *Queries) CreateProfessional(ctx context.Context, arg CreateProfessionalParams) (CreateProfessionalRow, error) {
	row := q.db.QueryRow(ctx, createProfessional,
		arg.TenantID,
		arg.UserID,
		arg.Nome,
		arg.Email,
		arg.Telefone,
		arg.Cpf,
		arg.Especialidades,
		arg.Comissao,
		arg.TipoComissao,
		arg.Foto,
		arg.DataAdmissao,
		arg.Status,
		arg.HorarioTrabalho,
		arg.Observacoes,
		arg.Tipo,
	)
	var i CreateProfessionalRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.Nome,
		&i.Email,
		&i.Telefone,
		&i.Cpf,
		&i.Especialidades,
		&i.Comissao,
		&i.TipoComissao,
		&i.Foto,
		&i.DataAdmissao,
		&i.DataDemissao,
		&i.Status,
		&i.HorarioTrabalho,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
		&i.Tipo,
	)
	return i, err
}

const createProfessionalCategoryCommission = `-- name: CreateProfessionalCategoryCommission :one
INSERT INTO comissoes_categoria_profissional (
  tenant_id, profissional_id, categoria_id, comissao
) VALUES (
  $1, $2, $3, $4
) RETURNING id, tenant_id, profissional_id, categoria_id, comissao, criado_em, atualizado_em
`

type CreateProfessionalCategoryCommissionParams struct {
	TenantID       pgtype.UUID     `json:"tenant_id"`
	ProfissionalID pgtype.UUID     `json:"profissional_id"`
	CategoriaID    pgtype.UUID     `json:"categoria_id"`
	Comissao       decimal.Decimal `json:"comissao"`
}

func (q *Queries) CreateProfessionalCategoryCommission(ctx context.Context, arg CreateProfessionalCategoryCommissionParams) (ComissoesCategoriaProfissional, error) {
	row := q.db.QueryRow(ctx, createProfessionalCategoryCommission,
		arg.TenantID,
		arg.ProfissionalID,
		arg.CategoriaID,
		arg.Comissao,
	)
	var i ComissoesCategoriaProfissional
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfissionalID,
		&i.CategoriaID,
		&i.Comissao,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const deleteProfessional = `-- name: DeleteProfessional :exec
DELETE FROM profissionais
WHERE id = $1 AND tenant_id = $2
`

type DeleteProfessionalParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteProfessional(ctx context.Context, arg DeleteProfessionalParams) error {
	_, err := q.db.Exec(ctx, deleteProfessional, arg.ID, arg.TenantID)
	return err
}

const deleteProfessionalCategoryCommissionsByProfessional = `-- name: DeleteProfessionalCategoryCommissionsByProfessional :exec
DELETE FROM comissoes_categoria_profissional
WHERE tenant_id = $1 AND profissional_id = $2
`

type DeleteProfessionalCategoryCommissionsByProfessionalParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ProfissionalID pgtype.UUID `json:"profissional_id"`
}

func (q *Queries) DeleteProfessionalCategoryCommissionsByProfessional(ctx context.Context, arg DeleteProfessionalCategoryCommissionsByProfessionalParams) error {
	_, err := q.db.Exec(ctx, deleteProfessionalCategoryCommissionsByProfessional, arg.TenantID, arg.ProfissionalID)
	return err
}

const getProfessionalByID = `-- name: GetProfessionalByID :one
SELECT id, tenant_id, user_id, nome, email, telefone, cpf, especialidades, 
       comissao, tipo_comissao, foto, data_admissao, data_demissao, status, 
       horario_trabalho, observacoes, criado_em, atualizado_em, tipo
FROM profissionais
WHERE id = $1 AND tenant_id = $2
`

type GetProfessionalByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetProfessionalByIDRow struct {
	ID              pgtype.UUID        `json:"id"`
	TenantID        pgtype.UUID        `json:"tenant_id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Nome            string             `json:"nome"`
	Email           string             `json:"email"`
	Telefone        string             `json:"telefone"`
	Cpf             string             `json:"cpf"`
	Especialidades  []string           `json:"especialidades"`
	Comissao        pgtype.Numeric     `json:"comissao"`
	TipoComissao    *string            `json:"tipo_comissao"`
	Foto            *string            `json:"foto"`
	DataAdmissao    pgtype.Date        `json:"data_admissao"`
	DataDemissao    pgtype.Date        `json:"data_demissao"`
	Status          *string            `json:"status"`
	HorarioTrabalho []byte             `json:"horario_trabalho"`
	Observacoes     *string            `json:"observacoes"`
	CriadoEm        pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm    pgtype.Timestamptz `json:"atualizado_em"`
	Tipo            string             `json:"tipo"`
}

func (q *Queries) GetProfessionalByID(ctx context.Context, arg GetProfessionalByIDParams) (GetProfessionalByIDRow, error) {
	row := q.db.QueryRow(ctx, getProfessionalByID, arg.ID, arg.TenantID)
	var i GetProfessionalByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.Nome,
		&i.Email,
		&i.Telefone,
		&i.Cpf,
		&i.Especialidades,
		&i.Comissao,
		&i.TipoComissao,
		&i.Foto,
		&i.DataAdmissao,
		&i.DataDemissao,
		&i.Status,
		&i.HorarioTrabalho,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
		&i.Tipo,
	)
	return i, err
}

const getProfessionalCategoryCommission = `-- name: GetProfessionalCategoryCommission :one
SELECT comissao::text as comissao
FROM comissoes_categoria_profissional
WHERE tenant_id = $1 
  AND profissional_id = $2 
  AND categoria_id = $3
`

type GetProfessionalCategoryCommissionParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ProfissionalID pgtype.UUID `json:"profissional_id"`
	CategoriaID    pgtype.UUID `json:"categoria_id"`
}

// Busca comissão específica de um profissional para uma categoria de serviço
func (q *Queries) GetProfessionalCategoryCommission(ctx context.Context, arg GetProfessionalCategoryCommissionParams) (string, error) {
	row := q.db.QueryRow(ctx, getProfessionalCategoryCommission, arg.TenantID, arg.ProfissionalID, arg.CategoriaID)
	var comissao string
	err := row.Scan(&comissao)
	return comissao, err
}

const listBarbers = `-- name: ListBarbers :many
SELECT id, tenant_id, user_id, nome, email, telefone, cpf, especialidades, 
       comissao, tipo_comissao, foto, data_admissao, data_demissao, status, 
       horario_trabalho, observacoes, criado_em, atualizado_em, tipo
FROM profissionais
WHERE tenant_id = $1 
  AND tipo = 'BARBEIRO' 
  AND status = 'ATIVO'
ORDER BY nome
`

type ListBarbersRow struct {
	ID              pgtype.UUID        `json:"id"`
	TenantID        pgtype.UUID        `json:"tenant_id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Nome            string             `json:"nome"`
	Email           string             `json:"email"`
	Telefone        string             `json:"telefone"`
	Cpf             string             `json:"cpf"`
	Especialidades  []string           `json:"especialidades"`
	Comissao        pgtype.Numeric     `json:"comissao"`
	TipoComissao    *string            `json:"tipo_comissao"`
	Foto            *string            `json:"foto"`
	DataAdmissao    pgtype.Date        `json:"data_admissao"`
	DataDemissao    pgtype.Date        `json:"data_demissao"`
	Status          *string            `json:"status"`
	HorarioTrabalho []byte             `json:"horario_trabalho"`
	Observacoes     *string            `json:"observacoes"`
	CriadoEm        pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm    pgtype.Timestamptz `json:"atualizado_em"`
	Tipo            string             `json:"tipo"`
}

func (q *Queries) ListBarbers(ctx context.Context, tenantID pgtype.UUID) ([]ListBarbersRow, error) {
	rows, err := q.db.Query(ctx, listBarbers, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBarbersRow{}
	for rows.Next() {
		var i ListBarbersRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.Nome,
			&i.Email,
			&i.Telefone,
			&i.Cpf,
			&i.Especialidades,
			&i.Comissao,
			&i.TipoComissao,
			&i.Foto,
			&i.DataAdmissao,
			&i.DataDemissao,
			&i.Status,
			&i.HorarioTrabalho,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.Tipo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfessionalCategoryCommissions = `-- name: ListProfessionalCategoryCommissions :many
SELECT id, tenant_id, profissional_id, categoria_id, comissao, criado_em, atualizado_em FROM comissoes_categoria_profissional
WHERE tenant_id = $1 AND profissional_id = $2
`

type ListProfessionalCategoryCommissionsParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ProfissionalID pgtype.UUID `json:"profissional_id"`
}

func (q *Queries) ListProfessionalCategoryCommissions(ctx context.Context, arg ListProfessionalCategoryCommissionsParams) ([]ComissoesCategoriaProfissional, error) {
	rows, err := q.db.Query(ctx, listProfessionalCategoryCommissions, arg.TenantID, arg.ProfissionalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ComissoesCategoriaProfissional{}
	for rows.Next() {
		var i ComissoesCategoriaProfissional
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProfissionalID,
			&i.CategoriaID,
			&i.Comissao,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfessionals = `-- name: ListProfessionals :many

SELECT id, tenant_id, user_id, nome, email, telefone, cpf, especialidades, 
       comissao, tipo_comissao, foto, data_admissao, data_demissao, status, 
       horario_trabalho, observacoes, criado_em, atualizado_em, tipo
FROM profissionais
WHERE tenant_id = $1
  AND ($2::text IS NULL OR status = $2)
  AND ($3::text IS NULL OR tipo = $3)
  AND (
    $4::text IS NULL 
    OR nome ILIKE '%' || $4 || '%'
    OR email ILIKE '%' || $4 || '%'
    OR cpf ILIKE '%' || $4 || '%'
  )
ORDER BY 
  CASE WHEN $5::text = 'nome' THEN nome END ASC,
  CASE WHEN $5::text = 'criado_em' OR $5::text IS NULL THEN criado_em END DESC,
  CASE WHEN $5::text = 'data_admissao' THEN data_admissao END DESC
LIMIT $7 OFFSET $6
`

type ListProfessionalsParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	Status     *string     `json:"status"`
	Tipo       *string     `json:"tipo"`
	Search     *string     `json:"search"`
	OrderBy    *string     `json:"order_by"`
	PageOffset int32       `json:"page_offset"`
	PageSize   int32       `json:"page_size"`
}

type ListProfessionalsRow struct {
	ID              pgtype.UUID        `json:"id"`
	TenantID        pgtype.UUID        `json:"tenant_id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Nome            string             `json:"nome"`
	Email           string             `json:"email"`
	Telefone        string             `json:"telefone"`
	Cpf             string             `json:"cpf"`
	Especialidades  []string           `json:"especialidades"`
	Comissao        pgtype.Numeric     `json:"comissao"`
	TipoComissao    *string            `json:"tipo_comissao"`
	Foto            *string            `json:"foto"`
	DataAdmissao    pgtype.Date        `json:"data_admissao"`
	DataDemissao    pgtype.Date        `json:"data_demissao"`
	Status          *string            `json:"status"`
	HorarioTrabalho []byte             `json:"horario_trabalho"`
	Observacoes     *string            `json:"observacoes"`
	CriadoEm        pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm    pgtype.Timestamptz `json:"atualizado_em"`
	Tipo            string             `json:"tipo"`
}

// =============================================================================
// QUERIES PARA PROFISSIONAIS
// =============================================================================
func (q *Queries) ListProfessionals(ctx context.Context, arg ListProfessionalsParams) ([]ListProfessionalsRow, error) {
	rows, err := q.db.Query(ctx, listProfessionals,
		arg.TenantID,
		arg.Status,
		arg.Tipo,
		arg.Search,
		arg.OrderBy,
		arg.PageOffset,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProfessionalsRow{}
	for rows.Next() {
		var i ListProfessionalsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.Nome,
			&i.Email,
			&i.Telefone,
			&i.Cpf,
			&i.Especialidades,
			&i.Comissao,
			&i.TipoComissao,
			&i.Foto,
			&i.DataAdmissao,
			&i.DataDemissao,
			&i.Status,
			&i.HorarioTrabalho,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.Tipo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProfessional = `-- name: UpdateProfessional :one
UPDATE profissionais SET
    nome = $1,
    email = $2,
    telefone = $3,
    cpf = $4,
    especialidades = $5,
    comissao = $6,
    tipo_comissao = $7,
    foto = $8,
    data_admissao = $9,
    data_demissao = $10,
    status = $11,
    horario_trabalho = $12,
    observacoes = $13,
    tipo = $14,
    atualizado_em = NOW()
WHERE id = $15 AND tenant_id = $16
RETURNING id, tenant_id, user_id, nome, email, telefone, cpf, especialidades, 
          comissao, tipo_comissao, foto, data_admissao, data_demissao, status, 
          horario_trabalho, observacoes, criado_em, atualizado_em, tipo
`

type UpdateProfessionalParams struct {
	Nome            string         `json:"nome"`
	Email           string         `json:"email"`
	Telefone        string         `json:"telefone"`
	Cpf             string         `json:"cpf"`
	Especialidades  []string       `json:"especialidades"`
	Comissao        pgtype.Numeric `json:"comissao"`
	TipoComissao    *string        `json:"tipo_comissao"`
	Foto            *string        `json:"foto"`
	DataAdmissao    pgtype.Date    `json:"data_admissao"`
	DataDemissao    pgtype.Date    `json:"data_demissao"`
	Status          *string        `json:"status"`
	HorarioTrabalho []byte         `json:"horario_trabalho"`
	Observacoes     *string        `json:"observacoes"`
	Tipo            string         `json:"tipo"`
	ID              pgtype.UUID    `json:"id"`
	TenantID        pgtype.UUID    `json:"tenant_id"`
}

type UpdateProfessionalRow struct {
	ID              pgtype.UUID        `json:"id"`
	TenantID        pgtype.UUID        `json:"tenant_id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Nome            string             `json:"nome"`
	Email           string             `json:"email"`
	Telefone        string             `json:"telefone"`
	Cpf             string             `json:"cpf"`
	Especialidades  []string           `json:"especialidades"`
	Comissao        pgtype.Numeric     `json:"comissao"`
	TipoComissao    *string            `json:"tipo_comissao"`
	Foto            *string            `json:"foto"`
	DataAdmissao    pgtype.Date        `json:"data_admissao"`
	DataDemissao    pgtype.Date        `json:"data_demissao"`
	Status          *string            `json:"status"`
	HorarioTrabalho []byte             `json:"horario_trabalho"`
	Observacoes     *string            `json:"observacoes"`
	CriadoEm        pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm    pgtype.Timestamptz `json:"atualizado_em"`
	Tipo            string             `json:"tipo"`
}

func (q *Queries) UpdateProfessional(ctx context.Context, arg UpdateProfessionalParams) (UpdateProfessionalRow, error) {
	row := q.db.QueryRow(ctx, updateProfessional,
		arg.Nome,
		arg.Email,
		arg.Telefone,
		arg.Cpf,
		arg.Especialidades,
		arg.Comissao,
		arg.TipoComissao,
		arg.Foto,
		arg.DataAdmissao,
		arg.DataDemissao,
		arg.Status,
		arg.HorarioTrabalho,
		arg.Observacoes,
		arg.Tipo,
		arg.ID,
		arg.TenantID,
	)
	var i UpdateProfessionalRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.Nome,
		&i.Email,
		&i.Telefone,
		&i.Cpf,
		&i.Especialidades,
		&i.Comissao,
		&i.TipoComissao,
		&i.Foto,
		&i.DataAdmissao,
		&i.DataDemissao,
		&i.Status,
		&i.HorarioTrabalho,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
		&i.Tipo,
	)
	return i, err
}

const updateProfessionalStatus = `-- name: UpdateProfessionalStatus :one
UPDATE profissionais SET
    status = $1,
    data_demissao = $2,
    atualizado_em = NOW()
WHERE id = $3 AND tenant_id = $4
RETURNING id, tenant_id, user_id, nome, email, telefone, cpf, especialidades, 
          comissao, tipo_comissao, foto, data_admissao, data_demissao, status, 
          horario_trabalho, observacoes, criado_em, atualizado_em, tipo
`

type UpdateProfessionalStatusParams struct {
	Status       *string     `json:"status"`
	DataDemissao pgtype.Date `json:"data_demissao"`
	ID           pgtype.UUID `json:"id"`
	TenantID     pgtype.UUID `json:"tenant_id"`
}

type UpdateProfessionalStatusRow struct {
	ID              pgtype.UUID        `json:"id"`
	TenantID        pgtype.UUID        `json:"tenant_id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Nome            string             `json:"nome"`
	Email           string             `json:"email"`
	Telefone        string             `json:"telefone"`
	Cpf             string             `json:"cpf"`
	Especialidades  []string           `json:"especialidades"`
	Comissao        pgtype.Numeric     `json:"comissao"`
	TipoComissao    *string            `json:"tipo_comissao"`
	Foto            *string            `json:"foto"`
	DataAdmissao    pgtype.Date        `json:"data_admissao"`
	DataDemissao    pgtype.Date        `json:"data_demissao"`
	Status          *string            `json:"status"`
	HorarioTrabalho []byte             `json:"horario_trabalho"`
	Observacoes     *string            `json:"observacoes"`
	CriadoEm        pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm    pgtype.Timestamptz `json:"atualizado_em"`
	Tipo            string             `json:"tipo"`
}

func (q *Queries) UpdateProfessionalStatus(ctx context.Context, arg UpdateProfessionalStatusParams) (UpdateProfessionalStatusRow, error) {
	row := q.db.QueryRow(ctx, updateProfessionalStatus,
		arg.Status,
		arg.DataDemissao,
		arg.ID,
		arg.TenantID,
	)
	var i UpdateProfessionalStatusRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.Nome,
		&i.Email,
		&i.Telefone,
		&i.Cpf,
		&i.Especialidades,
		&i.Comissao,
		&i.TipoComissao,
		&i.Foto,
		&i.DataAdmissao,
		&i.DataDemissao,
		&i.Status,
		&i.HorarioTrabalho,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
		&i.Tipo,
	)
	return i, err
}
