// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: units.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUnitsByTenant = `-- name: CountUnitsByTenant :one
SELECT COUNT(*) FROM units
WHERE tenant_id = $1
`

func (q *Queries) CountUnitsByTenant(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUnitsByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUnit = `-- name: CreateUnit :one

INSERT INTO units (
    tenant_id,
    nome,
    apelido,
    descricao,
    endereco_resumo,
    cidade,
    estado,
    timezone,
    ativa,
    is_matriz
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, tenant_id, nome, apelido, descricao, endereco_resumo, cidade, estado, timezone, ativa, is_matriz, criado_em, atualizado_em
`

type CreateUnitParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	Nome           string      `json:"nome"`
	Apelido        *string     `json:"apelido"`
	Descricao      *string     `json:"descricao"`
	EnderecoResumo *string     `json:"endereco_resumo"`
	Cidade         *string     `json:"cidade"`
	Estado         *string     `json:"estado"`
	Timezone       string      `json:"timezone"`
	Ativa          bool        `json:"ativa"`
	IsMatriz       bool        `json:"is_matriz"`
}

// ============================================================================
// SQLC Queries: Units (Unidades)
// ============================================================================
func (q *Queries) CreateUnit(ctx context.Context, arg CreateUnitParams) (Unit, error) {
	row := q.db.QueryRow(ctx, createUnit,
		arg.TenantID,
		arg.Nome,
		arg.Apelido,
		arg.Descricao,
		arg.EnderecoResumo,
		arg.Cidade,
		arg.Estado,
		arg.Timezone,
		arg.Ativa,
		arg.IsMatriz,
	)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Apelido,
		&i.Descricao,
		&i.EnderecoResumo,
		&i.Cidade,
		&i.Estado,
		&i.Timezone,
		&i.Ativa,
		&i.IsMatriz,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const deleteUnit = `-- name: DeleteUnit :exec
DELETE FROM units
WHERE id = $1 AND tenant_id = $2 AND is_matriz = false
`

type DeleteUnitParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteUnit(ctx context.Context, arg DeleteUnitParams) error {
	_, err := q.db.Exec(ctx, deleteUnit, arg.ID, arg.TenantID)
	return err
}

const getMatrizUnit = `-- name: GetMatrizUnit :one
SELECT id, tenant_id, nome, apelido, descricao, endereco_resumo, cidade, estado, timezone, ativa, is_matriz, criado_em, atualizado_em FROM units
WHERE tenant_id = $1 AND is_matriz = true
LIMIT 1
`

func (q *Queries) GetMatrizUnit(ctx context.Context, tenantID pgtype.UUID) (Unit, error) {
	row := q.db.QueryRow(ctx, getMatrizUnit, tenantID)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Apelido,
		&i.Descricao,
		&i.EnderecoResumo,
		&i.Cidade,
		&i.Estado,
		&i.Timezone,
		&i.Ativa,
		&i.IsMatriz,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getUnitByID = `-- name: GetUnitByID :one
SELECT id, tenant_id, nome, apelido, descricao, endereco_resumo, cidade, estado, timezone, ativa, is_matriz, criado_em, atualizado_em FROM units
WHERE id = $1 AND tenant_id = $2
`

type GetUnitByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetUnitByID(ctx context.Context, arg GetUnitByIDParams) (Unit, error) {
	row := q.db.QueryRow(ctx, getUnitByID, arg.ID, arg.TenantID)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Apelido,
		&i.Descricao,
		&i.EnderecoResumo,
		&i.Cidade,
		&i.Estado,
		&i.Timezone,
		&i.Ativa,
		&i.IsMatriz,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getUnitByName = `-- name: GetUnitByName :one
SELECT id, tenant_id, nome, apelido, descricao, endereco_resumo, cidade, estado, timezone, ativa, is_matriz, criado_em, atualizado_em FROM units
WHERE tenant_id = $1 AND nome = $2
`

type GetUnitByNameParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Nome     string      `json:"nome"`
}

func (q *Queries) GetUnitByName(ctx context.Context, arg GetUnitByNameParams) (Unit, error) {
	row := q.db.QueryRow(ctx, getUnitByName, arg.TenantID, arg.Nome)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Apelido,
		&i.Descricao,
		&i.EnderecoResumo,
		&i.Cidade,
		&i.Estado,
		&i.Timezone,
		&i.Ativa,
		&i.IsMatriz,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const listActiveUnitsByTenant = `-- name: ListActiveUnitsByTenant :many
SELECT id, tenant_id, nome, apelido, descricao, endereco_resumo, cidade, estado, timezone, ativa, is_matriz, criado_em, atualizado_em FROM units
WHERE tenant_id = $1 AND ativa = true
ORDER BY is_matriz DESC, nome
`

func (q *Queries) ListActiveUnitsByTenant(ctx context.Context, tenantID pgtype.UUID) ([]Unit, error) {
	rows, err := q.db.Query(ctx, listActiveUnitsByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Unit{}
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Nome,
			&i.Apelido,
			&i.Descricao,
			&i.EnderecoResumo,
			&i.Cidade,
			&i.Estado,
			&i.Timezone,
			&i.Ativa,
			&i.IsMatriz,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnitsByTenant = `-- name: ListUnitsByTenant :many
SELECT id, tenant_id, nome, apelido, descricao, endereco_resumo, cidade, estado, timezone, ativa, is_matriz, criado_em, atualizado_em FROM units
WHERE tenant_id = $1
ORDER BY is_matriz DESC, nome
`

func (q *Queries) ListUnitsByTenant(ctx context.Context, tenantID pgtype.UUID) ([]Unit, error) {
	rows, err := q.db.Query(ctx, listUnitsByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Unit{}
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Nome,
			&i.Apelido,
			&i.Descricao,
			&i.EnderecoResumo,
			&i.Cidade,
			&i.Estado,
			&i.Timezone,
			&i.Ativa,
			&i.IsMatriz,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setMatrizUnit = `-- name: SetMatrizUnit :exec
UPDATE units
SET is_matriz = CASE WHEN id = $1 THEN true ELSE false END,
    atualizado_em = NOW()
WHERE tenant_id = $2
`

type SetMatrizUnitParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) SetMatrizUnit(ctx context.Context, arg SetMatrizUnitParams) error {
	_, err := q.db.Exec(ctx, setMatrizUnit, arg.ID, arg.TenantID)
	return err
}

const toggleUnitStatus = `-- name: ToggleUnitStatus :one
UPDATE units
SET ativa = NOT ativa, atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, nome, apelido, descricao, endereco_resumo, cidade, estado, timezone, ativa, is_matriz, criado_em, atualizado_em
`

type ToggleUnitStatusParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) ToggleUnitStatus(ctx context.Context, arg ToggleUnitStatusParams) (Unit, error) {
	row := q.db.QueryRow(ctx, toggleUnitStatus, arg.ID, arg.TenantID)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Apelido,
		&i.Descricao,
		&i.EnderecoResumo,
		&i.Cidade,
		&i.Estado,
		&i.Timezone,
		&i.Ativa,
		&i.IsMatriz,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const updateUnit = `-- name: UpdateUnit :one
UPDATE units
SET
    nome = COALESCE(NULLIF($3, ''), nome),
    apelido = $4,
    descricao = $5,
    endereco_resumo = $6,
    cidade = $7,
    estado = $8,
    timezone = COALESCE(NULLIF($9, ''), timezone),
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, nome, apelido, descricao, endereco_resumo, cidade, estado, timezone, ativa, is_matriz, criado_em, atualizado_em
`

type UpdateUnitParams struct {
	ID             pgtype.UUID `json:"id"`
	TenantID       pgtype.UUID `json:"tenant_id"`
	Column3        interface{} `json:"column_3"`
	Apelido        *string     `json:"apelido"`
	Descricao      *string     `json:"descricao"`
	EnderecoResumo *string     `json:"endereco_resumo"`
	Cidade         *string     `json:"cidade"`
	Estado         *string     `json:"estado"`
	Column9        interface{} `json:"column_9"`
}

func (q *Queries) UpdateUnit(ctx context.Context, arg UpdateUnitParams) (Unit, error) {
	row := q.db.QueryRow(ctx, updateUnit,
		arg.ID,
		arg.TenantID,
		arg.Column3,
		arg.Apelido,
		arg.Descricao,
		arg.EnderecoResumo,
		arg.Cidade,
		arg.Estado,
		arg.Column9,
	)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Apelido,
		&i.Descricao,
		&i.EnderecoResumo,
		&i.Cidade,
		&i.Estado,
		&i.Timezone,
		&i.Ativa,
		&i.IsMatriz,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}
