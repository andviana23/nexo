// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: commission_items.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const bulkProcessCommissionItems = `-- name: BulkProcessCommissionItems :exec
UPDATE commission_items
SET
    status = 'PROCESSADO',
    period_id = $3,
    processed_at = NOW(),
    updated_at = NOW()
WHERE tenant_id = $1
  AND professional_id = $2
  AND status = 'PENDENTE'
  AND reference_date >= $4
  AND reference_date <= $5
`

type BulkProcessCommissionItemsParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	ProfessionalID  pgtype.UUID `json:"professional_id"`
	PeriodID        pgtype.UUID `json:"period_id"`
	ReferenceDate   pgtype.Date `json:"reference_date"`
	ReferenceDate_2 pgtype.Date `json:"reference_date_2"`
}

func (q *Queries) BulkProcessCommissionItems(ctx context.Context, arg BulkProcessCommissionItemsParams) error {
	_, err := q.db.Exec(ctx, bulkProcessCommissionItems,
		arg.TenantID,
		arg.ProfessionalID,
		arg.PeriodID,
		arg.ReferenceDate,
		arg.ReferenceDate_2,
	)
	return err
}

const cancelCommissionItem = `-- name: CancelCommissionItem :one
UPDATE commission_items
SET
    status = 'CANCELADO',
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2 AND status = 'PENDENTE'
RETURNING id, tenant_id, unit_id, professional_id, command_id, command_item_id, appointment_id, service_id, service_name, gross_value, commission_rate, commission_type, commission_value, commission_source, rule_id, reference_date, description, status, period_id, created_at, updated_at, processed_at
`

type CancelCommissionItemParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) CancelCommissionItem(ctx context.Context, arg CancelCommissionItemParams) (CommissionItem, error) {
	row := q.db.QueryRow(ctx, cancelCommissionItem, arg.ID, arg.TenantID)
	var i CommissionItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ProfessionalID,
		&i.CommandID,
		&i.CommandItemID,
		&i.AppointmentID,
		&i.ServiceID,
		&i.ServiceName,
		&i.GrossValue,
		&i.CommissionRate,
		&i.CommissionType,
		&i.CommissionValue,
		&i.CommissionSource,
		&i.RuleID,
		&i.ReferenceDate,
		&i.Description,
		&i.Status,
		&i.PeriodID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
	)
	return i, err
}

const countCommissionItemsByStatus = `-- name: CountCommissionItemsByStatus :one
SELECT
    COUNT(*) FILTER (WHERE status = 'PENDENTE') as pending,
    COUNT(*) FILTER (WHERE status = 'PROCESSADO') as processed,
    COUNT(*) FILTER (WHERE status = 'PAGO') as paid,
    COUNT(*) FILTER (WHERE status = 'CANCELADO') as cancelled,
    COUNT(*) FILTER (WHERE status = 'ESTORNADO') as reversed
FROM commission_items
WHERE tenant_id = $1
`

type CountCommissionItemsByStatusRow struct {
	Pending   int64 `json:"pending"`
	Processed int64 `json:"processed"`
	Paid      int64 `json:"paid"`
	Cancelled int64 `json:"cancelled"`
	Reversed  int64 `json:"reversed"`
}

func (q *Queries) CountCommissionItemsByStatus(ctx context.Context, tenantID pgtype.UUID) (CountCommissionItemsByStatusRow, error) {
	row := q.db.QueryRow(ctx, countCommissionItemsByStatus, tenantID)
	var i CountCommissionItemsByStatusRow
	err := row.Scan(
		&i.Pending,
		&i.Processed,
		&i.Paid,
		&i.Cancelled,
		&i.Reversed,
	)
	return i, err
}

const createCommissionItem = `-- name: CreateCommissionItem :one

INSERT INTO commission_items (
    tenant_id,
    unit_id,
    professional_id,
    command_id,
    command_item_id,
    appointment_id,
    service_id,
    service_name,
    gross_value,
    commission_rate,
    commission_type,
    commission_value,
    commission_source,
    rule_id,
    reference_date,
    description,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
) RETURNING id, tenant_id, unit_id, professional_id, command_id, command_item_id, appointment_id, service_id, service_name, gross_value, commission_rate, commission_type, commission_value, commission_source, rule_id, reference_date, description, status, period_id, created_at, updated_at, processed_at
`

type CreateCommissionItemParams struct {
	TenantID         pgtype.UUID     `json:"tenant_id"`
	UnitID           pgtype.UUID     `json:"unit_id"`
	ProfessionalID   pgtype.UUID     `json:"professional_id"`
	CommandID        pgtype.UUID     `json:"command_id"`
	CommandItemID    pgtype.UUID     `json:"command_item_id"`
	AppointmentID    pgtype.UUID     `json:"appointment_id"`
	ServiceID        pgtype.UUID     `json:"service_id"`
	ServiceName      *string         `json:"service_name"`
	GrossValue       decimal.Decimal `json:"gross_value"`
	CommissionRate   decimal.Decimal `json:"commission_rate"`
	CommissionType   string          `json:"commission_type"`
	CommissionValue  decimal.Decimal `json:"commission_value"`
	CommissionSource string          `json:"commission_source"`
	RuleID           pgtype.UUID     `json:"rule_id"`
	ReferenceDate    pgtype.Date     `json:"reference_date"`
	Description      *string         `json:"description"`
	Status           string          `json:"status"`
}

// ============================================================================
// QUERIES: commission_items
// Itens individuais de comissÃ£o
// ============================================================================
func (q *Queries) CreateCommissionItem(ctx context.Context, arg CreateCommissionItemParams) (CommissionItem, error) {
	row := q.db.QueryRow(ctx, createCommissionItem,
		arg.TenantID,
		arg.UnitID,
		arg.ProfessionalID,
		arg.CommandID,
		arg.CommandItemID,
		arg.AppointmentID,
		arg.ServiceID,
		arg.ServiceName,
		arg.GrossValue,
		arg.CommissionRate,
		arg.CommissionType,
		arg.CommissionValue,
		arg.CommissionSource,
		arg.RuleID,
		arg.ReferenceDate,
		arg.Description,
		arg.Status,
	)
	var i CommissionItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ProfessionalID,
		&i.CommandID,
		&i.CommandItemID,
		&i.AppointmentID,
		&i.ServiceID,
		&i.ServiceName,
		&i.GrossValue,
		&i.CommissionRate,
		&i.CommissionType,
		&i.CommissionValue,
		&i.CommissionSource,
		&i.RuleID,
		&i.ReferenceDate,
		&i.Description,
		&i.Status,
		&i.PeriodID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
	)
	return i, err
}

const deleteCommissionItem = `-- name: DeleteCommissionItem :exec
DELETE FROM commission_items
WHERE id = $1 AND tenant_id = $2 AND status = 'PENDENTE'
`

type DeleteCommissionItemParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteCommissionItem(ctx context.Context, arg DeleteCommissionItemParams) error {
	_, err := q.db.Exec(ctx, deleteCommissionItem, arg.ID, arg.TenantID)
	return err
}

const getCommissionItemByCommandItem = `-- name: GetCommissionItemByCommandItem :one
SELECT id, tenant_id, unit_id, professional_id, command_id, command_item_id, appointment_id, service_id, service_name, gross_value, commission_rate, commission_type, commission_value, commission_source, rule_id, reference_date, description, status, period_id, created_at, updated_at, processed_at FROM commission_items
WHERE tenant_id = $1
  AND command_item_id = $2
`

type GetCommissionItemByCommandItemParams struct {
	TenantID      pgtype.UUID `json:"tenant_id"`
	CommandItemID pgtype.UUID `json:"command_item_id"`
}

func (q *Queries) GetCommissionItemByCommandItem(ctx context.Context, arg GetCommissionItemByCommandItemParams) (CommissionItem, error) {
	row := q.db.QueryRow(ctx, getCommissionItemByCommandItem, arg.TenantID, arg.CommandItemID)
	var i CommissionItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ProfessionalID,
		&i.CommandID,
		&i.CommandItemID,
		&i.AppointmentID,
		&i.ServiceID,
		&i.ServiceName,
		&i.GrossValue,
		&i.CommissionRate,
		&i.CommissionType,
		&i.CommissionValue,
		&i.CommissionSource,
		&i.RuleID,
		&i.ReferenceDate,
		&i.Description,
		&i.Status,
		&i.PeriodID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
	)
	return i, err
}

const getCommissionItemByID = `-- name: GetCommissionItemByID :one
SELECT ci.id, ci.tenant_id, ci.unit_id, ci.professional_id, ci.command_id, ci.command_item_id, ci.appointment_id, ci.service_id, ci.service_name, ci.gross_value, ci.commission_rate, ci.commission_type, ci.commission_value, ci.commission_source, ci.rule_id, ci.reference_date, ci.description, ci.status, ci.period_id, ci.created_at, ci.updated_at, ci.processed_at,
       p.nome as professional_name,
       s.nome as service_display_name,
       u.nome as unit_name
FROM commission_items ci
JOIN profissionais p ON ci.professional_id = p.id
LEFT JOIN servicos s ON ci.service_id = s.id
LEFT JOIN units u ON ci.unit_id = u.id
WHERE ci.id = $1 AND ci.tenant_id = $2
`

type GetCommissionItemByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetCommissionItemByIDRow struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	UnitID             pgtype.UUID        `json:"unit_id"`
	ProfessionalID     pgtype.UUID        `json:"professional_id"`
	CommandID          pgtype.UUID        `json:"command_id"`
	CommandItemID      pgtype.UUID        `json:"command_item_id"`
	AppointmentID      pgtype.UUID        `json:"appointment_id"`
	ServiceID          pgtype.UUID        `json:"service_id"`
	ServiceName        *string            `json:"service_name"`
	GrossValue         decimal.Decimal    `json:"gross_value"`
	CommissionRate     decimal.Decimal    `json:"commission_rate"`
	CommissionType     string             `json:"commission_type"`
	CommissionValue    decimal.Decimal    `json:"commission_value"`
	CommissionSource   string             `json:"commission_source"`
	RuleID             pgtype.UUID        `json:"rule_id"`
	ReferenceDate      pgtype.Date        `json:"reference_date"`
	Description        *string            `json:"description"`
	Status             string             `json:"status"`
	PeriodID           pgtype.UUID        `json:"period_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ProcessedAt        pgtype.Timestamptz `json:"processed_at"`
	ProfessionalName   string             `json:"professional_name"`
	ServiceDisplayName *string            `json:"service_display_name"`
	UnitName           *string            `json:"unit_name"`
}

func (q *Queries) GetCommissionItemByID(ctx context.Context, arg GetCommissionItemByIDParams) (GetCommissionItemByIDRow, error) {
	row := q.db.QueryRow(ctx, getCommissionItemByID, arg.ID, arg.TenantID)
	var i GetCommissionItemByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ProfessionalID,
		&i.CommandID,
		&i.CommandItemID,
		&i.AppointmentID,
		&i.ServiceID,
		&i.ServiceName,
		&i.GrossValue,
		&i.CommissionRate,
		&i.CommissionType,
		&i.CommissionValue,
		&i.CommissionSource,
		&i.RuleID,
		&i.ReferenceDate,
		&i.Description,
		&i.Status,
		&i.PeriodID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
		&i.ProfessionalName,
		&i.ServiceDisplayName,
		&i.UnitName,
	)
	return i, err
}

const getCommissionSummaryByProfessionalAndMonth = `-- name: GetCommissionSummaryByProfessionalAndMonth :one
SELECT
    professional_id,
    COALESCE(SUM(gross_value), 0)::NUMERIC(15,2) as total_gross,
    COALESCE(SUM(commission_value), 0)::NUMERIC(15,2) as total_commission,
    COUNT(*) as items_count,
    COUNT(*) FILTER (WHERE status = 'PENDENTE') as pending_count,
    COUNT(*) FILTER (WHERE status = 'PROCESSADO') as processed_count,
    COUNT(*) FILTER (WHERE status = 'PAGO') as paid_count
FROM commission_items
WHERE tenant_id = $1
  AND professional_id = $2
  AND to_char(reference_date, 'YYYY-MM') = $3
  AND status != 'CANCELADO'
  AND status != 'ESTORNADO'
GROUP BY professional_id
`

type GetCommissionSummaryByProfessionalAndMonthParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ProfessionalID pgtype.UUID `json:"professional_id"`
	ReferenceDate  pgtype.Date `json:"reference_date"`
}

type GetCommissionSummaryByProfessionalAndMonthRow struct {
	ProfessionalID  pgtype.UUID     `json:"professional_id"`
	TotalGross      decimal.Decimal `json:"total_gross"`
	TotalCommission decimal.Decimal `json:"total_commission"`
	ItemsCount      int64           `json:"items_count"`
	PendingCount    int64           `json:"pending_count"`
	ProcessedCount  int64           `json:"processed_count"`
	PaidCount       int64           `json:"paid_count"`
}

func (q *Queries) GetCommissionSummaryByProfessionalAndMonth(ctx context.Context, arg GetCommissionSummaryByProfessionalAndMonthParams) (GetCommissionSummaryByProfessionalAndMonthRow, error) {
	row := q.db.QueryRow(ctx, getCommissionSummaryByProfessionalAndMonth, arg.TenantID, arg.ProfessionalID, arg.ReferenceDate)
	var i GetCommissionSummaryByProfessionalAndMonthRow
	err := row.Scan(
		&i.ProfessionalID,
		&i.TotalGross,
		&i.TotalCommission,
		&i.ItemsCount,
		&i.PendingCount,
		&i.ProcessedCount,
		&i.PaidCount,
	)
	return i, err
}

const getCommissionSummaryByService = `-- name: GetCommissionSummaryByService :many
SELECT
    service_id,
    service_name,
    COUNT(*) as items_count,
    SUM(gross_value)::NUMERIC(15,2) as total_gross,
    SUM(commission_value)::NUMERIC(15,2) as total_commission,
    AVG(commission_rate)::NUMERIC(5,2) as avg_rate
FROM commission_items
WHERE tenant_id = $1
  AND reference_date >= $2
  AND reference_date <= $3
  AND status != 'CANCELADO'
  AND status != 'ESTORNADO'
GROUP BY service_id, service_name
ORDER BY total_commission DESC
`

type GetCommissionSummaryByServiceParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	ReferenceDate   pgtype.Date `json:"reference_date"`
	ReferenceDate_2 pgtype.Date `json:"reference_date_2"`
}

type GetCommissionSummaryByServiceRow struct {
	ServiceID       pgtype.UUID     `json:"service_id"`
	ServiceName     *string         `json:"service_name"`
	ItemsCount      int64           `json:"items_count"`
	TotalGross      decimal.Decimal `json:"total_gross"`
	TotalCommission decimal.Decimal `json:"total_commission"`
	AvgRate         decimal.Decimal `json:"avg_rate"`
}

func (q *Queries) GetCommissionSummaryByService(ctx context.Context, arg GetCommissionSummaryByServiceParams) ([]GetCommissionSummaryByServiceRow, error) {
	rows, err := q.db.Query(ctx, getCommissionSummaryByService, arg.TenantID, arg.ReferenceDate, arg.ReferenceDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCommissionSummaryByServiceRow{}
	for rows.Next() {
		var i GetCommissionSummaryByServiceRow
		if err := rows.Scan(
			&i.ServiceID,
			&i.ServiceName,
			&i.ItemsCount,
			&i.TotalGross,
			&i.TotalCommission,
			&i.AvgRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommissionItemsByDateRange = `-- name: ListCommissionItemsByDateRange :many
SELECT ci.id, ci.tenant_id, ci.unit_id, ci.professional_id, ci.command_id, ci.command_item_id, ci.appointment_id, ci.service_id, ci.service_name, ci.gross_value, ci.commission_rate, ci.commission_type, ci.commission_value, ci.commission_source, ci.rule_id, ci.reference_date, ci.description, ci.status, ci.period_id, ci.created_at, ci.updated_at, ci.processed_at,
       p.nome as professional_name,
       s.nome as service_display_name,
       u.nome as unit_name
FROM commission_items ci
JOIN profissionais p ON ci.professional_id = p.id
LEFT JOIN servicos s ON ci.service_id = s.id
LEFT JOIN units u ON ci.unit_id = u.id
WHERE ci.tenant_id = $1
  AND ci.reference_date >= $2
  AND ci.reference_date <= $3
ORDER BY ci.reference_date ASC, p.nome ASC
`

type ListCommissionItemsByDateRangeParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	ReferenceDate   pgtype.Date `json:"reference_date"`
	ReferenceDate_2 pgtype.Date `json:"reference_date_2"`
}

type ListCommissionItemsByDateRangeRow struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	UnitID             pgtype.UUID        `json:"unit_id"`
	ProfessionalID     pgtype.UUID        `json:"professional_id"`
	CommandID          pgtype.UUID        `json:"command_id"`
	CommandItemID      pgtype.UUID        `json:"command_item_id"`
	AppointmentID      pgtype.UUID        `json:"appointment_id"`
	ServiceID          pgtype.UUID        `json:"service_id"`
	ServiceName        *string            `json:"service_name"`
	GrossValue         decimal.Decimal    `json:"gross_value"`
	CommissionRate     decimal.Decimal    `json:"commission_rate"`
	CommissionType     string             `json:"commission_type"`
	CommissionValue    decimal.Decimal    `json:"commission_value"`
	CommissionSource   string             `json:"commission_source"`
	RuleID             pgtype.UUID        `json:"rule_id"`
	ReferenceDate      pgtype.Date        `json:"reference_date"`
	Description        *string            `json:"description"`
	Status             string             `json:"status"`
	PeriodID           pgtype.UUID        `json:"period_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ProcessedAt        pgtype.Timestamptz `json:"processed_at"`
	ProfessionalName   string             `json:"professional_name"`
	ServiceDisplayName *string            `json:"service_display_name"`
	UnitName           *string            `json:"unit_name"`
}

func (q *Queries) ListCommissionItemsByDateRange(ctx context.Context, arg ListCommissionItemsByDateRangeParams) ([]ListCommissionItemsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, listCommissionItemsByDateRange, arg.TenantID, arg.ReferenceDate, arg.ReferenceDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommissionItemsByDateRangeRow{}
	for rows.Next() {
		var i ListCommissionItemsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ProfessionalID,
			&i.CommandID,
			&i.CommandItemID,
			&i.AppointmentID,
			&i.ServiceID,
			&i.ServiceName,
			&i.GrossValue,
			&i.CommissionRate,
			&i.CommissionType,
			&i.CommissionValue,
			&i.CommissionSource,
			&i.RuleID,
			&i.ReferenceDate,
			&i.Description,
			&i.Status,
			&i.PeriodID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProcessedAt,
			&i.ProfessionalName,
			&i.ServiceDisplayName,
			&i.UnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommissionItemsByPeriod = `-- name: ListCommissionItemsByPeriod :many
SELECT ci.id, ci.tenant_id, ci.unit_id, ci.professional_id, ci.command_id, ci.command_item_id, ci.appointment_id, ci.service_id, ci.service_name, ci.gross_value, ci.commission_rate, ci.commission_type, ci.commission_value, ci.commission_source, ci.rule_id, ci.reference_date, ci.description, ci.status, ci.period_id, ci.created_at, ci.updated_at, ci.processed_at,
       p.nome as professional_name,
       s.nome as service_display_name
FROM commission_items ci
JOIN profissionais p ON ci.professional_id = p.id
LEFT JOIN servicos s ON ci.service_id = s.id
WHERE ci.tenant_id = $1
  AND ci.period_id = $2
ORDER BY p.nome ASC, ci.reference_date ASC
`

type ListCommissionItemsByPeriodParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	PeriodID pgtype.UUID `json:"period_id"`
}

type ListCommissionItemsByPeriodRow struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	UnitID             pgtype.UUID        `json:"unit_id"`
	ProfessionalID     pgtype.UUID        `json:"professional_id"`
	CommandID          pgtype.UUID        `json:"command_id"`
	CommandItemID      pgtype.UUID        `json:"command_item_id"`
	AppointmentID      pgtype.UUID        `json:"appointment_id"`
	ServiceID          pgtype.UUID        `json:"service_id"`
	ServiceName        *string            `json:"service_name"`
	GrossValue         decimal.Decimal    `json:"gross_value"`
	CommissionRate     decimal.Decimal    `json:"commission_rate"`
	CommissionType     string             `json:"commission_type"`
	CommissionValue    decimal.Decimal    `json:"commission_value"`
	CommissionSource   string             `json:"commission_source"`
	RuleID             pgtype.UUID        `json:"rule_id"`
	ReferenceDate      pgtype.Date        `json:"reference_date"`
	Description        *string            `json:"description"`
	Status             string             `json:"status"`
	PeriodID           pgtype.UUID        `json:"period_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ProcessedAt        pgtype.Timestamptz `json:"processed_at"`
	ProfessionalName   string             `json:"professional_name"`
	ServiceDisplayName *string            `json:"service_display_name"`
}

func (q *Queries) ListCommissionItemsByPeriod(ctx context.Context, arg ListCommissionItemsByPeriodParams) ([]ListCommissionItemsByPeriodRow, error) {
	rows, err := q.db.Query(ctx, listCommissionItemsByPeriod, arg.TenantID, arg.PeriodID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommissionItemsByPeriodRow{}
	for rows.Next() {
		var i ListCommissionItemsByPeriodRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ProfessionalID,
			&i.CommandID,
			&i.CommandItemID,
			&i.AppointmentID,
			&i.ServiceID,
			&i.ServiceName,
			&i.GrossValue,
			&i.CommissionRate,
			&i.CommissionType,
			&i.CommissionValue,
			&i.CommissionSource,
			&i.RuleID,
			&i.ReferenceDate,
			&i.Description,
			&i.Status,
			&i.PeriodID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProcessedAt,
			&i.ProfessionalName,
			&i.ServiceDisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommissionItemsByProfessional = `-- name: ListCommissionItemsByProfessional :many
SELECT ci.id, ci.tenant_id, ci.unit_id, ci.professional_id, ci.command_id, ci.command_item_id, ci.appointment_id, ci.service_id, ci.service_name, ci.gross_value, ci.commission_rate, ci.commission_type, ci.commission_value, ci.commission_source, ci.rule_id, ci.reference_date, ci.description, ci.status, ci.period_id, ci.created_at, ci.updated_at, ci.processed_at,
       s.nome as service_display_name,
       u.nome as unit_name
FROM commission_items ci
LEFT JOIN servicos s ON ci.service_id = s.id
LEFT JOIN units u ON ci.unit_id = u.id
WHERE ci.tenant_id = $1
  AND ci.professional_id = $2
ORDER BY ci.reference_date DESC, ci.created_at DESC
LIMIT $3 OFFSET $4
`

type ListCommissionItemsByProfessionalParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ProfessionalID pgtype.UUID `json:"professional_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

type ListCommissionItemsByProfessionalRow struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	UnitID             pgtype.UUID        `json:"unit_id"`
	ProfessionalID     pgtype.UUID        `json:"professional_id"`
	CommandID          pgtype.UUID        `json:"command_id"`
	CommandItemID      pgtype.UUID        `json:"command_item_id"`
	AppointmentID      pgtype.UUID        `json:"appointment_id"`
	ServiceID          pgtype.UUID        `json:"service_id"`
	ServiceName        *string            `json:"service_name"`
	GrossValue         decimal.Decimal    `json:"gross_value"`
	CommissionRate     decimal.Decimal    `json:"commission_rate"`
	CommissionType     string             `json:"commission_type"`
	CommissionValue    decimal.Decimal    `json:"commission_value"`
	CommissionSource   string             `json:"commission_source"`
	RuleID             pgtype.UUID        `json:"rule_id"`
	ReferenceDate      pgtype.Date        `json:"reference_date"`
	Description        *string            `json:"description"`
	Status             string             `json:"status"`
	PeriodID           pgtype.UUID        `json:"period_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ProcessedAt        pgtype.Timestamptz `json:"processed_at"`
	ServiceDisplayName *string            `json:"service_display_name"`
	UnitName           *string            `json:"unit_name"`
}

func (q *Queries) ListCommissionItemsByProfessional(ctx context.Context, arg ListCommissionItemsByProfessionalParams) ([]ListCommissionItemsByProfessionalRow, error) {
	rows, err := q.db.Query(ctx, listCommissionItemsByProfessional,
		arg.TenantID,
		arg.ProfessionalID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommissionItemsByProfessionalRow{}
	for rows.Next() {
		var i ListCommissionItemsByProfessionalRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ProfessionalID,
			&i.CommandID,
			&i.CommandItemID,
			&i.AppointmentID,
			&i.ServiceID,
			&i.ServiceName,
			&i.GrossValue,
			&i.CommissionRate,
			&i.CommissionType,
			&i.CommissionValue,
			&i.CommissionSource,
			&i.RuleID,
			&i.ReferenceDate,
			&i.Description,
			&i.Status,
			&i.PeriodID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProcessedAt,
			&i.ServiceDisplayName,
			&i.UnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommissionItemsByProfessionalAndDateRange = `-- name: ListCommissionItemsByProfessionalAndDateRange :many
SELECT ci.id, ci.tenant_id, ci.unit_id, ci.professional_id, ci.command_id, ci.command_item_id, ci.appointment_id, ci.service_id, ci.service_name, ci.gross_value, ci.commission_rate, ci.commission_type, ci.commission_value, ci.commission_source, ci.rule_id, ci.reference_date, ci.description, ci.status, ci.period_id, ci.created_at, ci.updated_at, ci.processed_at,
       s.nome as service_display_name
FROM commission_items ci
LEFT JOIN servicos s ON ci.service_id = s.id
WHERE ci.tenant_id = $1
  AND ci.professional_id = $2
  AND ci.reference_date >= $3
  AND ci.reference_date <= $4
ORDER BY ci.reference_date ASC, ci.created_at ASC
`

type ListCommissionItemsByProfessionalAndDateRangeParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	ProfessionalID  pgtype.UUID `json:"professional_id"`
	ReferenceDate   pgtype.Date `json:"reference_date"`
	ReferenceDate_2 pgtype.Date `json:"reference_date_2"`
}

type ListCommissionItemsByProfessionalAndDateRangeRow struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	UnitID             pgtype.UUID        `json:"unit_id"`
	ProfessionalID     pgtype.UUID        `json:"professional_id"`
	CommandID          pgtype.UUID        `json:"command_id"`
	CommandItemID      pgtype.UUID        `json:"command_item_id"`
	AppointmentID      pgtype.UUID        `json:"appointment_id"`
	ServiceID          pgtype.UUID        `json:"service_id"`
	ServiceName        *string            `json:"service_name"`
	GrossValue         decimal.Decimal    `json:"gross_value"`
	CommissionRate     decimal.Decimal    `json:"commission_rate"`
	CommissionType     string             `json:"commission_type"`
	CommissionValue    decimal.Decimal    `json:"commission_value"`
	CommissionSource   string             `json:"commission_source"`
	RuleID             pgtype.UUID        `json:"rule_id"`
	ReferenceDate      pgtype.Date        `json:"reference_date"`
	Description        *string            `json:"description"`
	Status             string             `json:"status"`
	PeriodID           pgtype.UUID        `json:"period_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ProcessedAt        pgtype.Timestamptz `json:"processed_at"`
	ServiceDisplayName *string            `json:"service_display_name"`
}

func (q *Queries) ListCommissionItemsByProfessionalAndDateRange(ctx context.Context, arg ListCommissionItemsByProfessionalAndDateRangeParams) ([]ListCommissionItemsByProfessionalAndDateRangeRow, error) {
	rows, err := q.db.Query(ctx, listCommissionItemsByProfessionalAndDateRange,
		arg.TenantID,
		arg.ProfessionalID,
		arg.ReferenceDate,
		arg.ReferenceDate_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommissionItemsByProfessionalAndDateRangeRow{}
	for rows.Next() {
		var i ListCommissionItemsByProfessionalAndDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ProfessionalID,
			&i.CommandID,
			&i.CommandItemID,
			&i.AppointmentID,
			&i.ServiceID,
			&i.ServiceName,
			&i.GrossValue,
			&i.CommissionRate,
			&i.CommissionType,
			&i.CommissionValue,
			&i.CommissionSource,
			&i.RuleID,
			&i.ReferenceDate,
			&i.Description,
			&i.Status,
			&i.PeriodID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProcessedAt,
			&i.ServiceDisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommissionItemsByStatus = `-- name: ListCommissionItemsByStatus :many
SELECT ci.id, ci.tenant_id, ci.unit_id, ci.professional_id, ci.command_id, ci.command_item_id, ci.appointment_id, ci.service_id, ci.service_name, ci.gross_value, ci.commission_rate, ci.commission_type, ci.commission_value, ci.commission_source, ci.rule_id, ci.reference_date, ci.description, ci.status, ci.period_id, ci.created_at, ci.updated_at, ci.processed_at,
       p.nome as professional_name,
       s.nome as service_display_name,
       u.nome as unit_name
FROM commission_items ci
JOIN profissionais p ON ci.professional_id = p.id
LEFT JOIN servicos s ON ci.service_id = s.id
LEFT JOIN units u ON ci.unit_id = u.id
WHERE ci.tenant_id = $1
  AND ci.status = $2
ORDER BY ci.reference_date DESC, ci.created_at DESC
LIMIT $3 OFFSET $4
`

type ListCommissionItemsByStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListCommissionItemsByStatusRow struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	UnitID             pgtype.UUID        `json:"unit_id"`
	ProfessionalID     pgtype.UUID        `json:"professional_id"`
	CommandID          pgtype.UUID        `json:"command_id"`
	CommandItemID      pgtype.UUID        `json:"command_item_id"`
	AppointmentID      pgtype.UUID        `json:"appointment_id"`
	ServiceID          pgtype.UUID        `json:"service_id"`
	ServiceName        *string            `json:"service_name"`
	GrossValue         decimal.Decimal    `json:"gross_value"`
	CommissionRate     decimal.Decimal    `json:"commission_rate"`
	CommissionType     string             `json:"commission_type"`
	CommissionValue    decimal.Decimal    `json:"commission_value"`
	CommissionSource   string             `json:"commission_source"`
	RuleID             pgtype.UUID        `json:"rule_id"`
	ReferenceDate      pgtype.Date        `json:"reference_date"`
	Description        *string            `json:"description"`
	Status             string             `json:"status"`
	PeriodID           pgtype.UUID        `json:"period_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ProcessedAt        pgtype.Timestamptz `json:"processed_at"`
	ProfessionalName   string             `json:"professional_name"`
	ServiceDisplayName *string            `json:"service_display_name"`
	UnitName           *string            `json:"unit_name"`
}

func (q *Queries) ListCommissionItemsByStatus(ctx context.Context, arg ListCommissionItemsByStatusParams) ([]ListCommissionItemsByStatusRow, error) {
	rows, err := q.db.Query(ctx, listCommissionItemsByStatus,
		arg.TenantID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommissionItemsByStatusRow{}
	for rows.Next() {
		var i ListCommissionItemsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ProfessionalID,
			&i.CommandID,
			&i.CommandItemID,
			&i.AppointmentID,
			&i.ServiceID,
			&i.ServiceName,
			&i.GrossValue,
			&i.CommissionRate,
			&i.CommissionType,
			&i.CommissionValue,
			&i.CommissionSource,
			&i.RuleID,
			&i.ReferenceDate,
			&i.Description,
			&i.Status,
			&i.PeriodID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProcessedAt,
			&i.ProfessionalName,
			&i.ServiceDisplayName,
			&i.UnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommissionItemsByTenant = `-- name: ListCommissionItemsByTenant :many
SELECT ci.id, ci.tenant_id, ci.unit_id, ci.professional_id, ci.command_id, ci.command_item_id, ci.appointment_id, ci.service_id, ci.service_name, ci.gross_value, ci.commission_rate, ci.commission_type, ci.commission_value, ci.commission_source, ci.rule_id, ci.reference_date, ci.description, ci.status, ci.period_id, ci.created_at, ci.updated_at, ci.processed_at,
       p.nome as professional_name,
       s.nome as service_display_name,
       u.nome as unit_name
FROM commission_items ci
JOIN profissionais p ON ci.professional_id = p.id
LEFT JOIN servicos s ON ci.service_id = s.id
LEFT JOIN units u ON ci.unit_id = u.id
WHERE ci.tenant_id = $1
ORDER BY ci.reference_date DESC, ci.created_at DESC
LIMIT $2 OFFSET $3
`

type ListCommissionItemsByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListCommissionItemsByTenantRow struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	UnitID             pgtype.UUID        `json:"unit_id"`
	ProfessionalID     pgtype.UUID        `json:"professional_id"`
	CommandID          pgtype.UUID        `json:"command_id"`
	CommandItemID      pgtype.UUID        `json:"command_item_id"`
	AppointmentID      pgtype.UUID        `json:"appointment_id"`
	ServiceID          pgtype.UUID        `json:"service_id"`
	ServiceName        *string            `json:"service_name"`
	GrossValue         decimal.Decimal    `json:"gross_value"`
	CommissionRate     decimal.Decimal    `json:"commission_rate"`
	CommissionType     string             `json:"commission_type"`
	CommissionValue    decimal.Decimal    `json:"commission_value"`
	CommissionSource   string             `json:"commission_source"`
	RuleID             pgtype.UUID        `json:"rule_id"`
	ReferenceDate      pgtype.Date        `json:"reference_date"`
	Description        *string            `json:"description"`
	Status             string             `json:"status"`
	PeriodID           pgtype.UUID        `json:"period_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ProcessedAt        pgtype.Timestamptz `json:"processed_at"`
	ProfessionalName   string             `json:"professional_name"`
	ServiceDisplayName *string            `json:"service_display_name"`
	UnitName           *string            `json:"unit_name"`
}

func (q *Queries) ListCommissionItemsByTenant(ctx context.Context, arg ListCommissionItemsByTenantParams) ([]ListCommissionItemsByTenantRow, error) {
	rows, err := q.db.Query(ctx, listCommissionItemsByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommissionItemsByTenantRow{}
	for rows.Next() {
		var i ListCommissionItemsByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ProfessionalID,
			&i.CommandID,
			&i.CommandItemID,
			&i.AppointmentID,
			&i.ServiceID,
			&i.ServiceName,
			&i.GrossValue,
			&i.CommissionRate,
			&i.CommissionType,
			&i.CommissionValue,
			&i.CommissionSource,
			&i.RuleID,
			&i.ReferenceDate,
			&i.Description,
			&i.Status,
			&i.PeriodID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProcessedAt,
			&i.ProfessionalName,
			&i.ServiceDisplayName,
			&i.UnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingCommissionItems = `-- name: ListPendingCommissionItems :many
SELECT ci.id, ci.tenant_id, ci.unit_id, ci.professional_id, ci.command_id, ci.command_item_id, ci.appointment_id, ci.service_id, ci.service_name, ci.gross_value, ci.commission_rate, ci.commission_type, ci.commission_value, ci.commission_source, ci.rule_id, ci.reference_date, ci.description, ci.status, ci.period_id, ci.created_at, ci.updated_at, ci.processed_at,
       p.nome as professional_name,
       s.nome as service_display_name,
       u.nome as unit_name
FROM commission_items ci
JOIN profissionais p ON ci.professional_id = p.id
LEFT JOIN servicos s ON ci.service_id = s.id
LEFT JOIN units u ON ci.unit_id = u.id
WHERE ci.tenant_id = $1
  AND ci.status = 'PENDENTE'
ORDER BY ci.reference_date ASC, ci.created_at ASC
`

type ListPendingCommissionItemsRow struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	UnitID             pgtype.UUID        `json:"unit_id"`
	ProfessionalID     pgtype.UUID        `json:"professional_id"`
	CommandID          pgtype.UUID        `json:"command_id"`
	CommandItemID      pgtype.UUID        `json:"command_item_id"`
	AppointmentID      pgtype.UUID        `json:"appointment_id"`
	ServiceID          pgtype.UUID        `json:"service_id"`
	ServiceName        *string            `json:"service_name"`
	GrossValue         decimal.Decimal    `json:"gross_value"`
	CommissionRate     decimal.Decimal    `json:"commission_rate"`
	CommissionType     string             `json:"commission_type"`
	CommissionValue    decimal.Decimal    `json:"commission_value"`
	CommissionSource   string             `json:"commission_source"`
	RuleID             pgtype.UUID        `json:"rule_id"`
	ReferenceDate      pgtype.Date        `json:"reference_date"`
	Description        *string            `json:"description"`
	Status             string             `json:"status"`
	PeriodID           pgtype.UUID        `json:"period_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ProcessedAt        pgtype.Timestamptz `json:"processed_at"`
	ProfessionalName   string             `json:"professional_name"`
	ServiceDisplayName *string            `json:"service_display_name"`
	UnitName           *string            `json:"unit_name"`
}

func (q *Queries) ListPendingCommissionItems(ctx context.Context, tenantID pgtype.UUID) ([]ListPendingCommissionItemsRow, error) {
	rows, err := q.db.Query(ctx, listPendingCommissionItems, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingCommissionItemsRow{}
	for rows.Next() {
		var i ListPendingCommissionItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ProfessionalID,
			&i.CommandID,
			&i.CommandItemID,
			&i.AppointmentID,
			&i.ServiceID,
			&i.ServiceName,
			&i.GrossValue,
			&i.CommissionRate,
			&i.CommissionType,
			&i.CommissionValue,
			&i.CommissionSource,
			&i.RuleID,
			&i.ReferenceDate,
			&i.Description,
			&i.Status,
			&i.PeriodID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProcessedAt,
			&i.ProfessionalName,
			&i.ServiceDisplayName,
			&i.UnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingCommissionItemsByProfessional = `-- name: ListPendingCommissionItemsByProfessional :many
SELECT ci.id, ci.tenant_id, ci.unit_id, ci.professional_id, ci.command_id, ci.command_item_id, ci.appointment_id, ci.service_id, ci.service_name, ci.gross_value, ci.commission_rate, ci.commission_type, ci.commission_value, ci.commission_source, ci.rule_id, ci.reference_date, ci.description, ci.status, ci.period_id, ci.created_at, ci.updated_at, ci.processed_at,
       s.nome as service_display_name
FROM commission_items ci
LEFT JOIN servicos s ON ci.service_id = s.id
WHERE ci.tenant_id = $1
  AND ci.professional_id = $2
  AND ci.status = 'PENDENTE'
ORDER BY ci.reference_date ASC, ci.created_at ASC
`

type ListPendingCommissionItemsByProfessionalParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ProfessionalID pgtype.UUID `json:"professional_id"`
}

type ListPendingCommissionItemsByProfessionalRow struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	UnitID             pgtype.UUID        `json:"unit_id"`
	ProfessionalID     pgtype.UUID        `json:"professional_id"`
	CommandID          pgtype.UUID        `json:"command_id"`
	CommandItemID      pgtype.UUID        `json:"command_item_id"`
	AppointmentID      pgtype.UUID        `json:"appointment_id"`
	ServiceID          pgtype.UUID        `json:"service_id"`
	ServiceName        *string            `json:"service_name"`
	GrossValue         decimal.Decimal    `json:"gross_value"`
	CommissionRate     decimal.Decimal    `json:"commission_rate"`
	CommissionType     string             `json:"commission_type"`
	CommissionValue    decimal.Decimal    `json:"commission_value"`
	CommissionSource   string             `json:"commission_source"`
	RuleID             pgtype.UUID        `json:"rule_id"`
	ReferenceDate      pgtype.Date        `json:"reference_date"`
	Description        *string            `json:"description"`
	Status             string             `json:"status"`
	PeriodID           pgtype.UUID        `json:"period_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ProcessedAt        pgtype.Timestamptz `json:"processed_at"`
	ServiceDisplayName *string            `json:"service_display_name"`
}

func (q *Queries) ListPendingCommissionItemsByProfessional(ctx context.Context, arg ListPendingCommissionItemsByProfessionalParams) ([]ListPendingCommissionItemsByProfessionalRow, error) {
	rows, err := q.db.Query(ctx, listPendingCommissionItemsByProfessional, arg.TenantID, arg.ProfessionalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingCommissionItemsByProfessionalRow{}
	for rows.Next() {
		var i ListPendingCommissionItemsByProfessionalRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ProfessionalID,
			&i.CommandID,
			&i.CommandItemID,
			&i.AppointmentID,
			&i.ServiceID,
			&i.ServiceName,
			&i.GrossValue,
			&i.CommissionRate,
			&i.CommissionType,
			&i.CommissionValue,
			&i.CommissionSource,
			&i.RuleID,
			&i.ReferenceDate,
			&i.Description,
			&i.Status,
			&i.PeriodID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProcessedAt,
			&i.ServiceDisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markCommissionItemAsPaid = `-- name: MarkCommissionItemAsPaid :one
UPDATE commission_items
SET
    status = 'PAGO',
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2 AND status = 'PROCESSADO'
RETURNING id, tenant_id, unit_id, professional_id, command_id, command_item_id, appointment_id, service_id, service_name, gross_value, commission_rate, commission_type, commission_value, commission_source, rule_id, reference_date, description, status, period_id, created_at, updated_at, processed_at
`

type MarkCommissionItemAsPaidParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) MarkCommissionItemAsPaid(ctx context.Context, arg MarkCommissionItemAsPaidParams) (CommissionItem, error) {
	row := q.db.QueryRow(ctx, markCommissionItemAsPaid, arg.ID, arg.TenantID)
	var i CommissionItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ProfessionalID,
		&i.CommandID,
		&i.CommandItemID,
		&i.AppointmentID,
		&i.ServiceID,
		&i.ServiceName,
		&i.GrossValue,
		&i.CommissionRate,
		&i.CommissionType,
		&i.CommissionValue,
		&i.CommissionSource,
		&i.RuleID,
		&i.ReferenceDate,
		&i.Description,
		&i.Status,
		&i.PeriodID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
	)
	return i, err
}

const processCommissionItem = `-- name: ProcessCommissionItem :one
UPDATE commission_items
SET
    status = 'PROCESSADO',
    period_id = $3,
    processed_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2 AND status = 'PENDENTE'
RETURNING id, tenant_id, unit_id, professional_id, command_id, command_item_id, appointment_id, service_id, service_name, gross_value, commission_rate, commission_type, commission_value, commission_source, rule_id, reference_date, description, status, period_id, created_at, updated_at, processed_at
`

type ProcessCommissionItemParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	PeriodID pgtype.UUID `json:"period_id"`
}

func (q *Queries) ProcessCommissionItem(ctx context.Context, arg ProcessCommissionItemParams) (CommissionItem, error) {
	row := q.db.QueryRow(ctx, processCommissionItem, arg.ID, arg.TenantID, arg.PeriodID)
	var i CommissionItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ProfessionalID,
		&i.CommandID,
		&i.CommandItemID,
		&i.AppointmentID,
		&i.ServiceID,
		&i.ServiceName,
		&i.GrossValue,
		&i.CommissionRate,
		&i.CommissionType,
		&i.CommissionValue,
		&i.CommissionSource,
		&i.RuleID,
		&i.ReferenceDate,
		&i.Description,
		&i.Status,
		&i.PeriodID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
	)
	return i, err
}

const reverseCommissionItem = `-- name: ReverseCommissionItem :one
UPDATE commission_items
SET
    status = 'ESTORNADO',
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2 AND status IN ('PENDENTE', 'PROCESSADO')
RETURNING id, tenant_id, unit_id, professional_id, command_id, command_item_id, appointment_id, service_id, service_name, gross_value, commission_rate, commission_type, commission_value, commission_source, rule_id, reference_date, description, status, period_id, created_at, updated_at, processed_at
`

type ReverseCommissionItemParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) ReverseCommissionItem(ctx context.Context, arg ReverseCommissionItemParams) (CommissionItem, error) {
	row := q.db.QueryRow(ctx, reverseCommissionItem, arg.ID, arg.TenantID)
	var i CommissionItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ProfessionalID,
		&i.CommandID,
		&i.CommandItemID,
		&i.AppointmentID,
		&i.ServiceID,
		&i.ServiceName,
		&i.GrossValue,
		&i.CommissionRate,
		&i.CommissionType,
		&i.CommissionValue,
		&i.CommissionSource,
		&i.RuleID,
		&i.ReferenceDate,
		&i.Description,
		&i.Status,
		&i.PeriodID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
	)
	return i, err
}

const sumCommissionsByDateRange = `-- name: SumCommissionsByDateRange :one
SELECT
    COALESCE(SUM(gross_value), 0)::NUMERIC(15,2) as total_gross,
    COALESCE(SUM(commission_value), 0)::NUMERIC(15,2) as total_commission,
    COUNT(*) as items_count
FROM commission_items
WHERE tenant_id = $1
  AND reference_date >= $2
  AND reference_date <= $3
  AND status != 'CANCELADO'
  AND status != 'ESTORNADO'
`

type SumCommissionsByDateRangeParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	ReferenceDate   pgtype.Date `json:"reference_date"`
	ReferenceDate_2 pgtype.Date `json:"reference_date_2"`
}

type SumCommissionsByDateRangeRow struct {
	TotalGross      decimal.Decimal `json:"total_gross"`
	TotalCommission decimal.Decimal `json:"total_commission"`
	ItemsCount      int64           `json:"items_count"`
}

func (q *Queries) SumCommissionsByDateRange(ctx context.Context, arg SumCommissionsByDateRangeParams) (SumCommissionsByDateRangeRow, error) {
	row := q.db.QueryRow(ctx, sumCommissionsByDateRange, arg.TenantID, arg.ReferenceDate, arg.ReferenceDate_2)
	var i SumCommissionsByDateRangeRow
	err := row.Scan(&i.TotalGross, &i.TotalCommission, &i.ItemsCount)
	return i, err
}

const sumCommissionsByProfessionalAndDateRange = `-- name: SumCommissionsByProfessionalAndDateRange :one
SELECT
    COALESCE(SUM(gross_value), 0)::NUMERIC(15,2) as total_gross,
    COALESCE(SUM(commission_value), 0)::NUMERIC(15,2) as total_commission,
    COUNT(*) as items_count
FROM commission_items
WHERE tenant_id = $1
  AND professional_id = $2
  AND reference_date >= $3
  AND reference_date <= $4
  AND status != 'CANCELADO'
  AND status != 'ESTORNADO'
`

type SumCommissionsByProfessionalAndDateRangeParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	ProfessionalID  pgtype.UUID `json:"professional_id"`
	ReferenceDate   pgtype.Date `json:"reference_date"`
	ReferenceDate_2 pgtype.Date `json:"reference_date_2"`
}

type SumCommissionsByProfessionalAndDateRangeRow struct {
	TotalGross      decimal.Decimal `json:"total_gross"`
	TotalCommission decimal.Decimal `json:"total_commission"`
	ItemsCount      int64           `json:"items_count"`
}

func (q *Queries) SumCommissionsByProfessionalAndDateRange(ctx context.Context, arg SumCommissionsByProfessionalAndDateRangeParams) (SumCommissionsByProfessionalAndDateRangeRow, error) {
	row := q.db.QueryRow(ctx, sumCommissionsByProfessionalAndDateRange,
		arg.TenantID,
		arg.ProfessionalID,
		arg.ReferenceDate,
		arg.ReferenceDate_2,
	)
	var i SumCommissionsByProfessionalAndDateRangeRow
	err := row.Scan(&i.TotalGross, &i.TotalCommission, &i.ItemsCount)
	return i, err
}

const sumPendingCommissionsByProfessional = `-- name: SumPendingCommissionsByProfessional :one
SELECT
    COALESCE(SUM(gross_value), 0)::NUMERIC(15,2) as total_gross,
    COALESCE(SUM(commission_value), 0)::NUMERIC(15,2) as total_commission,
    COUNT(*) as items_count
FROM commission_items
WHERE tenant_id = $1
  AND professional_id = $2
  AND status = 'PENDENTE'
`

type SumPendingCommissionsByProfessionalParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ProfessionalID pgtype.UUID `json:"professional_id"`
}

type SumPendingCommissionsByProfessionalRow struct {
	TotalGross      decimal.Decimal `json:"total_gross"`
	TotalCommission decimal.Decimal `json:"total_commission"`
	ItemsCount      int64           `json:"items_count"`
}

func (q *Queries) SumPendingCommissionsByProfessional(ctx context.Context, arg SumPendingCommissionsByProfessionalParams) (SumPendingCommissionsByProfessionalRow, error) {
	row := q.db.QueryRow(ctx, sumPendingCommissionsByProfessional, arg.TenantID, arg.ProfessionalID)
	var i SumPendingCommissionsByProfessionalRow
	err := row.Scan(&i.TotalGross, &i.TotalCommission, &i.ItemsCount)
	return i, err
}

const updateCommissionItem = `-- name: UpdateCommissionItem :one
UPDATE commission_items
SET
    commission_rate = $3,
    commission_type = $4,
    commission_value = $5,
    commission_source = $6,
    description = $7,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, unit_id, professional_id, command_id, command_item_id, appointment_id, service_id, service_name, gross_value, commission_rate, commission_type, commission_value, commission_source, rule_id, reference_date, description, status, period_id, created_at, updated_at, processed_at
`

type UpdateCommissionItemParams struct {
	ID               pgtype.UUID     `json:"id"`
	TenantID         pgtype.UUID     `json:"tenant_id"`
	CommissionRate   decimal.Decimal `json:"commission_rate"`
	CommissionType   string          `json:"commission_type"`
	CommissionValue  decimal.Decimal `json:"commission_value"`
	CommissionSource string          `json:"commission_source"`
	Description      *string         `json:"description"`
}

func (q *Queries) UpdateCommissionItem(ctx context.Context, arg UpdateCommissionItemParams) (CommissionItem, error) {
	row := q.db.QueryRow(ctx, updateCommissionItem,
		arg.ID,
		arg.TenantID,
		arg.CommissionRate,
		arg.CommissionType,
		arg.CommissionValue,
		arg.CommissionSource,
		arg.Description,
	)
	var i CommissionItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ProfessionalID,
		&i.CommandID,
		&i.CommandItemID,
		&i.AppointmentID,
		&i.ServiceID,
		&i.ServiceName,
		&i.GrossValue,
		&i.CommissionRate,
		&i.CommissionType,
		&i.CommissionValue,
		&i.CommissionSource,
		&i.RuleID,
		&i.ReferenceDate,
		&i.Description,
		&i.Status,
		&i.PeriodID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
	)
	return i, err
}
