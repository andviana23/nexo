// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: categorias_produtos.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkCategoriaProdutoNomeExists = `-- name: CheckCategoriaProdutoNomeExists :one
SELECT EXISTS(
    SELECT 1 
    FROM categorias_produtos 
    WHERE tenant_id = $1 
      AND LOWER(nome) = LOWER($2)
      AND id != COALESCE($3, '00000000-0000-0000-0000-000000000000'::uuid)
) AS exists
`

type CheckCategoriaProdutoNomeExistsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Lower    string      `json:"lower"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) CheckCategoriaProdutoNomeExists(ctx context.Context, arg CheckCategoriaProdutoNomeExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkCategoriaProdutoNomeExists, arg.TenantID, arg.Lower, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countProdutosByCategoria = `-- name: CountProdutosByCategoria :one
SELECT COUNT(*) AS count
FROM produtos
WHERE tenant_id = $1 AND categoria_produto_id = $2
`

type CountProdutosByCategoriaParams struct {
	TenantID           pgtype.UUID `json:"tenant_id"`
	CategoriaProdutoID pgtype.UUID `json:"categoria_produto_id"`
}

func (q *Queries) CountProdutosByCategoria(ctx context.Context, arg CountProdutosByCategoriaParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProdutosByCategoria, arg.TenantID, arg.CategoriaProdutoID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCategoriaProduto = `-- name: CreateCategoriaProduto :one


INSERT INTO categorias_produtos (
    id,
    tenant_id,
    nome,
    descricao,
    cor,
    icone,
    centro_custo,
    ativa,
    criado_em,
    atualizado_em
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW()
) RETURNING id, tenant_id, nome, descricao, cor, icone, centro_custo, ativa, criado_em, atualizado_em
`

type CreateCategoriaProdutoParams struct {
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	Nome        string      `json:"nome"`
	Descricao   *string     `json:"descricao"`
	Cor         *string     `json:"cor"`
	Icone       *string     `json:"icone"`
	CentroCusto *string     `json:"centro_custo"`
	Ativa       bool        `json:"ativa"`
}

// ============================================================================
// CATEGORIAS DE PRODUTOS QUERIES (sqlc)
// Módulo de Estoque — NEXO v1.0
// Tabela: categorias_produtos (customizáveis por tenant)
// ============================================================================
// ============================================================================
// CREATE
// ============================================================================
func (q *Queries) CreateCategoriaProduto(ctx context.Context, arg CreateCategoriaProdutoParams) (CategoriasProduto, error) {
	row := q.db.QueryRow(ctx, createCategoriaProduto,
		arg.ID,
		arg.TenantID,
		arg.Nome,
		arg.Descricao,
		arg.Cor,
		arg.Icone,
		arg.CentroCusto,
		arg.Ativa,
	)
	var i CategoriasProduto
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Descricao,
		&i.Cor,
		&i.Icone,
		&i.CentroCusto,
		&i.Ativa,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const deleteCategoriaProduto = `-- name: DeleteCategoriaProduto :exec

DELETE FROM categorias_produtos
WHERE id = $1 AND tenant_id = $2
`

type DeleteCategoriaProdutoParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// ============================================================================
// DELETE
// ============================================================================
func (q *Queries) DeleteCategoriaProduto(ctx context.Context, arg DeleteCategoriaProdutoParams) error {
	_, err := q.db.Exec(ctx, deleteCategoriaProduto, arg.ID, arg.TenantID)
	return err
}

const getCategoriaProdutoByID = `-- name: GetCategoriaProdutoByID :one

SELECT 
    id,
    tenant_id,
    nome,
    descricao,
    cor,
    icone,
    centro_custo,
    ativa,
    criado_em,
    atualizado_em
FROM categorias_produtos
WHERE id = $1 AND tenant_id = $2
`

type GetCategoriaProdutoByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// ============================================================================
// READ
// ============================================================================
func (q *Queries) GetCategoriaProdutoByID(ctx context.Context, arg GetCategoriaProdutoByIDParams) (CategoriasProduto, error) {
	row := q.db.QueryRow(ctx, getCategoriaProdutoByID, arg.ID, arg.TenantID)
	var i CategoriasProduto
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Descricao,
		&i.Cor,
		&i.Icone,
		&i.CentroCusto,
		&i.Ativa,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getCategoriaProdutoByNome = `-- name: GetCategoriaProdutoByNome :one
SELECT 
    id,
    tenant_id,
    nome,
    descricao,
    cor,
    icone,
    centro_custo,
    ativa,
    criado_em,
    atualizado_em
FROM categorias_produtos
WHERE tenant_id = $1 AND LOWER(nome) = LOWER($2)
`

type GetCategoriaProdutoByNomeParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Lower    string      `json:"lower"`
}

func (q *Queries) GetCategoriaProdutoByNome(ctx context.Context, arg GetCategoriaProdutoByNomeParams) (CategoriasProduto, error) {
	row := q.db.QueryRow(ctx, getCategoriaProdutoByNome, arg.TenantID, arg.Lower)
	var i CategoriasProduto
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Descricao,
		&i.Cor,
		&i.Icone,
		&i.CentroCusto,
		&i.Ativa,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const listCategoriasProdutos = `-- name: ListCategoriasProdutos :many
SELECT 
    id,
    tenant_id,
    nome,
    descricao,
    cor,
    icone,
    centro_custo,
    ativa,
    criado_em,
    atualizado_em
FROM categorias_produtos
WHERE tenant_id = $1
ORDER BY nome ASC
`

func (q *Queries) ListCategoriasProdutos(ctx context.Context, tenantID pgtype.UUID) ([]CategoriasProduto, error) {
	rows, err := q.db.Query(ctx, listCategoriasProdutos, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CategoriasProduto{}
	for rows.Next() {
		var i CategoriasProduto
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Nome,
			&i.Descricao,
			&i.Cor,
			&i.Icone,
			&i.CentroCusto,
			&i.Ativa,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategoriasProdutosAtivas = `-- name: ListCategoriasProdutosAtivas :many
SELECT 
    id,
    tenant_id,
    nome,
    descricao,
    cor,
    icone,
    centro_custo,
    ativa,
    criado_em,
    atualizado_em
FROM categorias_produtos
WHERE tenant_id = $1 AND ativa = true
ORDER BY nome ASC
`

func (q *Queries) ListCategoriasProdutosAtivas(ctx context.Context, tenantID pgtype.UUID) ([]CategoriasProduto, error) {
	rows, err := q.db.Query(ctx, listCategoriasProdutosAtivas, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CategoriasProduto{}
	for rows.Next() {
		var i CategoriasProduto
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Nome,
			&i.Descricao,
			&i.Cor,
			&i.Icone,
			&i.CentroCusto,
			&i.Ativa,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleCategoriaProdutoAtiva = `-- name: ToggleCategoriaProdutoAtiva :one
UPDATE categorias_produtos
SET
    ativa = NOT ativa,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, nome, descricao, cor, icone, centro_custo, ativa, criado_em, atualizado_em
`

type ToggleCategoriaProdutoAtivaParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) ToggleCategoriaProdutoAtiva(ctx context.Context, arg ToggleCategoriaProdutoAtivaParams) (CategoriasProduto, error) {
	row := q.db.QueryRow(ctx, toggleCategoriaProdutoAtiva, arg.ID, arg.TenantID)
	var i CategoriasProduto
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Descricao,
		&i.Cor,
		&i.Icone,
		&i.CentroCusto,
		&i.Ativa,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const updateCategoriaProduto = `-- name: UpdateCategoriaProduto :one

UPDATE categorias_produtos
SET
    nome = $3,
    descricao = $4,
    cor = $5,
    icone = $6,
    centro_custo = $7,
    ativa = $8,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, nome, descricao, cor, icone, centro_custo, ativa, criado_em, atualizado_em
`

type UpdateCategoriaProdutoParams struct {
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	Nome        string      `json:"nome"`
	Descricao   *string     `json:"descricao"`
	Cor         *string     `json:"cor"`
	Icone       *string     `json:"icone"`
	CentroCusto *string     `json:"centro_custo"`
	Ativa       bool        `json:"ativa"`
}

// ============================================================================
// UPDATE
// ============================================================================
func (q *Queries) UpdateCategoriaProduto(ctx context.Context, arg UpdateCategoriaProdutoParams) (CategoriasProduto, error) {
	row := q.db.QueryRow(ctx, updateCategoriaProduto,
		arg.ID,
		arg.TenantID,
		arg.Nome,
		arg.Descricao,
		arg.Cor,
		arg.Icone,
		arg.CentroCusto,
		arg.Ativa,
	)
	var i CategoriasProduto
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Descricao,
		&i.Cor,
		&i.Icone,
		&i.CentroCusto,
		&i.Ativa,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}
