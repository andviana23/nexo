// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: commission_rules.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const countCommissionRulesByTenant = `-- name: CountCommissionRulesByTenant :one
SELECT COUNT(*) as total
FROM commission_rules
WHERE tenant_id = $1
`

func (q *Queries) CountCommissionRulesByTenant(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countCommissionRulesByTenant, tenantID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createCommissionRule = `-- name: CreateCommissionRule :one

INSERT INTO commission_rules (
    tenant_id,
    unit_id,
    name,
    description,
    type,
    default_rate,
    min_amount,
    max_amount,
    calculation_base,
    effective_from,
    effective_to,
    priority,
    is_active,
    created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, tenant_id, unit_id, name, description, type, default_rate, min_amount, max_amount, calculation_base, effective_from, effective_to, priority, is_active, created_at, updated_at, created_by
`

type CreateCommissionRuleParams struct {
	TenantID        pgtype.UUID     `json:"tenant_id"`
	UnitID          pgtype.UUID     `json:"unit_id"`
	Name            string          `json:"name"`
	Description     *string         `json:"description"`
	Type            string          `json:"type"`
	DefaultRate     decimal.Decimal `json:"default_rate"`
	MinAmount       pgtype.Numeric  `json:"min_amount"`
	MaxAmount       pgtype.Numeric  `json:"max_amount"`
	CalculationBase *string         `json:"calculation_base"`
	EffectiveFrom   pgtype.Date     `json:"effective_from"`
	EffectiveTo     pgtype.Date     `json:"effective_to"`
	Priority        *int32          `json:"priority"`
	IsActive        bool            `json:"is_active"`
	CreatedBy       pgtype.UUID     `json:"created_by"`
}

// ============================================================================
// QUERIES: commission_rules
// Regras de comissão
// ============================================================================
func (q *Queries) CreateCommissionRule(ctx context.Context, arg CreateCommissionRuleParams) (CommissionRule, error) {
	row := q.db.QueryRow(ctx, createCommissionRule,
		arg.TenantID,
		arg.UnitID,
		arg.Name,
		arg.Description,
		arg.Type,
		arg.DefaultRate,
		arg.MinAmount,
		arg.MaxAmount,
		arg.CalculationBase,
		arg.EffectiveFrom,
		arg.EffectiveTo,
		arg.Priority,
		arg.IsActive,
		arg.CreatedBy,
	)
	var i CommissionRule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.Name,
		&i.Description,
		&i.Type,
		&i.DefaultRate,
		&i.MinAmount,
		&i.MaxAmount,
		&i.CalculationBase,
		&i.EffectiveFrom,
		&i.EffectiveTo,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deactivateCommissionRule = `-- name: DeactivateCommissionRule :one
UPDATE commission_rules
SET
    is_active = false,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, unit_id, name, description, type, default_rate, min_amount, max_amount, calculation_base, effective_from, effective_to, priority, is_active, created_at, updated_at, created_by
`

type DeactivateCommissionRuleParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeactivateCommissionRule(ctx context.Context, arg DeactivateCommissionRuleParams) (CommissionRule, error) {
	row := q.db.QueryRow(ctx, deactivateCommissionRule, arg.ID, arg.TenantID)
	var i CommissionRule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.Name,
		&i.Description,
		&i.Type,
		&i.DefaultRate,
		&i.MinAmount,
		&i.MaxAmount,
		&i.CalculationBase,
		&i.EffectiveFrom,
		&i.EffectiveTo,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteCommissionRule = `-- name: DeleteCommissionRule :exec
DELETE FROM commission_rules
WHERE id = $1 AND tenant_id = $2
`

type DeleteCommissionRuleParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteCommissionRule(ctx context.Context, arg DeleteCommissionRuleParams) error {
	_, err := q.db.Exec(ctx, deleteCommissionRule, arg.ID, arg.TenantID)
	return err
}

const getCommissionRuleByID = `-- name: GetCommissionRuleByID :one
SELECT id, tenant_id, unit_id, name, description, type, default_rate, min_amount, max_amount, calculation_base, effective_from, effective_to, priority, is_active, created_at, updated_at, created_by FROM commission_rules
WHERE id = $1 AND tenant_id = $2
`

type GetCommissionRuleByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetCommissionRuleByID(ctx context.Context, arg GetCommissionRuleByIDParams) (CommissionRule, error) {
	row := q.db.QueryRow(ctx, getCommissionRuleByID, arg.ID, arg.TenantID)
	var i CommissionRule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.Name,
		&i.Description,
		&i.Type,
		&i.DefaultRate,
		&i.MinAmount,
		&i.MaxAmount,
		&i.CalculationBase,
		&i.EffectiveFrom,
		&i.EffectiveTo,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getCommissionRuleByUnit = `-- name: GetCommissionRuleByUnit :one
SELECT id, tenant_id, unit_id, name, description, type, default_rate, min_amount, max_amount, calculation_base, effective_from, effective_to, priority, is_active, created_at, updated_at, created_by FROM commission_rules
WHERE tenant_id = $1
  AND unit_id = $2
  AND is_active = true
  AND effective_from <= $3::date
  AND (effective_to IS NULL OR effective_to >= $3::date)
ORDER BY priority DESC
LIMIT 1
`

type GetCommissionRuleByUnitParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UnitID   pgtype.UUID `json:"unit_id"`
	Column3  pgtype.Date `json:"column_3"`
}

// COM-001: Busca regra vigente específica de uma unidade
func (q *Queries) GetCommissionRuleByUnit(ctx context.Context, arg GetCommissionRuleByUnitParams) (CommissionRule, error) {
	row := q.db.QueryRow(ctx, getCommissionRuleByUnit, arg.TenantID, arg.UnitID, arg.Column3)
	var i CommissionRule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.Name,
		&i.Description,
		&i.Type,
		&i.DefaultRate,
		&i.MinAmount,
		&i.MaxAmount,
		&i.CalculationBase,
		&i.EffectiveFrom,
		&i.EffectiveTo,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getDefaultCommissionRule = `-- name: GetDefaultCommissionRule :one
SELECT id, tenant_id, unit_id, name, description, type, default_rate, min_amount, max_amount, calculation_base, effective_from, effective_to, priority, is_active, created_at, updated_at, created_by FROM commission_rules
WHERE tenant_id = $1
  AND unit_id IS NULL
  AND is_active = true
  AND effective_from <= CURRENT_DATE
  AND (effective_to IS NULL OR effective_to >= CURRENT_DATE)
ORDER BY priority DESC
LIMIT 1
`

func (q *Queries) GetDefaultCommissionRule(ctx context.Context, tenantID pgtype.UUID) (CommissionRule, error) {
	row := q.db.QueryRow(ctx, getDefaultCommissionRule, tenantID)
	var i CommissionRule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.Name,
		&i.Description,
		&i.Type,
		&i.DefaultRate,
		&i.MinAmount,
		&i.MaxAmount,
		&i.CalculationBase,
		&i.EffectiveFrom,
		&i.EffectiveTo,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getGlobalCommissionRule = `-- name: GetGlobalCommissionRule :one
SELECT id, tenant_id, unit_id, name, description, type, default_rate, min_amount, max_amount, calculation_base, effective_from, effective_to, priority, is_active, created_at, updated_at, created_by FROM commission_rules
WHERE tenant_id = $1
  AND unit_id IS NULL
  AND is_active = true
  AND effective_from <= $2::date
  AND (effective_to IS NULL OR effective_to >= $2::date)
ORDER BY priority DESC
LIMIT 1
`

type GetGlobalCommissionRuleParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Column2  pgtype.Date `json:"column_2"`
}

// COM-001: Busca regra vigente global do tenant (unit_id IS NULL)
func (q *Queries) GetGlobalCommissionRule(ctx context.Context, arg GetGlobalCommissionRuleParams) (CommissionRule, error) {
	row := q.db.QueryRow(ctx, getGlobalCommissionRule, arg.TenantID, arg.Column2)
	var i CommissionRule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.Name,
		&i.Description,
		&i.Type,
		&i.DefaultRate,
		&i.MinAmount,
		&i.MaxAmount,
		&i.CalculationBase,
		&i.EffectiveFrom,
		&i.EffectiveTo,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const listCommissionRulesActive = `-- name: ListCommissionRulesActive :many
SELECT id, tenant_id, unit_id, name, description, type, default_rate, min_amount, max_amount, calculation_base, effective_from, effective_to, priority, is_active, created_at, updated_at, created_by FROM commission_rules
WHERE tenant_id = $1
  AND is_active = true
  AND effective_from <= CURRENT_DATE
  AND (effective_to IS NULL OR effective_to >= CURRENT_DATE)
ORDER BY priority DESC, created_at DESC
`

func (q *Queries) ListCommissionRulesActive(ctx context.Context, tenantID pgtype.UUID) ([]CommissionRule, error) {
	rows, err := q.db.Query(ctx, listCommissionRulesActive, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CommissionRule{}
	for rows.Next() {
		var i CommissionRule
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.Name,
			&i.Description,
			&i.Type,
			&i.DefaultRate,
			&i.MinAmount,
			&i.MaxAmount,
			&i.CalculationBase,
			&i.EffectiveFrom,
			&i.EffectiveTo,
			&i.Priority,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommissionRulesByTenant = `-- name: ListCommissionRulesByTenant :many
SELECT id, tenant_id, unit_id, name, description, type, default_rate, min_amount, max_amount, calculation_base, effective_from, effective_to, priority, is_active, created_at, updated_at, created_by FROM commission_rules
WHERE tenant_id = $1
ORDER BY priority DESC, created_at DESC
LIMIT $2 OFFSET $3
`

type ListCommissionRulesByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListCommissionRulesByTenant(ctx context.Context, arg ListCommissionRulesByTenantParams) ([]CommissionRule, error) {
	rows, err := q.db.Query(ctx, listCommissionRulesByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CommissionRule{}
	for rows.Next() {
		var i CommissionRule
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.Name,
			&i.Description,
			&i.Type,
			&i.DefaultRate,
			&i.MinAmount,
			&i.MaxAmount,
			&i.CalculationBase,
			&i.EffectiveFrom,
			&i.EffectiveTo,
			&i.Priority,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommissionRulesByUnit = `-- name: ListCommissionRulesByUnit :many
SELECT id, tenant_id, unit_id, name, description, type, default_rate, min_amount, max_amount, calculation_base, effective_from, effective_to, priority, is_active, created_at, updated_at, created_by FROM commission_rules
WHERE tenant_id = $1
  AND (unit_id = $2 OR unit_id IS NULL)
  AND is_active = true
  AND effective_from <= CURRENT_DATE
  AND (effective_to IS NULL OR effective_to >= CURRENT_DATE)
ORDER BY 
    CASE WHEN unit_id IS NOT NULL THEN 0 ELSE 1 END,
    priority DESC
`

type ListCommissionRulesByUnitParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UnitID   pgtype.UUID `json:"unit_id"`
}

func (q *Queries) ListCommissionRulesByUnit(ctx context.Context, arg ListCommissionRulesByUnitParams) ([]CommissionRule, error) {
	rows, err := q.db.Query(ctx, listCommissionRulesByUnit, arg.TenantID, arg.UnitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CommissionRule{}
	for rows.Next() {
		var i CommissionRule
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.Name,
			&i.Description,
			&i.Type,
			&i.DefaultRate,
			&i.MinAmount,
			&i.MaxAmount,
			&i.CalculationBase,
			&i.EffectiveFrom,
			&i.EffectiveTo,
			&i.Priority,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCommissionRule = `-- name: UpdateCommissionRule :one
UPDATE commission_rules
SET
    name = $3,
    description = $4,
    type = $5,
    default_rate = $6,
    min_amount = $7,
    max_amount = $8,
    calculation_base = $9,
    effective_from = $10,
    effective_to = $11,
    priority = $12,
    is_active = $13,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, unit_id, name, description, type, default_rate, min_amount, max_amount, calculation_base, effective_from, effective_to, priority, is_active, created_at, updated_at, created_by
`

type UpdateCommissionRuleParams struct {
	ID              pgtype.UUID     `json:"id"`
	TenantID        pgtype.UUID     `json:"tenant_id"`
	Name            string          `json:"name"`
	Description     *string         `json:"description"`
	Type            string          `json:"type"`
	DefaultRate     decimal.Decimal `json:"default_rate"`
	MinAmount       pgtype.Numeric  `json:"min_amount"`
	MaxAmount       pgtype.Numeric  `json:"max_amount"`
	CalculationBase *string         `json:"calculation_base"`
	EffectiveFrom   pgtype.Date     `json:"effective_from"`
	EffectiveTo     pgtype.Date     `json:"effective_to"`
	Priority        *int32          `json:"priority"`
	IsActive        bool            `json:"is_active"`
}

func (q *Queries) UpdateCommissionRule(ctx context.Context, arg UpdateCommissionRuleParams) (CommissionRule, error) {
	row := q.db.QueryRow(ctx, updateCommissionRule,
		arg.ID,
		arg.TenantID,
		arg.Name,
		arg.Description,
		arg.Type,
		arg.DefaultRate,
		arg.MinAmount,
		arg.MaxAmount,
		arg.CalculationBase,
		arg.EffectiveFrom,
		arg.EffectiveTo,
		arg.Priority,
		arg.IsActive,
	)
	var i CommissionRule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.Name,
		&i.Description,
		&i.Type,
		&i.DefaultRate,
		&i.MinAmount,
		&i.MaxAmount,
		&i.CalculationBase,
		&i.EffectiveFrom,
		&i.EffectiveTo,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}
