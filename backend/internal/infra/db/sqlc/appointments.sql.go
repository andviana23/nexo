// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: appointments.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const checkAppointmentConflict = `-- name: CheckAppointmentConflict :one
SELECT EXISTS (
    SELECT 1 FROM appointments
    WHERE tenant_id = $1
      AND professional_id = $2
      AND id != $3
      AND status NOT IN ('CANCELED', 'NO_SHOW')
      AND start_time < $5
      AND end_time > $4
) as has_conflict
`

type CheckAppointmentConflictParams struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	ProfessionalID pgtype.UUID        `json:"professional_id"`
	ID             pgtype.UUID        `json:"id"`
	EndTime        pgtype.Timestamptz `json:"end_time"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
}

// Verifica conflito com agendamentos existentes
// Parâmetros: tenant_id, professional_id, exclude_id, start_time, end_time
func (q *Queries) CheckAppointmentConflict(ctx context.Context, arg CheckAppointmentConflictParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkAppointmentConflict,
		arg.TenantID,
		arg.ProfessionalID,
		arg.ID,
		arg.EndTime,
		arg.StartTime,
	)
	var has_conflict bool
	err := row.Scan(&has_conflict)
	return has_conflict, err
}

const checkBlockedTimeConflictForAppointment = `-- name: CheckBlockedTimeConflictForAppointment :one
SELECT EXISTS (
    SELECT 1 FROM blocked_times
    WHERE tenant_id = $1::uuid
      AND professional_id = $2::uuid
      AND start_time < $3::timestamptz
      AND end_time > $4::timestamptz
) as has_blocked_conflict
`

type CheckBlockedTimeConflictForAppointmentParams struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	ProfessionalID pgtype.UUID        `json:"professional_id"`
	EndTime        pgtype.Timestamptz `json:"end_time"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
}

// Verifica se há conflito com horários bloqueados (blocked_times)
func (q *Queries) CheckBlockedTimeConflictForAppointment(ctx context.Context, arg CheckBlockedTimeConflictForAppointmentParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkBlockedTimeConflictForAppointment,
		arg.TenantID,
		arg.ProfessionalID,
		arg.EndTime,
		arg.StartTime,
	)
	var has_blocked_conflict bool
	err := row.Scan(&has_blocked_conflict)
	return has_blocked_conflict, err
}

const checkInAppointment = `-- name: CheckInAppointment :one
UPDATE appointments
SET
    status = 'CHECKED_IN',
    checked_in_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
  AND status IN ('CREATED', 'CONFIRMED')
RETURNING id, tenant_id, professional_id, customer_id, start_time, end_time, status, total_price, notes, canceled_reason, google_calendar_event_id, command_id, checked_in_at, started_at, finished_at, created_at, updated_at
`

type CheckInAppointmentParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Marca que o cliente chegou para o atendimento
func (q *Queries) CheckInAppointment(ctx context.Context, arg CheckInAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, checkInAppointment, arg.ID, arg.TenantID)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CustomerID,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.TotalPrice,
		&i.Notes,
		&i.CanceledReason,
		&i.GoogleCalendarEventID,
		&i.CommandID,
		&i.CheckedInAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const checkMinimumIntervalConflict = `-- name: CheckMinimumIntervalConflict :one
SELECT EXISTS (
    SELECT 1 FROM appointments
    WHERE tenant_id = $1::uuid
      AND professional_id = $2::uuid
      AND id != $3::uuid
      AND status NOT IN ('CANCELED', 'NO_SHOW')
      AND (
          -- Agendamento existente termina menos de X minutos antes do novo início
          (end_time > $4::timestamptz - ($5::int * interval '1 minute') AND end_time <= $4::timestamptz)
          OR
          -- Novo agendamento termina menos de X minutos antes do início existente
          ($6::timestamptz > start_time - ($5::int * interval '1 minute') AND $6::timestamptz <= start_time)
      )
) as has_interval_conflict
`

type CheckMinimumIntervalConflictParams struct {
	TenantID        pgtype.UUID        `json:"tenant_id"`
	ProfessionalID  pgtype.UUID        `json:"professional_id"`
	ExcludeID       pgtype.UUID        `json:"exclude_id"`
	StartTime       pgtype.Timestamptz `json:"start_time"`
	IntervalMinutes int32              `json:"interval_minutes"`
	EndTime         pgtype.Timestamptz `json:"end_time"`
}

// Verifica se há conflito de intervalo mínimo (10 minutos entre agendamentos)
// Um agendamento que termina exatamente quando outro começa não é conflito,
// mas se o intervalo for menor que 10 minutos, é conflito.
func (q *Queries) CheckMinimumIntervalConflict(ctx context.Context, arg CheckMinimumIntervalConflictParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkMinimumIntervalConflict,
		arg.TenantID,
		arg.ProfessionalID,
		arg.ExcludeID,
		arg.StartTime,
		arg.IntervalMinutes,
		arg.EndTime,
	)
	var has_interval_conflict bool
	err := row.Scan(&has_interval_conflict)
	return has_interval_conflict, err
}

const completeAppointment = `-- name: CompleteAppointment :one
UPDATE appointments
SET
    status = 'DONE',
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
  AND status = 'AWAITING_PAYMENT'
RETURNING id, tenant_id, professional_id, customer_id, start_time, end_time, status, total_price, notes, canceled_reason, google_calendar_event_id, command_id, checked_in_at, started_at, finished_at, created_at, updated_at
`

type CompleteAppointmentParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Completa o agendamento após pagamento confirmado
func (q *Queries) CompleteAppointment(ctx context.Context, arg CompleteAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, completeAppointment, arg.ID, arg.TenantID)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CustomerID,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.TotalPrice,
		&i.Notes,
		&i.CanceledReason,
		&i.GoogleCalendarEventID,
		&i.CommandID,
		&i.CheckedInAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countAppointments = `-- name: CountAppointments :one
SELECT COUNT(*)
FROM appointments a
WHERE a.tenant_id = $1
  AND ($2::uuid IS NULL OR a.professional_id = $2)
  AND ($3::uuid IS NULL OR a.customer_id = $3)
  AND (COALESCE(array_length($4::text[], 1), 0) = 0 OR a.status = ANY($4::text[]))
  AND ($5::timestamptz IS NULL OR a.start_time >= $5)
  AND ($6::timestamptz IS NULL OR a.start_time < $6)
`

type CountAppointmentsParams struct {
	TenantID pgtype.UUID        `json:"tenant_id"`
	Column2  pgtype.UUID        `json:"column_2"`
	Column3  pgtype.UUID        `json:"column_3"`
	Column4  []string           `json:"column_4"`
	Column5  pgtype.Timestamptz `json:"column_5"`
	Column6  pgtype.Timestamptz `json:"column_6"`
}

func (q *Queries) CountAppointments(ctx context.Context, arg CountAppointmentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAppointments,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAppointmentsByStatus = `-- name: CountAppointmentsByStatus :one
SELECT COUNT(*)
FROM appointments
WHERE tenant_id = $1 AND status = $2
`

type CountAppointmentsByStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
}

func (q *Queries) CountAppointmentsByStatus(ctx context.Context, arg CountAppointmentsByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAppointmentsByStatus, arg.TenantID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAppointment = `-- name: CreateAppointment :one

INSERT INTO appointments (
    id,
    tenant_id,
    professional_id,
    customer_id,
    start_time,
    end_time,
    status,
    total_price,
    notes,
    canceled_reason,
    google_calendar_event_id,
    command_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, tenant_id, professional_id, customer_id, start_time, end_time, status, total_price, notes, canceled_reason, google_calendar_event_id, command_id, checked_in_at, started_at, finished_at, created_at, updated_at
`

type CreateAppointmentParams struct {
	ID                    pgtype.UUID        `json:"id"`
	TenantID              pgtype.UUID        `json:"tenant_id"`
	ProfessionalID        pgtype.UUID        `json:"professional_id"`
	CustomerID            pgtype.UUID        `json:"customer_id"`
	StartTime             pgtype.Timestamptz `json:"start_time"`
	EndTime               pgtype.Timestamptz `json:"end_time"`
	Status                string             `json:"status"`
	TotalPrice            decimal.Decimal    `json:"total_price"`
	Notes                 *string            `json:"notes"`
	CanceledReason        *string            `json:"canceled_reason"`
	GoogleCalendarEventID *string            `json:"google_calendar_event_id"`
	CommandID             pgtype.UUID        `json:"command_id"`
}

// ============================================================================
// APPOINTMENTS QUERIES (sqlc)
// Módulo de Agendamento — NEXO v1.0
// ============================================================================
func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, createAppointment,
		arg.ID,
		arg.TenantID,
		arg.ProfessionalID,
		arg.CustomerID,
		arg.StartTime,
		arg.EndTime,
		arg.Status,
		arg.TotalPrice,
		arg.Notes,
		arg.CanceledReason,
		arg.GoogleCalendarEventID,
		arg.CommandID,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CustomerID,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.TotalPrice,
		&i.Notes,
		&i.CanceledReason,
		&i.GoogleCalendarEventID,
		&i.CommandID,
		&i.CheckedInAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createAppointmentService = `-- name: CreateAppointmentService :exec
INSERT INTO appointment_services (
    appointment_id,
    service_id,
    price_at_booking,
    duration_at_booking
) VALUES (
    $1, $2, $3, $4
)
`

type CreateAppointmentServiceParams struct {
	AppointmentID     pgtype.UUID     `json:"appointment_id"`
	ServiceID         pgtype.UUID     `json:"service_id"`
	PriceAtBooking    decimal.Decimal `json:"price_at_booking"`
	DurationAtBooking int32           `json:"duration_at_booking"`
}

func (q *Queries) CreateAppointmentService(ctx context.Context, arg CreateAppointmentServiceParams) error {
	_, err := q.db.Exec(ctx, createAppointmentService,
		arg.AppointmentID,
		arg.ServiceID,
		arg.PriceAtBooking,
		arg.DurationAtBooking,
	)
	return err
}

const customerExists = `-- name: CustomerExists :one
SELECT EXISTS (
    SELECT 1 FROM clientes
    WHERE id = $1 AND tenant_id = $2 AND ativo = true
) as exists
`

type CustomerExistsParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) CustomerExists(ctx context.Context, arg CustomerExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, customerExists, arg.ID, arg.TenantID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const deleteAppointment = `-- name: DeleteAppointment :exec
UPDATE appointments
SET
    status = 'CANCELED',
    canceled_reason = 'Removido pelo sistema',
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type DeleteAppointmentParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteAppointment(ctx context.Context, arg DeleteAppointmentParams) error {
	_, err := q.db.Exec(ctx, deleteAppointment, arg.ID, arg.TenantID)
	return err
}

const deleteAppointmentServices = `-- name: DeleteAppointmentServices :exec
DELETE FROM appointment_services
WHERE appointment_id = $1
`

func (q *Queries) DeleteAppointmentServices(ctx context.Context, appointmentID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAppointmentServices, appointmentID)
	return err
}

const finishAppointment = `-- name: FinishAppointment :one
UPDATE appointments
SET
    status = 'AWAITING_PAYMENT',
    finished_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
  AND status = 'IN_SERVICE'
RETURNING id, tenant_id, professional_id, customer_id, start_time, end_time, status, total_price, notes, canceled_reason, google_calendar_event_id, command_id, checked_in_at, started_at, finished_at, created_at, updated_at
`

type FinishAppointmentParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Finaliza o atendimento (serviços concluídos, aguardando pagamento)
func (q *Queries) FinishAppointment(ctx context.Context, arg FinishAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, finishAppointment, arg.ID, arg.TenantID)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CustomerID,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.TotalPrice,
		&i.Notes,
		&i.CanceledReason,
		&i.GoogleCalendarEventID,
		&i.CommandID,
		&i.CheckedInAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAppointmentByID = `-- name: GetAppointmentByID :one
SELECT 
    a.id, a.tenant_id, a.professional_id, a.customer_id, a.start_time, a.end_time, a.status, a.total_price, a.notes, a.canceled_reason, a.google_calendar_event_id, a.command_id, a.checked_in_at, a.started_at, a.finished_at, a.created_at, a.updated_at,
    p.nome as professional_name,
    c.nome as customer_name,
    c.telefone as customer_phone
FROM appointments a
JOIN profissionais p ON p.id = a.professional_id
JOIN clientes c ON c.id = a.customer_id
WHERE a.id = $1 AND a.tenant_id = $2
`

type GetAppointmentByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetAppointmentByIDRow struct {
	ID                    pgtype.UUID        `json:"id"`
	TenantID              pgtype.UUID        `json:"tenant_id"`
	ProfessionalID        pgtype.UUID        `json:"professional_id"`
	CustomerID            pgtype.UUID        `json:"customer_id"`
	StartTime             pgtype.Timestamptz `json:"start_time"`
	EndTime               pgtype.Timestamptz `json:"end_time"`
	Status                string             `json:"status"`
	TotalPrice            decimal.Decimal    `json:"total_price"`
	Notes                 *string            `json:"notes"`
	CanceledReason        *string            `json:"canceled_reason"`
	GoogleCalendarEventID *string            `json:"google_calendar_event_id"`
	CommandID             pgtype.UUID        `json:"command_id"`
	CheckedInAt           pgtype.Timestamptz `json:"checked_in_at"`
	StartedAt             pgtype.Timestamptz `json:"started_at"`
	FinishedAt            pgtype.Timestamptz `json:"finished_at"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	ProfessionalName      string             `json:"professional_name"`
	CustomerName          string             `json:"customer_name"`
	CustomerPhone         string             `json:"customer_phone"`
}

func (q *Queries) GetAppointmentByID(ctx context.Context, arg GetAppointmentByIDParams) (GetAppointmentByIDRow, error) {
	row := q.db.QueryRow(ctx, getAppointmentByID, arg.ID, arg.TenantID)
	var i GetAppointmentByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CustomerID,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.TotalPrice,
		&i.Notes,
		&i.CanceledReason,
		&i.GoogleCalendarEventID,
		&i.CommandID,
		&i.CheckedInAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProfessionalName,
		&i.CustomerName,
		&i.CustomerPhone,
	)
	return i, err
}

const getAppointmentServices = `-- name: GetAppointmentServices :many
SELECT 
    aps.appointment_id, aps.service_id, aps.price_at_booking, aps.duration_at_booking, aps.created_at,
    s.nome as service_name
FROM appointment_services aps
JOIN servicos s ON s.id = aps.service_id
WHERE aps.appointment_id = $1
`

type GetAppointmentServicesRow struct {
	AppointmentID     pgtype.UUID        `json:"appointment_id"`
	ServiceID         pgtype.UUID        `json:"service_id"`
	PriceAtBooking    decimal.Decimal    `json:"price_at_booking"`
	DurationAtBooking int32              `json:"duration_at_booking"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	ServiceName       string             `json:"service_name"`
}

func (q *Queries) GetAppointmentServices(ctx context.Context, appointmentID pgtype.UUID) ([]GetAppointmentServicesRow, error) {
	rows, err := q.db.Query(ctx, getAppointmentServices, appointmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAppointmentServicesRow{}
	for rows.Next() {
		var i GetAppointmentServicesRow
		if err := rows.Scan(
			&i.AppointmentID,
			&i.ServiceID,
			&i.PriceAtBooking,
			&i.DurationAtBooking,
			&i.CreatedAt,
			&i.ServiceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerInfo = `-- name: GetCustomerInfo :one
SELECT id, nome, telefone, email
FROM clientes
WHERE id = $1 AND tenant_id = $2
`

type GetCustomerInfoParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetCustomerInfoRow struct {
	ID       pgtype.UUID `json:"id"`
	Nome     string      `json:"nome"`
	Telefone string      `json:"telefone"`
	Email    *string     `json:"email"`
}

func (q *Queries) GetCustomerInfo(ctx context.Context, arg GetCustomerInfoParams) (GetCustomerInfoRow, error) {
	row := q.db.QueryRow(ctx, getCustomerInfo, arg.ID, arg.TenantID)
	var i GetCustomerInfoRow
	err := row.Scan(
		&i.ID,
		&i.Nome,
		&i.Telefone,
		&i.Email,
	)
	return i, err
}

const getDailyAppointmentStats = `-- name: GetDailyAppointmentStats :one
SELECT 
    COUNT(*) as total_appointments,
    COUNT(*) FILTER (WHERE status = 'DONE') as completed_count,
    COUNT(*) FILTER (WHERE status = 'CANCELED') as canceled_count,
    COUNT(*) FILTER (WHERE status = 'NO_SHOW') as no_show_count,
    COALESCE(SUM(total_price) FILTER (WHERE status = 'DONE'), 0) as total_revenue
FROM appointments
WHERE tenant_id = $1
  AND start_time >= $2
  AND start_time < $3
`

type GetDailyAppointmentStatsParams struct {
	TenantID    pgtype.UUID        `json:"tenant_id"`
	StartTime   pgtype.Timestamptz `json:"start_time"`
	StartTime_2 pgtype.Timestamptz `json:"start_time_2"`
}

type GetDailyAppointmentStatsRow struct {
	TotalAppointments int64       `json:"total_appointments"`
	CompletedCount    int64       `json:"completed_count"`
	CanceledCount     int64       `json:"canceled_count"`
	NoShowCount       int64       `json:"no_show_count"`
	TotalRevenue      interface{} `json:"total_revenue"`
}

func (q *Queries) GetDailyAppointmentStats(ctx context.Context, arg GetDailyAppointmentStatsParams) (GetDailyAppointmentStatsRow, error) {
	row := q.db.QueryRow(ctx, getDailyAppointmentStats, arg.TenantID, arg.StartTime, arg.StartTime_2)
	var i GetDailyAppointmentStatsRow
	err := row.Scan(
		&i.TotalAppointments,
		&i.CompletedCount,
		&i.CanceledCount,
		&i.NoShowCount,
		&i.TotalRevenue,
	)
	return i, err
}

const getProfessionalInfo = `-- name: GetProfessionalInfo :one
SELECT id, nome, status, NULL::text as cor, comissao::text as comissao, tipo_comissao
FROM profissionais
WHERE id = $1 AND tenant_id = $2
`

type GetProfessionalInfoParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetProfessionalInfoRow struct {
	ID           pgtype.UUID `json:"id"`
	Nome         string      `json:"nome"`
	Status       *string     `json:"status"`
	Cor          *string     `json:"cor"`
	Comissao     string      `json:"comissao"`
	TipoComissao *string     `json:"tipo_comissao"`
}

func (q *Queries) GetProfessionalInfo(ctx context.Context, arg GetProfessionalInfoParams) (GetProfessionalInfoRow, error) {
	row := q.db.QueryRow(ctx, getProfessionalInfo, arg.ID, arg.TenantID)
	var i GetProfessionalInfoRow
	err := row.Scan(
		&i.ID,
		&i.Nome,
		&i.Status,
		&i.Cor,
		&i.Comissao,
		&i.TipoComissao,
	)
	return i, err
}

const getServiceInfo = `-- name: GetServiceInfo :one
SELECT id, nome, preco, duracao, ativo, comissao::text as comissao, categoria_id
FROM servicos
WHERE id = $1 AND tenant_id = $2
`

type GetServiceInfoParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetServiceInfoRow struct {
	ID          pgtype.UUID     `json:"id"`
	Nome        string          `json:"nome"`
	Preco       decimal.Decimal `json:"preco"`
	Duracao     int32           `json:"duracao"`
	Ativo       *bool           `json:"ativo"`
	Comissao    string          `json:"comissao"`
	CategoriaID pgtype.UUID     `json:"categoria_id"`
}

func (q *Queries) GetServiceInfo(ctx context.Context, arg GetServiceInfoParams) (GetServiceInfoRow, error) {
	row := q.db.QueryRow(ctx, getServiceInfo, arg.ID, arg.TenantID)
	var i GetServiceInfoRow
	err := row.Scan(
		&i.ID,
		&i.Nome,
		&i.Preco,
		&i.Duracao,
		&i.Ativo,
		&i.Comissao,
		&i.CategoriaID,
	)
	return i, err
}

const getServicesByIDs = `-- name: GetServicesByIDs :many
SELECT id, nome, preco, duracao, ativo, comissao::text as comissao
FROM servicos
WHERE tenant_id = $1 AND id = ANY($2::uuid[])
ORDER BY nome ASC
`

type GetServicesByIDsParams struct {
	TenantID pgtype.UUID   `json:"tenant_id"`
	Column2  []pgtype.UUID `json:"column_2"`
}

type GetServicesByIDsRow struct {
	ID       pgtype.UUID     `json:"id"`
	Nome     string          `json:"nome"`
	Preco    decimal.Decimal `json:"preco"`
	Duracao  int32           `json:"duracao"`
	Ativo    *bool           `json:"ativo"`
	Comissao string          `json:"comissao"`
}

func (q *Queries) GetServicesByIDs(ctx context.Context, arg GetServicesByIDsParams) ([]GetServicesByIDsRow, error) {
	rows, err := q.db.Query(ctx, getServicesByIDs, arg.TenantID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetServicesByIDsRow{}
	for rows.Next() {
		var i GetServicesByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Nome,
			&i.Preco,
			&i.Duracao,
			&i.Ativo,
			&i.Comissao,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServicesForAppointments = `-- name: GetServicesForAppointments :many
SELECT 
    aps.appointment_id,
    aps.service_id,
    aps.price_at_booking,
    aps.duration_at_booking,
    aps.created_at,
    s.nome as service_name
FROM appointment_services aps
JOIN servicos s ON s.id = aps.service_id
WHERE aps.appointment_id = ANY($1::uuid[])
ORDER BY aps.appointment_id, s.nome
`

type GetServicesForAppointmentsRow struct {
	AppointmentID     pgtype.UUID        `json:"appointment_id"`
	ServiceID         pgtype.UUID        `json:"service_id"`
	PriceAtBooking    decimal.Decimal    `json:"price_at_booking"`
	DurationAtBooking int32              `json:"duration_at_booking"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	ServiceName       string             `json:"service_name"`
}

// Busca todos os serviços de múltiplos agendamentos de uma vez (evita N+1)
func (q *Queries) GetServicesForAppointments(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetServicesForAppointmentsRow, error) {
	rows, err := q.db.Query(ctx, getServicesForAppointments, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetServicesForAppointmentsRow{}
	for rows.Next() {
		var i GetServicesForAppointmentsRow
		if err := rows.Scan(
			&i.AppointmentID,
			&i.ServiceID,
			&i.PriceAtBooking,
			&i.DurationAtBooking,
			&i.CreatedAt,
			&i.ServiceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveProfessionals = `-- name: ListActiveProfessionals :many
SELECT id, nome, status, NULL::text as cor
FROM profissionais
WHERE tenant_id = $1 AND status = 'ATIVO'
ORDER BY nome ASC
`

type ListActiveProfessionalsRow struct {
	ID     pgtype.UUID `json:"id"`
	Nome   string      `json:"nome"`
	Status *string     `json:"status"`
	Cor    *string     `json:"cor"`
}

func (q *Queries) ListActiveProfessionals(ctx context.Context, tenantID pgtype.UUID) ([]ListActiveProfessionalsRow, error) {
	rows, err := q.db.Query(ctx, listActiveProfessionals, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveProfessionalsRow{}
	for rows.Next() {
		var i ListActiveProfessionalsRow
		if err := rows.Scan(
			&i.ID,
			&i.Nome,
			&i.Status,
			&i.Cor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppointments = `-- name: ListAppointments :many
SELECT 
    a.id, a.tenant_id, a.professional_id, a.customer_id, a.start_time, a.end_time, a.status, a.total_price, a.notes, a.canceled_reason, a.google_calendar_event_id, a.command_id, a.checked_in_at, a.started_at, a.finished_at, a.created_at, a.updated_at,
    p.nome as professional_name,
    c.nome as customer_name,
    c.telefone as customer_phone
FROM appointments a
JOIN profissionais p ON p.id = a.professional_id
JOIN clientes c ON c.id = a.customer_id
WHERE a.tenant_id = $1
  AND ($2::uuid IS NULL OR a.professional_id = $2)
  AND ($3::uuid IS NULL OR a.customer_id = $3)
  AND (COALESCE(array_length($4::text[], 1), 0) = 0 OR a.status = ANY($4::text[]))
  AND ($5::timestamptz IS NULL OR a.start_time >= $5)
  AND ($6::timestamptz IS NULL OR a.start_time < $6)
ORDER BY a.start_time DESC
LIMIT $7 OFFSET $8
`

type ListAppointmentsParams struct {
	TenantID pgtype.UUID        `json:"tenant_id"`
	Column2  pgtype.UUID        `json:"column_2"`
	Column3  pgtype.UUID        `json:"column_3"`
	Column4  []string           `json:"column_4"`
	Column5  pgtype.Timestamptz `json:"column_5"`
	Column6  pgtype.Timestamptz `json:"column_6"`
	Limit    int32              `json:"limit"`
	Offset   int32              `json:"offset"`
}

type ListAppointmentsRow struct {
	ID                    pgtype.UUID        `json:"id"`
	TenantID              pgtype.UUID        `json:"tenant_id"`
	ProfessionalID        pgtype.UUID        `json:"professional_id"`
	CustomerID            pgtype.UUID        `json:"customer_id"`
	StartTime             pgtype.Timestamptz `json:"start_time"`
	EndTime               pgtype.Timestamptz `json:"end_time"`
	Status                string             `json:"status"`
	TotalPrice            decimal.Decimal    `json:"total_price"`
	Notes                 *string            `json:"notes"`
	CanceledReason        *string            `json:"canceled_reason"`
	GoogleCalendarEventID *string            `json:"google_calendar_event_id"`
	CommandID             pgtype.UUID        `json:"command_id"`
	CheckedInAt           pgtype.Timestamptz `json:"checked_in_at"`
	StartedAt             pgtype.Timestamptz `json:"started_at"`
	FinishedAt            pgtype.Timestamptz `json:"finished_at"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	ProfessionalName      string             `json:"professional_name"`
	CustomerName          string             `json:"customer_name"`
	CustomerPhone         string             `json:"customer_phone"`
}

func (q *Queries) ListAppointments(ctx context.Context, arg ListAppointmentsParams) ([]ListAppointmentsRow, error) {
	rows, err := q.db.Query(ctx, listAppointments,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAppointmentsRow{}
	for rows.Next() {
		var i ListAppointmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProfessionalID,
			&i.CustomerID,
			&i.StartTime,
			&i.EndTime,
			&i.Status,
			&i.TotalPrice,
			&i.Notes,
			&i.CanceledReason,
			&i.GoogleCalendarEventID,
			&i.CommandID,
			&i.CheckedInAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProfessionalName,
			&i.CustomerName,
			&i.CustomerPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppointmentsByCustomer = `-- name: ListAppointmentsByCustomer :many
SELECT 
    a.id, a.tenant_id, a.professional_id, a.customer_id, a.start_time, a.end_time, a.status, a.total_price, a.notes, a.canceled_reason, a.google_calendar_event_id, a.command_id, a.checked_in_at, a.started_at, a.finished_at, a.created_at, a.updated_at,
    p.nome as professional_name,
    c.nome as customer_name,
    c.telefone as customer_phone
FROM appointments a
JOIN profissionais p ON p.id = a.professional_id
JOIN clientes c ON c.id = a.customer_id
WHERE a.tenant_id = $1
  AND a.customer_id = $2
ORDER BY a.start_time DESC
LIMIT 50
`

type ListAppointmentsByCustomerParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	CustomerID pgtype.UUID `json:"customer_id"`
}

type ListAppointmentsByCustomerRow struct {
	ID                    pgtype.UUID        `json:"id"`
	TenantID              pgtype.UUID        `json:"tenant_id"`
	ProfessionalID        pgtype.UUID        `json:"professional_id"`
	CustomerID            pgtype.UUID        `json:"customer_id"`
	StartTime             pgtype.Timestamptz `json:"start_time"`
	EndTime               pgtype.Timestamptz `json:"end_time"`
	Status                string             `json:"status"`
	TotalPrice            decimal.Decimal    `json:"total_price"`
	Notes                 *string            `json:"notes"`
	CanceledReason        *string            `json:"canceled_reason"`
	GoogleCalendarEventID *string            `json:"google_calendar_event_id"`
	CommandID             pgtype.UUID        `json:"command_id"`
	CheckedInAt           pgtype.Timestamptz `json:"checked_in_at"`
	StartedAt             pgtype.Timestamptz `json:"started_at"`
	FinishedAt            pgtype.Timestamptz `json:"finished_at"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	ProfessionalName      string             `json:"professional_name"`
	CustomerName          string             `json:"customer_name"`
	CustomerPhone         string             `json:"customer_phone"`
}

func (q *Queries) ListAppointmentsByCustomer(ctx context.Context, arg ListAppointmentsByCustomerParams) ([]ListAppointmentsByCustomerRow, error) {
	rows, err := q.db.Query(ctx, listAppointmentsByCustomer, arg.TenantID, arg.CustomerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAppointmentsByCustomerRow{}
	for rows.Next() {
		var i ListAppointmentsByCustomerRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProfessionalID,
			&i.CustomerID,
			&i.StartTime,
			&i.EndTime,
			&i.Status,
			&i.TotalPrice,
			&i.Notes,
			&i.CanceledReason,
			&i.GoogleCalendarEventID,
			&i.CommandID,
			&i.CheckedInAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProfessionalName,
			&i.CustomerName,
			&i.CustomerPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppointmentsByProfessionalAndDateRange = `-- name: ListAppointmentsByProfessionalAndDateRange :many
SELECT 
    a.id, a.tenant_id, a.professional_id, a.customer_id, a.start_time, a.end_time, a.status, a.total_price, a.notes, a.canceled_reason, a.google_calendar_event_id, a.command_id, a.checked_in_at, a.started_at, a.finished_at, a.created_at, a.updated_at,
    p.nome as professional_name,
    c.nome as customer_name,
    c.telefone as customer_phone
FROM appointments a
JOIN profissionais p ON p.id = a.professional_id
JOIN clientes c ON c.id = a.customer_id
WHERE a.tenant_id = $1
  AND a.professional_id = $2
  AND a.start_time >= $3
  AND a.start_time < $4
  AND a.status NOT IN ('CANCELED')
ORDER BY a.start_time ASC
`

type ListAppointmentsByProfessionalAndDateRangeParams struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	ProfessionalID pgtype.UUID        `json:"professional_id"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
	StartTime_2    pgtype.Timestamptz `json:"start_time_2"`
}

type ListAppointmentsByProfessionalAndDateRangeRow struct {
	ID                    pgtype.UUID        `json:"id"`
	TenantID              pgtype.UUID        `json:"tenant_id"`
	ProfessionalID        pgtype.UUID        `json:"professional_id"`
	CustomerID            pgtype.UUID        `json:"customer_id"`
	StartTime             pgtype.Timestamptz `json:"start_time"`
	EndTime               pgtype.Timestamptz `json:"end_time"`
	Status                string             `json:"status"`
	TotalPrice            decimal.Decimal    `json:"total_price"`
	Notes                 *string            `json:"notes"`
	CanceledReason        *string            `json:"canceled_reason"`
	GoogleCalendarEventID *string            `json:"google_calendar_event_id"`
	CommandID             pgtype.UUID        `json:"command_id"`
	CheckedInAt           pgtype.Timestamptz `json:"checked_in_at"`
	StartedAt             pgtype.Timestamptz `json:"started_at"`
	FinishedAt            pgtype.Timestamptz `json:"finished_at"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	ProfessionalName      string             `json:"professional_name"`
	CustomerName          string             `json:"customer_name"`
	CustomerPhone         string             `json:"customer_phone"`
}

func (q *Queries) ListAppointmentsByProfessionalAndDateRange(ctx context.Context, arg ListAppointmentsByProfessionalAndDateRangeParams) ([]ListAppointmentsByProfessionalAndDateRangeRow, error) {
	rows, err := q.db.Query(ctx, listAppointmentsByProfessionalAndDateRange,
		arg.TenantID,
		arg.ProfessionalID,
		arg.StartTime,
		arg.StartTime_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAppointmentsByProfessionalAndDateRangeRow{}
	for rows.Next() {
		var i ListAppointmentsByProfessionalAndDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProfessionalID,
			&i.CustomerID,
			&i.StartTime,
			&i.EndTime,
			&i.Status,
			&i.TotalPrice,
			&i.Notes,
			&i.CanceledReason,
			&i.GoogleCalendarEventID,
			&i.CommandID,
			&i.CheckedInAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProfessionalName,
			&i.CustomerName,
			&i.CustomerPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const professionalExists = `-- name: ProfessionalExists :one

SELECT EXISTS (
    SELECT 1 FROM profissionais
    WHERE id = $1 AND tenant_id = $2 AND status = 'ATIVO'
) as exists
`

type ProfessionalExistsParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// ============================================================================
// QUERIES AUXILIARES: Profissionais, Clientes, Serviços (Read-Only)
// ============================================================================
func (q *Queries) ProfessionalExists(ctx context.Context, arg ProfessionalExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, professionalExists, arg.ID, arg.TenantID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const serviceExists = `-- name: ServiceExists :one
SELECT EXISTS (
    SELECT 1 FROM servicos
    WHERE id = $1 AND tenant_id = $2 AND ativo = true
) as exists
`

type ServiceExistsParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) ServiceExists(ctx context.Context, arg ServiceExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, serviceExists, arg.ID, arg.TenantID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const startAppointment = `-- name: StartAppointment :one
UPDATE appointments
SET
    status = 'IN_SERVICE',
    started_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
  AND status = 'CHECKED_IN'
RETURNING id, tenant_id, professional_id, customer_id, start_time, end_time, status, total_price, notes, canceled_reason, google_calendar_event_id, command_id, checked_in_at, started_at, finished_at, created_at, updated_at
`

type StartAppointmentParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Inicia o atendimento (profissional começou os serviços)
func (q *Queries) StartAppointment(ctx context.Context, arg StartAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, startAppointment, arg.ID, arg.TenantID)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CustomerID,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.TotalPrice,
		&i.Notes,
		&i.CanceledReason,
		&i.GoogleCalendarEventID,
		&i.CommandID,
		&i.CheckedInAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAppointment = `-- name: UpdateAppointment :one
UPDATE appointments
SET
    professional_id = $3,
    start_time = $4,
    end_time = $5,
    status = $6,
    total_price = $7,
    notes = $8,
    canceled_reason = $9,
    google_calendar_event_id = $10,
    checked_in_at = $11,
    started_at = $12,
    finished_at = $13,
    command_id = $14,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, professional_id, customer_id, start_time, end_time, status, total_price, notes, canceled_reason, google_calendar_event_id, command_id, checked_in_at, started_at, finished_at, created_at, updated_at
`

type UpdateAppointmentParams struct {
	ID                    pgtype.UUID        `json:"id"`
	TenantID              pgtype.UUID        `json:"tenant_id"`
	ProfessionalID        pgtype.UUID        `json:"professional_id"`
	StartTime             pgtype.Timestamptz `json:"start_time"`
	EndTime               pgtype.Timestamptz `json:"end_time"`
	Status                string             `json:"status"`
	TotalPrice            decimal.Decimal    `json:"total_price"`
	Notes                 *string            `json:"notes"`
	CanceledReason        *string            `json:"canceled_reason"`
	GoogleCalendarEventID *string            `json:"google_calendar_event_id"`
	CheckedInAt           pgtype.Timestamptz `json:"checked_in_at"`
	StartedAt             pgtype.Timestamptz `json:"started_at"`
	FinishedAt            pgtype.Timestamptz `json:"finished_at"`
	CommandID             pgtype.UUID        `json:"command_id"`
}

func (q *Queries) UpdateAppointment(ctx context.Context, arg UpdateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, updateAppointment,
		arg.ID,
		arg.TenantID,
		arg.ProfessionalID,
		arg.StartTime,
		arg.EndTime,
		arg.Status,
		arg.TotalPrice,
		arg.Notes,
		arg.CanceledReason,
		arg.GoogleCalendarEventID,
		arg.CheckedInAt,
		arg.StartedAt,
		arg.FinishedAt,
		arg.CommandID,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CustomerID,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.TotalPrice,
		&i.Notes,
		&i.CanceledReason,
		&i.GoogleCalendarEventID,
		&i.CommandID,
		&i.CheckedInAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAppointmentStatus = `-- name: UpdateAppointmentStatus :one
UPDATE appointments
SET
    status = $3,
    canceled_reason = $4,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, professional_id, customer_id, start_time, end_time, status, total_price, notes, canceled_reason, google_calendar_event_id, command_id, checked_in_at, started_at, finished_at, created_at, updated_at
`

type UpdateAppointmentStatusParams struct {
	ID             pgtype.UUID `json:"id"`
	TenantID       pgtype.UUID `json:"tenant_id"`
	Status         string      `json:"status"`
	CanceledReason *string     `json:"canceled_reason"`
}

func (q *Queries) UpdateAppointmentStatus(ctx context.Context, arg UpdateAppointmentStatusParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, updateAppointmentStatus,
		arg.ID,
		arg.TenantID,
		arg.Status,
		arg.CanceledReason,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CustomerID,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.TotalPrice,
		&i.Notes,
		&i.CanceledReason,
		&i.GoogleCalendarEventID,
		&i.CommandID,
		&i.CheckedInAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
