// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: commands.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const countCommands = `-- name: CountCommands :one
SELECT COUNT(*) FROM commands
WHERE tenant_id = $1
    AND ($2::VARCHAR IS NULL OR status = $2)
    AND ($3::UUID IS NULL OR customer_id = $3)
    AND ($4::DATE IS NULL OR DATE(criado_em) >= $4)
    AND ($5::DATE IS NULL OR DATE(criado_em) <= $5)
`

type CountCommandsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Column2  string      `json:"column_2"`
	Column3  pgtype.UUID `json:"column_3"`
	Column4  pgtype.Date `json:"column_4"`
	Column5  pgtype.Date `json:"column_5"`
}

func (q *Queries) CountCommands(ctx context.Context, arg CountCommandsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countCommands,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCommand = `-- name: CreateCommand :one

INSERT INTO commands (
    id,
    tenant_id,
    appointment_id,
    customer_id,
    numero,
    status,
    subtotal,
    desconto,
    total,
    total_recebido,
    troco,
    saldo_devedor,
    observacoes,
    deixar_troco_gorjeta,
    deixar_saldo_divida,
    criado_em,
    atualizado_em
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
) RETURNING id, tenant_id, appointment_id, customer_id, numero, status, subtotal, desconto, total, total_recebido, troco, saldo_devedor, observacoes, deixar_troco_gorjeta, deixar_saldo_divida, criado_em, atualizado_em, fechado_em, fechado_por
`

type CreateCommandParams struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	AppointmentID      pgtype.UUID        `json:"appointment_id"`
	CustomerID         pgtype.UUID        `json:"customer_id"`
	Numero             *string            `json:"numero"`
	Status             string             `json:"status"`
	Subtotal           decimal.Decimal    `json:"subtotal"`
	Desconto           decimal.Decimal    `json:"desconto"`
	Total              decimal.Decimal    `json:"total"`
	TotalRecebido      decimal.Decimal    `json:"total_recebido"`
	Troco              decimal.Decimal    `json:"troco"`
	SaldoDevedor       decimal.Decimal    `json:"saldo_devedor"`
	Observacoes        *string            `json:"observacoes"`
	DeixarTrocoGorjeta *bool              `json:"deixar_troco_gorjeta"`
	DeixarSaldoDivida  *bool              `json:"deixar_saldo_divida"`
	CriadoEm           pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm       pgtype.Timestamptz `json:"atualizado_em"`
}

// =============================================
// Commands Queries (sqlc)
// =============================================
func (q *Queries) CreateCommand(ctx context.Context, arg CreateCommandParams) (Command, error) {
	row := q.db.QueryRow(ctx, createCommand,
		arg.ID,
		arg.TenantID,
		arg.AppointmentID,
		arg.CustomerID,
		arg.Numero,
		arg.Status,
		arg.Subtotal,
		arg.Desconto,
		arg.Total,
		arg.TotalRecebido,
		arg.Troco,
		arg.SaldoDevedor,
		arg.Observacoes,
		arg.DeixarTrocoGorjeta,
		arg.DeixarSaldoDivida,
		arg.CriadoEm,
		arg.AtualizadoEm,
	)
	var i Command
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AppointmentID,
		&i.CustomerID,
		&i.Numero,
		&i.Status,
		&i.Subtotal,
		&i.Desconto,
		&i.Total,
		&i.TotalRecebido,
		&i.Troco,
		&i.SaldoDevedor,
		&i.Observacoes,
		&i.DeixarTrocoGorjeta,
		&i.DeixarSaldoDivida,
		&i.CriadoEm,
		&i.AtualizadoEm,
		&i.FechadoEm,
		&i.FechadoPor,
	)
	return i, err
}

const createCommandItem = `-- name: CreateCommandItem :one

INSERT INTO command_items (
    id,
    command_id,
    tipo,
    item_id,
    descricao,
    preco_unitario,
    quantidade,
    desconto_valor,
    desconto_percentual,
    preco_final,
    observacoes,
    criado_em
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, command_id, tipo, item_id, descricao, preco_unitario, quantidade, desconto_valor, desconto_percentual, preco_final, observacoes, criado_em
`

type CreateCommandItemParams struct {
	ID                 pgtype.UUID        `json:"id"`
	CommandID          pgtype.UUID        `json:"command_id"`
	Tipo               string             `json:"tipo"`
	ItemID             pgtype.UUID        `json:"item_id"`
	Descricao          string             `json:"descricao"`
	PrecoUnitario      decimal.Decimal    `json:"preco_unitario"`
	Quantidade         int32              `json:"quantidade"`
	DescontoValor      decimal.Decimal    `json:"desconto_valor"`
	DescontoPercentual decimal.Decimal    `json:"desconto_percentual"`
	PrecoFinal         decimal.Decimal    `json:"preco_final"`
	Observacoes        *string            `json:"observacoes"`
	CriadoEm           pgtype.Timestamptz `json:"criado_em"`
}

// =============================================
// Command Items Queries
// =============================================
func (q *Queries) CreateCommandItem(ctx context.Context, arg CreateCommandItemParams) (CommandItem, error) {
	row := q.db.QueryRow(ctx, createCommandItem,
		arg.ID,
		arg.CommandID,
		arg.Tipo,
		arg.ItemID,
		arg.Descricao,
		arg.PrecoUnitario,
		arg.Quantidade,
		arg.DescontoValor,
		arg.DescontoPercentual,
		arg.PrecoFinal,
		arg.Observacoes,
		arg.CriadoEm,
	)
	var i CommandItem
	err := row.Scan(
		&i.ID,
		&i.CommandID,
		&i.Tipo,
		&i.ItemID,
		&i.Descricao,
		&i.PrecoUnitario,
		&i.Quantidade,
		&i.DescontoValor,
		&i.DescontoPercentual,
		&i.PrecoFinal,
		&i.Observacoes,
		&i.CriadoEm,
	)
	return i, err
}

const createCommandPayment = `-- name: CreateCommandPayment :one

INSERT INTO command_payments (
    id,
    command_id,
    meio_pagamento_id,
    valor_recebido,
    taxa_percentual,
    taxa_fixa,
    valor_liquido,
    observacoes,
    criado_em,
    criado_por
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, command_id, meio_pagamento_id, valor_recebido, taxa_percentual, taxa_fixa, valor_liquido, observacoes, criado_em, criado_por
`

type CreateCommandPaymentParams struct {
	ID              pgtype.UUID        `json:"id"`
	CommandID       pgtype.UUID        `json:"command_id"`
	MeioPagamentoID pgtype.UUID        `json:"meio_pagamento_id"`
	ValorRecebido   decimal.Decimal    `json:"valor_recebido"`
	TaxaPercentual  decimal.Decimal    `json:"taxa_percentual"`
	TaxaFixa        decimal.Decimal    `json:"taxa_fixa"`
	ValorLiquido    decimal.Decimal    `json:"valor_liquido"`
	Observacoes     *string            `json:"observacoes"`
	CriadoEm        pgtype.Timestamptz `json:"criado_em"`
	CriadoPor       pgtype.UUID        `json:"criado_por"`
}

// =============================================
// Command Payments Queries
// =============================================
func (q *Queries) CreateCommandPayment(ctx context.Context, arg CreateCommandPaymentParams) (CommandPayment, error) {
	row := q.db.QueryRow(ctx, createCommandPayment,
		arg.ID,
		arg.CommandID,
		arg.MeioPagamentoID,
		arg.ValorRecebido,
		arg.TaxaPercentual,
		arg.TaxaFixa,
		arg.ValorLiquido,
		arg.Observacoes,
		arg.CriadoEm,
		arg.CriadoPor,
	)
	var i CommandPayment
	err := row.Scan(
		&i.ID,
		&i.CommandID,
		&i.MeioPagamentoID,
		&i.ValorRecebido,
		&i.TaxaPercentual,
		&i.TaxaFixa,
		&i.ValorLiquido,
		&i.Observacoes,
		&i.CriadoEm,
		&i.CriadoPor,
	)
	return i, err
}

const deleteCommand = `-- name: DeleteCommand :exec
UPDATE commands SET
    status = 'CANCELED',
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
`

type DeleteCommandParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteCommand(ctx context.Context, arg DeleteCommandParams) error {
	_, err := q.db.Exec(ctx, deleteCommand, arg.ID, arg.TenantID)
	return err
}

const deleteCommandItem = `-- name: DeleteCommandItem :exec
DELETE FROM command_items
WHERE command_items.id = $1
    AND EXISTS (
        SELECT 1 FROM commands 
        WHERE commands.id = command_items.command_id 
        AND commands.tenant_id = $2
    )
`

type DeleteCommandItemParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteCommandItem(ctx context.Context, arg DeleteCommandItemParams) error {
	_, err := q.db.Exec(ctx, deleteCommandItem, arg.ID, arg.TenantID)
	return err
}

const deleteCommandPayment = `-- name: DeleteCommandPayment :exec
DELETE FROM command_payments
WHERE command_payments.id = $1
    AND EXISTS (
        SELECT 1 FROM commands 
        WHERE commands.id = command_payments.command_id 
        AND commands.tenant_id = $2
    )
`

type DeleteCommandPaymentParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteCommandPayment(ctx context.Context, arg DeleteCommandPaymentParams) error {
	_, err := q.db.Exec(ctx, deleteCommandPayment, arg.ID, arg.TenantID)
	return err
}

const getCommandByAppointmentID = `-- name: GetCommandByAppointmentID :one
SELECT id, tenant_id, appointment_id, customer_id, numero, status, subtotal, desconto, total, total_recebido, troco, saldo_devedor, observacoes, deixar_troco_gorjeta, deixar_saldo_divida, criado_em, atualizado_em, fechado_em, fechado_por FROM commands
WHERE appointment_id = $1 AND tenant_id = $2
ORDER BY criado_em DESC
LIMIT 1
`

type GetCommandByAppointmentIDParams struct {
	AppointmentID pgtype.UUID `json:"appointment_id"`
	TenantID      pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetCommandByAppointmentID(ctx context.Context, arg GetCommandByAppointmentIDParams) (Command, error) {
	row := q.db.QueryRow(ctx, getCommandByAppointmentID, arg.AppointmentID, arg.TenantID)
	var i Command
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AppointmentID,
		&i.CustomerID,
		&i.Numero,
		&i.Status,
		&i.Subtotal,
		&i.Desconto,
		&i.Total,
		&i.TotalRecebido,
		&i.Troco,
		&i.SaldoDevedor,
		&i.Observacoes,
		&i.DeixarTrocoGorjeta,
		&i.DeixarSaldoDivida,
		&i.CriadoEm,
		&i.AtualizadoEm,
		&i.FechadoEm,
		&i.FechadoPor,
	)
	return i, err
}

const getCommandByID = `-- name: GetCommandByID :one
SELECT id, tenant_id, appointment_id, customer_id, numero, status, subtotal, desconto, total, total_recebido, troco, saldo_devedor, observacoes, deixar_troco_gorjeta, deixar_saldo_divida, criado_em, atualizado_em, fechado_em, fechado_por FROM commands
WHERE id = $1 AND tenant_id = $2
`

type GetCommandByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetCommandByID(ctx context.Context, arg GetCommandByIDParams) (Command, error) {
	row := q.db.QueryRow(ctx, getCommandByID, arg.ID, arg.TenantID)
	var i Command
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AppointmentID,
		&i.CustomerID,
		&i.Numero,
		&i.Status,
		&i.Subtotal,
		&i.Desconto,
		&i.Total,
		&i.TotalRecebido,
		&i.Troco,
		&i.SaldoDevedor,
		&i.Observacoes,
		&i.DeixarTrocoGorjeta,
		&i.DeixarSaldoDivida,
		&i.CriadoEm,
		&i.AtualizadoEm,
		&i.FechadoEm,
		&i.FechadoPor,
	)
	return i, err
}

const getCommandItemByID = `-- name: GetCommandItemByID :one
SELECT ci.id, ci.command_id, ci.tipo, ci.item_id, ci.descricao, ci.preco_unitario, ci.quantidade, ci.desconto_valor, ci.desconto_percentual, ci.preco_final, ci.observacoes, ci.criado_em FROM command_items ci
INNER JOIN commands c ON c.id = ci.command_id
WHERE ci.id = $1 AND c.tenant_id = $2
`

type GetCommandItemByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetCommandItemByID(ctx context.Context, arg GetCommandItemByIDParams) (CommandItem, error) {
	row := q.db.QueryRow(ctx, getCommandItemByID, arg.ID, arg.TenantID)
	var i CommandItem
	err := row.Scan(
		&i.ID,
		&i.CommandID,
		&i.Tipo,
		&i.ItemID,
		&i.Descricao,
		&i.PrecoUnitario,
		&i.Quantidade,
		&i.DescontoValor,
		&i.DescontoPercentual,
		&i.PrecoFinal,
		&i.Observacoes,
		&i.CriadoEm,
	)
	return i, err
}

const getCommandItems = `-- name: GetCommandItems :many
SELECT ci.id, ci.command_id, ci.tipo, ci.item_id, ci.descricao, ci.preco_unitario, ci.quantidade, ci.desconto_valor, ci.desconto_percentual, ci.preco_final, ci.observacoes, ci.criado_em FROM command_items ci
INNER JOIN commands c ON c.id = ci.command_id
WHERE ci.command_id = $1 AND c.tenant_id = $2
ORDER BY ci.criado_em ASC
`

type GetCommandItemsParams struct {
	CommandID pgtype.UUID `json:"command_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetCommandItems(ctx context.Context, arg GetCommandItemsParams) ([]CommandItem, error) {
	rows, err := q.db.Query(ctx, getCommandItems, arg.CommandID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CommandItem{}
	for rows.Next() {
		var i CommandItem
		if err := rows.Scan(
			&i.ID,
			&i.CommandID,
			&i.Tipo,
			&i.ItemID,
			&i.Descricao,
			&i.PrecoUnitario,
			&i.Quantidade,
			&i.DescontoValor,
			&i.DescontoPercentual,
			&i.PrecoFinal,
			&i.Observacoes,
			&i.CriadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommandPaymentByID = `-- name: GetCommandPaymentByID :one
SELECT cp.id, cp.command_id, cp.meio_pagamento_id, cp.valor_recebido, cp.taxa_percentual, cp.taxa_fixa, cp.valor_liquido, cp.observacoes, cp.criado_em, cp.criado_por FROM command_payments cp
INNER JOIN commands c ON c.id = cp.command_id
WHERE cp.id = $1 AND c.tenant_id = $2
`

type GetCommandPaymentByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetCommandPaymentByID(ctx context.Context, arg GetCommandPaymentByIDParams) (CommandPayment, error) {
	row := q.db.QueryRow(ctx, getCommandPaymentByID, arg.ID, arg.TenantID)
	var i CommandPayment
	err := row.Scan(
		&i.ID,
		&i.CommandID,
		&i.MeioPagamentoID,
		&i.ValorRecebido,
		&i.TaxaPercentual,
		&i.TaxaFixa,
		&i.ValorLiquido,
		&i.Observacoes,
		&i.CriadoEm,
		&i.CriadoPor,
	)
	return i, err
}

const getCommandPayments = `-- name: GetCommandPayments :many
SELECT cp.id, cp.command_id, cp.meio_pagamento_id, cp.valor_recebido, cp.taxa_percentual, cp.taxa_fixa, cp.valor_liquido, cp.observacoes, cp.criado_em, cp.criado_por FROM command_payments cp
INNER JOIN commands c ON c.id = cp.command_id
WHERE cp.command_id = $1 AND c.tenant_id = $2
ORDER BY cp.criado_em ASC
`

type GetCommandPaymentsParams struct {
	CommandID pgtype.UUID `json:"command_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetCommandPayments(ctx context.Context, arg GetCommandPaymentsParams) ([]CommandPayment, error) {
	rows, err := q.db.Query(ctx, getCommandPayments, arg.CommandID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CommandPayment{}
	for rows.Next() {
		var i CommandPayment
		if err := rows.Scan(
			&i.ID,
			&i.CommandID,
			&i.MeioPagamentoID,
			&i.ValorRecebido,
			&i.TaxaPercentual,
			&i.TaxaFixa,
			&i.ValorLiquido,
			&i.Observacoes,
			&i.CriadoEm,
			&i.CriadoPor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommandPaymentsSummary = `-- name: GetCommandPaymentsSummary :one
SELECT 
    COALESCE(SUM(valor_recebido), 0) as total_recebido,
    COALESCE(SUM(valor_liquido), 0) as total_liquido,
    COALESCE(SUM(valor_recebido - valor_liquido), 0) as total_taxas,
    COUNT(*) as total_pagamentos
FROM command_payments cp
INNER JOIN commands c ON c.id = cp.command_id
WHERE cp.command_id = $1 AND c.tenant_id = $2
`

type GetCommandPaymentsSummaryParams struct {
	CommandID pgtype.UUID `json:"command_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

type GetCommandPaymentsSummaryRow struct {
	TotalRecebido   interface{} `json:"total_recebido"`
	TotalLiquido    interface{} `json:"total_liquido"`
	TotalTaxas      interface{} `json:"total_taxas"`
	TotalPagamentos int64       `json:"total_pagamentos"`
}

func (q *Queries) GetCommandPaymentsSummary(ctx context.Context, arg GetCommandPaymentsSummaryParams) (GetCommandPaymentsSummaryRow, error) {
	row := q.db.QueryRow(ctx, getCommandPaymentsSummary, arg.CommandID, arg.TenantID)
	var i GetCommandPaymentsSummaryRow
	err := row.Scan(
		&i.TotalRecebido,
		&i.TotalLiquido,
		&i.TotalTaxas,
		&i.TotalPagamentos,
	)
	return i, err
}

const getNextCommandNumber = `-- name: GetNextCommandNumber :one
SELECT COALESCE(MAX(
    CAST(
        NULLIF(REGEXP_REPLACE(numero, '[^0-9]', '', 'g'), '') 
        AS INTEGER
    )
), 0) + 1 as next_number
FROM commands
WHERE tenant_id = $1
    AND EXTRACT(YEAR FROM criado_em) = EXTRACT(YEAR FROM NOW())
`

// Retorna o próximo número sequencial para comandas do tenant no ano atual
func (q *Queries) GetNextCommandNumber(ctx context.Context, tenantID pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getNextCommandNumber, tenantID)
	var next_number int32
	err := row.Scan(&next_number)
	return next_number, err
}

const listCommands = `-- name: ListCommands :many
SELECT id, tenant_id, appointment_id, customer_id, numero, status, subtotal, desconto, total, total_recebido, troco, saldo_devedor, observacoes, deixar_troco_gorjeta, deixar_saldo_divida, criado_em, atualizado_em, fechado_em, fechado_por FROM commands
WHERE tenant_id = $1
    AND ($2::VARCHAR IS NULL OR status = $2)
    AND ($3::UUID IS NULL OR customer_id = $3)
    AND ($4::DATE IS NULL OR DATE(criado_em) >= $4)
    AND ($5::DATE IS NULL OR DATE(criado_em) <= $5)
ORDER BY criado_em DESC
LIMIT $6 OFFSET $7
`

type ListCommandsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Column2  string      `json:"column_2"`
	Column3  pgtype.UUID `json:"column_3"`
	Column4  pgtype.Date `json:"column_4"`
	Column5  pgtype.Date `json:"column_5"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListCommands(ctx context.Context, arg ListCommandsParams) ([]Command, error) {
	rows, err := q.db.Query(ctx, listCommands,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Command{}
	for rows.Next() {
		var i Command
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.AppointmentID,
			&i.CustomerID,
			&i.Numero,
			&i.Status,
			&i.Subtotal,
			&i.Desconto,
			&i.Total,
			&i.TotalRecebido,
			&i.Troco,
			&i.SaldoDevedor,
			&i.Observacoes,
			&i.DeixarTrocoGorjeta,
			&i.DeixarSaldoDivida,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.FechadoEm,
			&i.FechadoPor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCommand = `-- name: UpdateCommand :one
UPDATE commands SET
    status = $3,
    subtotal = $4,
    desconto = $5,
    total = $6,
    total_recebido = $7,
    troco = $8,
    saldo_devedor = $9,
    observacoes = $10,
    deixar_troco_gorjeta = $11,
    deixar_saldo_divida = $12,
    fechado_em = $13,
    fechado_por = $14,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, appointment_id, customer_id, numero, status, subtotal, desconto, total, total_recebido, troco, saldo_devedor, observacoes, deixar_troco_gorjeta, deixar_saldo_divida, criado_em, atualizado_em, fechado_em, fechado_por
`

type UpdateCommandParams struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	Status             string             `json:"status"`
	Subtotal           decimal.Decimal    `json:"subtotal"`
	Desconto           decimal.Decimal    `json:"desconto"`
	Total              decimal.Decimal    `json:"total"`
	TotalRecebido      decimal.Decimal    `json:"total_recebido"`
	Troco              decimal.Decimal    `json:"troco"`
	SaldoDevedor       decimal.Decimal    `json:"saldo_devedor"`
	Observacoes        *string            `json:"observacoes"`
	DeixarTrocoGorjeta *bool              `json:"deixar_troco_gorjeta"`
	DeixarSaldoDivida  *bool              `json:"deixar_saldo_divida"`
	FechadoEm          pgtype.Timestamptz `json:"fechado_em"`
	FechadoPor         pgtype.UUID        `json:"fechado_por"`
}

func (q *Queries) UpdateCommand(ctx context.Context, arg UpdateCommandParams) (Command, error) {
	row := q.db.QueryRow(ctx, updateCommand,
		arg.ID,
		arg.TenantID,
		arg.Status,
		arg.Subtotal,
		arg.Desconto,
		arg.Total,
		arg.TotalRecebido,
		arg.Troco,
		arg.SaldoDevedor,
		arg.Observacoes,
		arg.DeixarTrocoGorjeta,
		arg.DeixarSaldoDivida,
		arg.FechadoEm,
		arg.FechadoPor,
	)
	var i Command
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AppointmentID,
		&i.CustomerID,
		&i.Numero,
		&i.Status,
		&i.Subtotal,
		&i.Desconto,
		&i.Total,
		&i.TotalRecebido,
		&i.Troco,
		&i.SaldoDevedor,
		&i.Observacoes,
		&i.DeixarTrocoGorjeta,
		&i.DeixarSaldoDivida,
		&i.CriadoEm,
		&i.AtualizadoEm,
		&i.FechadoEm,
		&i.FechadoPor,
	)
	return i, err
}

const updateCommandItem = `-- name: UpdateCommandItem :one
UPDATE command_items SET
    preco_unitario = $3,
    quantidade = $4,
    desconto_valor = $5,
    desconto_percentual = $6,
    preco_final = $7,
    observacoes = $8
WHERE command_items.id = $1
    AND EXISTS (
        SELECT 1 FROM commands 
        WHERE commands.id = command_items.command_id 
        AND commands.tenant_id = $2
    )
RETURNING id, command_id, tipo, item_id, descricao, preco_unitario, quantidade, desconto_valor, desconto_percentual, preco_final, observacoes, criado_em
`

type UpdateCommandItemParams struct {
	ID                 pgtype.UUID     `json:"id"`
	TenantID           pgtype.UUID     `json:"tenant_id"`
	PrecoUnitario      decimal.Decimal `json:"preco_unitario"`
	Quantidade         int32           `json:"quantidade"`
	DescontoValor      decimal.Decimal `json:"desconto_valor"`
	DescontoPercentual decimal.Decimal `json:"desconto_percentual"`
	PrecoFinal         decimal.Decimal `json:"preco_final"`
	Observacoes        *string         `json:"observacoes"`
}

func (q *Queries) UpdateCommandItem(ctx context.Context, arg UpdateCommandItemParams) (CommandItem, error) {
	row := q.db.QueryRow(ctx, updateCommandItem,
		arg.ID,
		arg.TenantID,
		arg.PrecoUnitario,
		arg.Quantidade,
		arg.DescontoValor,
		arg.DescontoPercentual,
		arg.PrecoFinal,
		arg.Observacoes,
	)
	var i CommandItem
	err := row.Scan(
		&i.ID,
		&i.CommandID,
		&i.Tipo,
		&i.ItemID,
		&i.Descricao,
		&i.PrecoUnitario,
		&i.Quantidade,
		&i.DescontoValor,
		&i.DescontoPercentual,
		&i.PrecoFinal,
		&i.Observacoes,
		&i.CriadoEm,
	)
	return i, err
}
