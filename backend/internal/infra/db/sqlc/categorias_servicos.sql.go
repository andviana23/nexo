// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: categorias_servicos.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkCategoriaServicoNomeExists = `-- name: CheckCategoriaServicoNomeExists :one
SELECT EXISTS(
    SELECT 1 
    FROM categorias_servicos 
    WHERE tenant_id = $1 
      AND unit_id = $2
      AND LOWER(nome) = LOWER($3)
      AND id != COALESCE($4, '00000000-0000-0000-0000-000000000000'::uuid)
) AS exists
`

type CheckCategoriaServicoNomeExistsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UnitID   pgtype.UUID `json:"unit_id"`
	Lower    string      `json:"lower"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) CheckCategoriaServicoNomeExists(ctx context.Context, arg CheckCategoriaServicoNomeExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkCategoriaServicoNomeExists,
		arg.TenantID,
		arg.UnitID,
		arg.Lower,
		arg.ID,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countCategoriasServicosByTenant = `-- name: CountCategoriasServicosByTenant :one
SELECT COUNT(*) AS total
FROM categorias_servicos
WHERE tenant_id = $1 AND unit_id = $2
`

type CountCategoriasServicosByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UnitID   pgtype.UUID `json:"unit_id"`
}

func (q *Queries) CountCategoriasServicosByTenant(ctx context.Context, arg CountCategoriasServicosByTenantParams) (int64, error) {
	row := q.db.QueryRow(ctx, countCategoriasServicosByTenant, arg.TenantID, arg.UnitID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countServicosInCategoria = `-- name: CountServicosInCategoria :one
SELECT COUNT(*) AS total
FROM servicos
WHERE categoria_id = $1 AND tenant_id = $2 AND unit_id = $3
`

type CountServicosInCategoriaParams struct {
	CategoriaID pgtype.UUID `json:"categoria_id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	UnitID      pgtype.UUID `json:"unit_id"`
}

// ============================================================================
// QUERIES AUXILIARES
// ============================================================================
func (q *Queries) CountServicosInCategoria(ctx context.Context, arg CountServicosInCategoriaParams) (int64, error) {
	row := q.db.QueryRow(ctx, countServicosInCategoria, arg.CategoriaID, arg.TenantID, arg.UnitID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createCategoriaServico = `-- name: CreateCategoriaServico :one


INSERT INTO categorias_servicos (
    id,
    tenant_id,
    unit_id,
    nome,
    descricao,
    cor,
    icone,
    ativa,
    criado_em,
    atualizado_em
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW()
) RETURNING id, tenant_id, unit_id, nome, descricao, cor, icone, ativa, criado_em, atualizado_em
`

type CreateCategoriaServicoParams struct {
	ID        pgtype.UUID `json:"id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
	UnitID    pgtype.UUID `json:"unit_id"`
	Nome      string      `json:"nome"`
	Descricao *string     `json:"descricao"`
	Cor       *string     `json:"cor"`
	Icone     *string     `json:"icone"`
	Ativa     *bool       `json:"ativa"`
}

// ============================================================================
// CATEGORIAS DE SERVIÇOS QUERIES (sqlc)
// Módulo de Cadastro de Serviços — NEXO v1.0
// Tabela: categorias_servicos (separada de categorias financeiras)
// ============================================================================
// ============================================================================
// CREATE
// ============================================================================
func (q *Queries) CreateCategoriaServico(ctx context.Context, arg CreateCategoriaServicoParams) (CategoriasServico, error) {
	row := q.db.QueryRow(ctx, createCategoriaServico,
		arg.ID,
		arg.TenantID,
		arg.UnitID,
		arg.Nome,
		arg.Descricao,
		arg.Cor,
		arg.Icone,
		arg.Ativa,
	)
	var i CategoriasServico
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.Nome,
		&i.Descricao,
		&i.Cor,
		&i.Icone,
		&i.Ativa,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const deleteCategoriaServico = `-- name: DeleteCategoriaServico :exec

DELETE FROM categorias_servicos
WHERE id = $1 AND tenant_id = $2 AND unit_id = $3
`

type DeleteCategoriaServicoParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	UnitID   pgtype.UUID `json:"unit_id"`
}

// ============================================================================
// DELETE
// ============================================================================
func (q *Queries) DeleteCategoriaServico(ctx context.Context, arg DeleteCategoriaServicoParams) error {
	_, err := q.db.Exec(ctx, deleteCategoriaServico, arg.ID, arg.TenantID, arg.UnitID)
	return err
}

const getCategoriaServicoByID = `-- name: GetCategoriaServicoByID :one

SELECT 
    id,
    tenant_id,
    unit_id,
    nome,
    descricao,
    cor,
    icone,
    ativa,
    criado_em,
    atualizado_em
FROM categorias_servicos
WHERE id = $1 AND tenant_id = $2 AND unit_id = $3
`

type GetCategoriaServicoByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	UnitID   pgtype.UUID `json:"unit_id"`
}

// ============================================================================
// READ
// ============================================================================
func (q *Queries) GetCategoriaServicoByID(ctx context.Context, arg GetCategoriaServicoByIDParams) (CategoriasServico, error) {
	row := q.db.QueryRow(ctx, getCategoriaServicoByID, arg.ID, arg.TenantID, arg.UnitID)
	var i CategoriasServico
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.Nome,
		&i.Descricao,
		&i.Cor,
		&i.Icone,
		&i.Ativa,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getCategoriasServicosComServicos = `-- name: GetCategoriasServicosComServicos :many
SELECT 
    cs.id,
    cs.tenant_id,
    cs.unit_id,
    cs.nome,
    cs.descricao,
    cs.cor,
    cs.icone,
    cs.ativa,
    cs.criado_em,
    cs.atualizado_em,
    COUNT(s.id) AS total_servicos
FROM categorias_servicos cs
LEFT JOIN servicos s ON s.categoria_id = cs.id AND s.tenant_id = cs.tenant_id AND s.unit_id = cs.unit_id
WHERE cs.tenant_id = $1 AND cs.unit_id = $2
GROUP BY cs.id, cs.tenant_id, cs.unit_id, cs.nome, cs.descricao, cs.cor, cs.icone, cs.ativa, cs.criado_em, cs.atualizado_em
ORDER BY cs.nome ASC
`

type GetCategoriasServicosComServicosParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UnitID   pgtype.UUID `json:"unit_id"`
}

type GetCategoriasServicosComServicosRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	UnitID        pgtype.UUID        `json:"unit_id"`
	Nome          string             `json:"nome"`
	Descricao     *string            `json:"descricao"`
	Cor           *string            `json:"cor"`
	Icone         *string            `json:"icone"`
	Ativa         *bool              `json:"ativa"`
	CriadoEm      pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm  pgtype.Timestamptz `json:"atualizado_em"`
	TotalServicos int64              `json:"total_servicos"`
}

func (q *Queries) GetCategoriasServicosComServicos(ctx context.Context, arg GetCategoriasServicosComServicosParams) ([]GetCategoriasServicosComServicosRow, error) {
	rows, err := q.db.Query(ctx, getCategoriasServicosComServicos, arg.TenantID, arg.UnitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoriasServicosComServicosRow{}
	for rows.Next() {
		var i GetCategoriasServicosComServicosRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.Nome,
			&i.Descricao,
			&i.Cor,
			&i.Icone,
			&i.Ativa,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.TotalServicos,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategoriasServicos = `-- name: ListCategoriasServicos :many
SELECT 
    id,
    tenant_id,
    unit_id,
    nome,
    descricao,
    cor,
    icone,
    ativa,
    criado_em,
    atualizado_em
FROM categorias_servicos
WHERE tenant_id = $1 AND unit_id = $2
ORDER BY nome ASC
`

type ListCategoriasServicosParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UnitID   pgtype.UUID `json:"unit_id"`
}

func (q *Queries) ListCategoriasServicos(ctx context.Context, arg ListCategoriasServicosParams) ([]CategoriasServico, error) {
	rows, err := q.db.Query(ctx, listCategoriasServicos, arg.TenantID, arg.UnitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CategoriasServico{}
	for rows.Next() {
		var i CategoriasServico
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.Nome,
			&i.Descricao,
			&i.Cor,
			&i.Icone,
			&i.Ativa,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategoriasServicosAtivas = `-- name: ListCategoriasServicosAtivas :many
SELECT 
    id,
    tenant_id,
    unit_id,
    nome,
    descricao,
    cor,
    icone,
    ativa,
    criado_em,
    atualizado_em
FROM categorias_servicos
WHERE tenant_id = $1 AND unit_id = $2 AND ativa = true
ORDER BY nome ASC
`

type ListCategoriasServicosAtivasParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UnitID   pgtype.UUID `json:"unit_id"`
}

func (q *Queries) ListCategoriasServicosAtivas(ctx context.Context, arg ListCategoriasServicosAtivasParams) ([]CategoriasServico, error) {
	rows, err := q.db.Query(ctx, listCategoriasServicosAtivas, arg.TenantID, arg.UnitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CategoriasServico{}
	for rows.Next() {
		var i CategoriasServico
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.Nome,
			&i.Descricao,
			&i.Cor,
			&i.Icone,
			&i.Ativa,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleCategoriaServicoStatus = `-- name: ToggleCategoriaServicoStatus :one
UPDATE categorias_servicos SET
    ativa = $3,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, nome, descricao, cor, icone, ativa, criado_em, atualizado_em
`

type ToggleCategoriaServicoStatusParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Ativa    *bool       `json:"ativa"`
}

func (q *Queries) ToggleCategoriaServicoStatus(ctx context.Context, arg ToggleCategoriaServicoStatusParams) (CategoriasServico, error) {
	row := q.db.QueryRow(ctx, toggleCategoriaServicoStatus, arg.ID, arg.TenantID, arg.Ativa)
	var i CategoriasServico
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Descricao,
		&i.Cor,
		&i.Icone,
		&i.Ativa,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const updateCategoriaServico = `-- name: UpdateCategoriaServico :one

UPDATE categorias_servicos SET
    nome = $3,
    descricao = $4,
    cor = $5,
    icone = $6,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, nome, descricao, cor, icone, ativa, criado_em, atualizado_em
`

type UpdateCategoriaServicoParams struct {
	ID        pgtype.UUID `json:"id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
	Nome      string      `json:"nome"`
	Descricao *string     `json:"descricao"`
	Cor       *string     `json:"cor"`
	Icone     *string     `json:"icone"`
}

// ============================================================================
// UPDATE
// ============================================================================
func (q *Queries) UpdateCategoriaServico(ctx context.Context, arg UpdateCategoriaServicoParams) (CategoriasServico, error) {
	row := q.db.QueryRow(ctx, updateCategoriaServico,
		arg.ID,
		arg.TenantID,
		arg.Nome,
		arg.Descricao,
		arg.Cor,
		arg.Icone,
	)
	var i CategoriasServico
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Descricao,
		&i.Cor,
		&i.Icone,
		&i.Ativa,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}
