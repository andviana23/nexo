// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stock.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const atualizarQuantidadeProduto = `-- name: AtualizarQuantidadeProduto :one
UPDATE produtos
SET
    quantidade_atual = $3,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, categoria_id, categoria_produto_id, fornecedor_id, nome, descricao, sku, codigo_barras, preco, custo, valor_venda_profissional, valor_entrada, estoque, estoque_minimo, estoque_maximo, unidade, fornecedor, categoria_produto, centro_custo, unidade_medida, quantidade_atual, quantidade_minima, localizacao, lote, data_validade, ncm, permite_venda, controla_validade, lead_time_dias, imagem, observacoes, ativo, unit_id, criado_em, atualizado_em
`

type AtualizarQuantidadeProdutoParams struct {
	ID              pgtype.UUID     `json:"id"`
	TenantID        pgtype.UUID     `json:"tenant_id"`
	QuantidadeAtual decimal.Decimal `json:"quantidade_atual"`
}

func (q *Queries) AtualizarQuantidadeProduto(ctx context.Context, arg AtualizarQuantidadeProdutoParams) (Produto, error) {
	row := q.db.QueryRow(ctx, atualizarQuantidadeProduto, arg.ID, arg.TenantID, arg.QuantidadeAtual)
	var i Produto
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoriaID,
		&i.CategoriaProdutoID,
		&i.FornecedorID,
		&i.Nome,
		&i.Descricao,
		&i.Sku,
		&i.CodigoBarras,
		&i.Preco,
		&i.Custo,
		&i.ValorVendaProfissional,
		&i.ValorEntrada,
		&i.Estoque,
		&i.EstoqueMinimo,
		&i.EstoqueMaximo,
		&i.Unidade,
		&i.Fornecedor,
		&i.CategoriaProduto,
		&i.CentroCusto,
		&i.UnidadeMedida,
		&i.QuantidadeAtual,
		&i.QuantidadeMinima,
		&i.Localizacao,
		&i.Lote,
		&i.DataValidade,
		&i.Ncm,
		&i.PermiteVenda,
		&i.ControlaValidade,
		&i.LeadTimeDias,
		&i.Imagem,
		&i.Observacoes,
		&i.Ativo,
		&i.UnitID,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const createFornecedor = `-- name: CreateFornecedor :one


INSERT INTO fornecedores (
    tenant_id,
    razao_social,
    nome_fantasia,
    cnpj,
    email,
    telefone,
    celular,
    endereco_logradouro,
    endereco_numero,
    endereco_complemento,
    endereco_bairro,
    endereco_cidade,
    endereco_estado,
    endereco_cep,
    banco,
    agencia,
    conta,
    observacoes,
    ativo
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19
)
RETURNING id, tenant_id, razao_social, nome_fantasia, cnpj, email, telefone, celular, endereco_logradouro, endereco_numero, endereco_complemento, endereco_bairro, endereco_cidade, endereco_estado, endereco_cep, banco, agencia, conta, observacoes, ativo, criado_em, atualizado_em
`

type CreateFornecedorParams struct {
	TenantID            pgtype.UUID `json:"tenant_id"`
	RazaoSocial         string      `json:"razao_social"`
	NomeFantasia        *string     `json:"nome_fantasia"`
	Cnpj                string      `json:"cnpj"`
	Email               *string     `json:"email"`
	Telefone            *string     `json:"telefone"`
	Celular             *string     `json:"celular"`
	EnderecoLogradouro  *string     `json:"endereco_logradouro"`
	EnderecoNumero      *string     `json:"endereco_numero"`
	EnderecoComplemento *string     `json:"endereco_complemento"`
	EnderecoBairro      *string     `json:"endereco_bairro"`
	EnderecoCidade      *string     `json:"endereco_cidade"`
	EnderecoEstado      *string     `json:"endereco_estado"`
	EnderecoCep         *string     `json:"endereco_cep"`
	Banco               *string     `json:"banco"`
	Agencia             *string     `json:"agencia"`
	Conta               *string     `json:"conta"`
	Observacoes         *string     `json:"observacoes"`
	Ativo               bool        `json:"ativo"`
}

// ========================================
// QUERIES SQL - MÓDULO DE ESTOQUE
// Geradas via sqlc para type-safety
// ========================================
// ========================================
// FORNECEDORES
// ========================================
func (q *Queries) CreateFornecedor(ctx context.Context, arg CreateFornecedorParams) (Fornecedore, error) {
	row := q.db.QueryRow(ctx, createFornecedor,
		arg.TenantID,
		arg.RazaoSocial,
		arg.NomeFantasia,
		arg.Cnpj,
		arg.Email,
		arg.Telefone,
		arg.Celular,
		arg.EnderecoLogradouro,
		arg.EnderecoNumero,
		arg.EnderecoComplemento,
		arg.EnderecoBairro,
		arg.EnderecoCidade,
		arg.EnderecoEstado,
		arg.EnderecoCep,
		arg.Banco,
		arg.Agencia,
		arg.Conta,
		arg.Observacoes,
		arg.Ativo,
	)
	var i Fornecedore
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RazaoSocial,
		&i.NomeFantasia,
		&i.Cnpj,
		&i.Email,
		&i.Telefone,
		&i.Celular,
		&i.EnderecoLogradouro,
		&i.EnderecoNumero,
		&i.EnderecoComplemento,
		&i.EnderecoBairro,
		&i.EnderecoCidade,
		&i.EnderecoEstado,
		&i.EnderecoCep,
		&i.Banco,
		&i.Agencia,
		&i.Conta,
		&i.Observacoes,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const createMovimentacaoEstoque = `-- name: CreateMovimentacaoEstoque :one

INSERT INTO movimentacoes_estoque (
    tenant_id,
    produto_id,
    tipo_movimentacao,
    quantidade,
    valor_unitario,
    valor_total,
    fornecedor_id,
    usuario_id,
    data_movimentacao,
    observacoes,
    documento
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING id, tenant_id, produto_id, tipo_movimentacao, quantidade, valor_unitario, valor_total, fornecedor_id, usuario_id, data_movimentacao, observacoes, documento, criado_em, atualizado_em
`

type CreateMovimentacaoEstoqueParams struct {
	TenantID         pgtype.UUID        `json:"tenant_id"`
	ProdutoID        pgtype.UUID        `json:"produto_id"`
	TipoMovimentacao string             `json:"tipo_movimentacao"`
	Quantidade       decimal.Decimal    `json:"quantidade"`
	ValorUnitario    decimal.Decimal    `json:"valor_unitario"`
	ValorTotal       decimal.Decimal    `json:"valor_total"`
	FornecedorID     pgtype.UUID        `json:"fornecedor_id"`
	UsuarioID        pgtype.UUID        `json:"usuario_id"`
	DataMovimentacao pgtype.Timestamptz `json:"data_movimentacao"`
	Observacoes      *string            `json:"observacoes"`
	Documento        *string            `json:"documento"`
}

// ========================================
// MOVIMENTAÇÕES DE ESTOQUE
// ========================================
func (q *Queries) CreateMovimentacaoEstoque(ctx context.Context, arg CreateMovimentacaoEstoqueParams) (MovimentacoesEstoque, error) {
	row := q.db.QueryRow(ctx, createMovimentacaoEstoque,
		arg.TenantID,
		arg.ProdutoID,
		arg.TipoMovimentacao,
		arg.Quantidade,
		arg.ValorUnitario,
		arg.ValorTotal,
		arg.FornecedorID,
		arg.UsuarioID,
		arg.DataMovimentacao,
		arg.Observacoes,
		arg.Documento,
	)
	var i MovimentacoesEstoque
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProdutoID,
		&i.TipoMovimentacao,
		&i.Quantidade,
		&i.ValorUnitario,
		&i.ValorTotal,
		&i.FornecedorID,
		&i.UsuarioID,
		&i.DataMovimentacao,
		&i.Observacoes,
		&i.Documento,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const createProduto = `-- name: CreateProduto :one

INSERT INTO produtos (
    tenant_id,
    categoria_produto_id,
    nome,
    descricao,
    sku,
    codigo_barras,
    preco,
    custo,
    unidade_medida,
    quantidade_atual,
    quantidade_minima,
    estoque_maximo,
    valor_venda_profissional,
    valor_entrada,
    fornecedor_id,
    localizacao,
    lote,
    data_validade,
    ncm,
    permite_venda,
    ativo
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21
)
RETURNING id, tenant_id, categoria_id, categoria_produto_id, fornecedor_id, nome, descricao, sku, codigo_barras, preco, custo, valor_venda_profissional, valor_entrada, estoque, estoque_minimo, estoque_maximo, unidade, fornecedor, categoria_produto, centro_custo, unidade_medida, quantidade_atual, quantidade_minima, localizacao, lote, data_validade, ncm, permite_venda, controla_validade, lead_time_dias, imagem, observacoes, ativo, unit_id, criado_em, atualizado_em
`

type CreateProdutoParams struct {
	TenantID               pgtype.UUID     `json:"tenant_id"`
	CategoriaProdutoID     pgtype.UUID     `json:"categoria_produto_id"`
	Nome                   string          `json:"nome"`
	Descricao              *string         `json:"descricao"`
	Sku                    *string         `json:"sku"`
	CodigoBarras           *string         `json:"codigo_barras"`
	Preco                  decimal.Decimal `json:"preco"`
	Custo                  pgtype.Numeric  `json:"custo"`
	UnidadeMedida          string          `json:"unidade_medida"`
	QuantidadeAtual        decimal.Decimal `json:"quantidade_atual"`
	QuantidadeMinima       decimal.Decimal `json:"quantidade_minima"`
	EstoqueMaximo          *int32          `json:"estoque_maximo"`
	ValorVendaProfissional pgtype.Numeric  `json:"valor_venda_profissional"`
	ValorEntrada           pgtype.Numeric  `json:"valor_entrada"`
	FornecedorID           pgtype.UUID     `json:"fornecedor_id"`
	Localizacao            *string         `json:"localizacao"`
	Lote                   *string         `json:"lote"`
	DataValidade           pgtype.Date     `json:"data_validade"`
	Ncm                    *string         `json:"ncm"`
	PermiteVenda           bool            `json:"permite_venda"`
	Ativo                  *bool           `json:"ativo"`
}

// ========================================
// PRODUTOS (operações de estoque)
// ========================================
func (q *Queries) CreateProduto(ctx context.Context, arg CreateProdutoParams) (Produto, error) {
	row := q.db.QueryRow(ctx, createProduto,
		arg.TenantID,
		arg.CategoriaProdutoID,
		arg.Nome,
		arg.Descricao,
		arg.Sku,
		arg.CodigoBarras,
		arg.Preco,
		arg.Custo,
		arg.UnidadeMedida,
		arg.QuantidadeAtual,
		arg.QuantidadeMinima,
		arg.EstoqueMaximo,
		arg.ValorVendaProfissional,
		arg.ValorEntrada,
		arg.FornecedorID,
		arg.Localizacao,
		arg.Lote,
		arg.DataValidade,
		arg.Ncm,
		arg.PermiteVenda,
		arg.Ativo,
	)
	var i Produto
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoriaID,
		&i.CategoriaProdutoID,
		&i.FornecedorID,
		&i.Nome,
		&i.Descricao,
		&i.Sku,
		&i.CodigoBarras,
		&i.Preco,
		&i.Custo,
		&i.ValorVendaProfissional,
		&i.ValorEntrada,
		&i.Estoque,
		&i.EstoqueMinimo,
		&i.EstoqueMaximo,
		&i.Unidade,
		&i.Fornecedor,
		&i.CategoriaProduto,
		&i.CentroCusto,
		&i.UnidadeMedida,
		&i.QuantidadeAtual,
		&i.QuantidadeMinima,
		&i.Localizacao,
		&i.Lote,
		&i.DataValidade,
		&i.Ncm,
		&i.PermiteVenda,
		&i.ControlaValidade,
		&i.LeadTimeDias,
		&i.Imagem,
		&i.Observacoes,
		&i.Ativo,
		&i.UnitID,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const createProdutoFornecedor = `-- name: CreateProdutoFornecedor :one

INSERT INTO produto_fornecedor (
    tenant_id,
    produto_id,
    fornecedor_id,
    codigo_fornecedor,
    preco_compra,
    prazo_entrega_dias,
    fornecedor_preferencial,
    ativo
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, tenant_id, produto_id, fornecedor_id, codigo_fornecedor, preco_compra, prazo_entrega_dias, fornecedor_preferencial, ativo, criado_em, atualizado_em
`

type CreateProdutoFornecedorParams struct {
	TenantID               pgtype.UUID    `json:"tenant_id"`
	ProdutoID              pgtype.UUID    `json:"produto_id"`
	FornecedorID           pgtype.UUID    `json:"fornecedor_id"`
	CodigoFornecedor       *string        `json:"codigo_fornecedor"`
	PrecoCompra            pgtype.Numeric `json:"preco_compra"`
	PrazoEntregaDias       *int32         `json:"prazo_entrega_dias"`
	FornecedorPreferencial *bool          `json:"fornecedor_preferencial"`
	Ativo                  bool           `json:"ativo"`
}

// ========================================
// PRODUTO-FORNECEDOR (relacionamento)
// ========================================
func (q *Queries) CreateProdutoFornecedor(ctx context.Context, arg CreateProdutoFornecedorParams) (ProdutoFornecedor, error) {
	row := q.db.QueryRow(ctx, createProdutoFornecedor,
		arg.TenantID,
		arg.ProdutoID,
		arg.FornecedorID,
		arg.CodigoFornecedor,
		arg.PrecoCompra,
		arg.PrazoEntregaDias,
		arg.FornecedorPreferencial,
		arg.Ativo,
	)
	var i ProdutoFornecedor
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProdutoID,
		&i.FornecedorID,
		&i.CodigoFornecedor,
		&i.PrecoCompra,
		&i.PrazoEntregaDias,
		&i.FornecedorPreferencial,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const deleteFornecedor = `-- name: DeleteFornecedor :exec
UPDATE fornecedores
SET ativo = false, atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
`

type DeleteFornecedorParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteFornecedor(ctx context.Context, arg DeleteFornecedorParams) error {
	_, err := q.db.Exec(ctx, deleteFornecedor, arg.ID, arg.TenantID)
	return err
}

const deleteProduto = `-- name: DeleteProduto :exec
UPDATE produtos
SET ativo = false, atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
`

type DeleteProdutoParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteProduto(ctx context.Context, arg DeleteProdutoParams) error {
	_, err := q.db.Exec(ctx, deleteProduto, arg.ID, arg.TenantID)
	return err
}

const deleteProdutoFornecedor = `-- name: DeleteProdutoFornecedor :exec
UPDATE produto_fornecedor
SET ativo = false, atualizado_em = NOW()
WHERE produto_id = $1
  AND fornecedor_id = $2
  AND tenant_id = $3
`

type DeleteProdutoFornecedorParams struct {
	ProdutoID    pgtype.UUID `json:"produto_id"`
	FornecedorID pgtype.UUID `json:"fornecedor_id"`
	TenantID     pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteProdutoFornecedor(ctx context.Context, arg DeleteProdutoFornecedorParams) error {
	_, err := q.db.Exec(ctx, deleteProdutoFornecedor, arg.ProdutoID, arg.FornecedorID, arg.TenantID)
	return err
}

const getCurvaABC = `-- name: GetCurvaABC :many
SELECT
    p.id,
    p.nome,
    p.sku,
    p.categoria_produto,
    p.quantidade_atual,
    p.custo,
    (p.quantidade_atual * COALESCE(p.custo, 0)) as valor_estoque,
    CASE
        WHEN ROW_NUMBER() OVER (ORDER BY (p.quantidade_atual * COALESCE(p.custo, 0)) DESC) <= (COUNT(*) OVER () * 0.2) THEN 'A'
        WHEN ROW_NUMBER() OVER (ORDER BY (p.quantidade_atual * COALESCE(p.custo, 0)) DESC) <= (COUNT(*) OVER () * 0.5) THEN 'B'
        ELSE 'C'
    END as classe_abc
FROM produtos p
WHERE p.tenant_id = $1 AND p.ativo = true
ORDER BY valor_estoque DESC
`

type GetCurvaABCRow struct {
	ID               pgtype.UUID     `json:"id"`
	Nome             string          `json:"nome"`
	Sku              *string         `json:"sku"`
	CategoriaProduto string          `json:"categoria_produto"`
	QuantidadeAtual  decimal.Decimal `json:"quantidade_atual"`
	Custo            pgtype.Numeric  `json:"custo"`
	ValorEstoque     int32           `json:"valor_estoque"`
	ClasseAbc        string          `json:"classe_abc"`
}

func (q *Queries) GetCurvaABC(ctx context.Context, tenantID pgtype.UUID) ([]GetCurvaABCRow, error) {
	rows, err := q.db.Query(ctx, getCurvaABC, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCurvaABCRow{}
	for rows.Next() {
		var i GetCurvaABCRow
		if err := rows.Scan(
			&i.ID,
			&i.Nome,
			&i.Sku,
			&i.CategoriaProduto,
			&i.QuantidadeAtual,
			&i.Custo,
			&i.ValorEstoque,
			&i.ClasseAbc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFornecedorByCNPJ = `-- name: GetFornecedorByCNPJ :one
SELECT id, tenant_id, razao_social, nome_fantasia, cnpj, email, telefone, celular, endereco_logradouro, endereco_numero, endereco_complemento, endereco_bairro, endereco_cidade, endereco_estado, endereco_cep, banco, agencia, conta, observacoes, ativo, criado_em, atualizado_em FROM fornecedores
WHERE cnpj = $1 AND tenant_id = $2
`

type GetFornecedorByCNPJParams struct {
	Cnpj     string      `json:"cnpj"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetFornecedorByCNPJ(ctx context.Context, arg GetFornecedorByCNPJParams) (Fornecedore, error) {
	row := q.db.QueryRow(ctx, getFornecedorByCNPJ, arg.Cnpj, arg.TenantID)
	var i Fornecedore
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RazaoSocial,
		&i.NomeFantasia,
		&i.Cnpj,
		&i.Email,
		&i.Telefone,
		&i.Celular,
		&i.EnderecoLogradouro,
		&i.EnderecoNumero,
		&i.EnderecoComplemento,
		&i.EnderecoBairro,
		&i.EnderecoCidade,
		&i.EnderecoEstado,
		&i.EnderecoCep,
		&i.Banco,
		&i.Agencia,
		&i.Conta,
		&i.Observacoes,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getFornecedorByID = `-- name: GetFornecedorByID :one
SELECT id, tenant_id, razao_social, nome_fantasia, cnpj, email, telefone, celular, endereco_logradouro, endereco_numero, endereco_complemento, endereco_bairro, endereco_cidade, endereco_estado, endereco_cep, banco, agencia, conta, observacoes, ativo, criado_em, atualizado_em FROM fornecedores
WHERE id = $1 AND tenant_id = $2
`

type GetFornecedorByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetFornecedorByID(ctx context.Context, arg GetFornecedorByIDParams) (Fornecedore, error) {
	row := q.db.QueryRow(ctx, getFornecedorByID, arg.ID, arg.TenantID)
	var i Fornecedore
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RazaoSocial,
		&i.NomeFantasia,
		&i.Cnpj,
		&i.Email,
		&i.Telefone,
		&i.Celular,
		&i.EnderecoLogradouro,
		&i.EnderecoNumero,
		&i.EnderecoComplemento,
		&i.EnderecoBairro,
		&i.EnderecoCidade,
		&i.EnderecoEstado,
		&i.EnderecoCep,
		&i.Banco,
		&i.Agencia,
		&i.Conta,
		&i.Observacoes,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getMovimentacaoByID = `-- name: GetMovimentacaoByID :one
SELECT id, tenant_id, produto_id, tipo_movimentacao, quantidade, valor_unitario, valor_total, fornecedor_id, usuario_id, data_movimentacao, observacoes, documento, criado_em, atualizado_em FROM movimentacoes_estoque
WHERE id = $1 AND tenant_id = $2
`

type GetMovimentacaoByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetMovimentacaoByID(ctx context.Context, arg GetMovimentacaoByIDParams) (MovimentacoesEstoque, error) {
	row := q.db.QueryRow(ctx, getMovimentacaoByID, arg.ID, arg.TenantID)
	var i MovimentacoesEstoque
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProdutoID,
		&i.TipoMovimentacao,
		&i.Quantidade,
		&i.ValorUnitario,
		&i.ValorTotal,
		&i.FornecedorID,
		&i.UsuarioID,
		&i.DataMovimentacao,
		&i.Observacoes,
		&i.Documento,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getMovimentacoesPorPeriodoComDetalhes = `-- name: GetMovimentacoesPorPeriodoComDetalhes :many
SELECT
    m.id, m.tenant_id, m.produto_id, m.tipo_movimentacao, m.quantidade, m.valor_unitario, m.valor_total, m.fornecedor_id, m.usuario_id, m.data_movimentacao, m.observacoes, m.documento, m.criado_em, m.atualizado_em,
    p.nome as produto_nome,
    p.sku as produto_sku,
    f.razao_social as fornecedor_nome,
    u.nome as usuario_nome
FROM movimentacoes_estoque m
JOIN produtos p ON m.produto_id = p.id
LEFT JOIN fornecedores f ON m.fornecedor_id = f.id
LEFT JOIN users u ON m.usuario_id = u.id
WHERE m.tenant_id = $1
  AND m.data_movimentacao >= $2
  AND m.data_movimentacao <= $3
ORDER BY m.data_movimentacao DESC
`

type GetMovimentacoesPorPeriodoComDetalhesParams struct {
	TenantID           pgtype.UUID        `json:"tenant_id"`
	DataMovimentacao   pgtype.Timestamptz `json:"data_movimentacao"`
	DataMovimentacao_2 pgtype.Timestamptz `json:"data_movimentacao_2"`
}

type GetMovimentacoesPorPeriodoComDetalhesRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	ProdutoID        pgtype.UUID        `json:"produto_id"`
	TipoMovimentacao string             `json:"tipo_movimentacao"`
	Quantidade       decimal.Decimal    `json:"quantidade"`
	ValorUnitario    decimal.Decimal    `json:"valor_unitario"`
	ValorTotal       decimal.Decimal    `json:"valor_total"`
	FornecedorID     pgtype.UUID        `json:"fornecedor_id"`
	UsuarioID        pgtype.UUID        `json:"usuario_id"`
	DataMovimentacao pgtype.Timestamptz `json:"data_movimentacao"`
	Observacoes      *string            `json:"observacoes"`
	Documento        *string            `json:"documento"`
	CriadoEm         pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm     pgtype.Timestamptz `json:"atualizado_em"`
	ProdutoNome      string             `json:"produto_nome"`
	ProdutoSku       *string            `json:"produto_sku"`
	FornecedorNome   *string            `json:"fornecedor_nome"`
	UsuarioNome      *string            `json:"usuario_nome"`
}

func (q *Queries) GetMovimentacoesPorPeriodoComDetalhes(ctx context.Context, arg GetMovimentacoesPorPeriodoComDetalhesParams) ([]GetMovimentacoesPorPeriodoComDetalhesRow, error) {
	rows, err := q.db.Query(ctx, getMovimentacoesPorPeriodoComDetalhes, arg.TenantID, arg.DataMovimentacao, arg.DataMovimentacao_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMovimentacoesPorPeriodoComDetalhesRow{}
	for rows.Next() {
		var i GetMovimentacoesPorPeriodoComDetalhesRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProdutoID,
			&i.TipoMovimentacao,
			&i.Quantidade,
			&i.ValorUnitario,
			&i.ValorTotal,
			&i.FornecedorID,
			&i.UsuarioID,
			&i.DataMovimentacao,
			&i.Observacoes,
			&i.Documento,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.ProdutoNome,
			&i.ProdutoSku,
			&i.FornecedorNome,
			&i.UsuarioNome,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProdutoByCodigoBarras = `-- name: GetProdutoByCodigoBarras :one
SELECT id, tenant_id, categoria_id, categoria_produto_id, fornecedor_id, nome, descricao, sku, codigo_barras, preco, custo, valor_venda_profissional, valor_entrada, estoque, estoque_minimo, estoque_maximo, unidade, fornecedor, categoria_produto, centro_custo, unidade_medida, quantidade_atual, quantidade_minima, localizacao, lote, data_validade, ncm, permite_venda, controla_validade, lead_time_dias, imagem, observacoes, ativo, unit_id, criado_em, atualizado_em FROM produtos
WHERE codigo_barras = $1 AND tenant_id = $2
`

type GetProdutoByCodigoBarrasParams struct {
	CodigoBarras *string     `json:"codigo_barras"`
	TenantID     pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetProdutoByCodigoBarras(ctx context.Context, arg GetProdutoByCodigoBarrasParams) (Produto, error) {
	row := q.db.QueryRow(ctx, getProdutoByCodigoBarras, arg.CodigoBarras, arg.TenantID)
	var i Produto
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoriaID,
		&i.CategoriaProdutoID,
		&i.FornecedorID,
		&i.Nome,
		&i.Descricao,
		&i.Sku,
		&i.CodigoBarras,
		&i.Preco,
		&i.Custo,
		&i.ValorVendaProfissional,
		&i.ValorEntrada,
		&i.Estoque,
		&i.EstoqueMinimo,
		&i.EstoqueMaximo,
		&i.Unidade,
		&i.Fornecedor,
		&i.CategoriaProduto,
		&i.CentroCusto,
		&i.UnidadeMedida,
		&i.QuantidadeAtual,
		&i.QuantidadeMinima,
		&i.Localizacao,
		&i.Lote,
		&i.DataValidade,
		&i.Ncm,
		&i.PermiteVenda,
		&i.ControlaValidade,
		&i.LeadTimeDias,
		&i.Imagem,
		&i.Observacoes,
		&i.Ativo,
		&i.UnitID,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getProdutoByID = `-- name: GetProdutoByID :one
SELECT id, tenant_id, categoria_id, categoria_produto_id, fornecedor_id, nome, descricao, sku, codigo_barras, preco, custo, valor_venda_profissional, valor_entrada, estoque, estoque_minimo, estoque_maximo, unidade, fornecedor, categoria_produto, centro_custo, unidade_medida, quantidade_atual, quantidade_minima, localizacao, lote, data_validade, ncm, permite_venda, controla_validade, lead_time_dias, imagem, observacoes, ativo, unit_id, criado_em, atualizado_em FROM produtos
WHERE id = $1 AND tenant_id = $2
`

type GetProdutoByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetProdutoByID(ctx context.Context, arg GetProdutoByIDParams) (Produto, error) {
	row := q.db.QueryRow(ctx, getProdutoByID, arg.ID, arg.TenantID)
	var i Produto
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoriaID,
		&i.CategoriaProdutoID,
		&i.FornecedorID,
		&i.Nome,
		&i.Descricao,
		&i.Sku,
		&i.CodigoBarras,
		&i.Preco,
		&i.Custo,
		&i.ValorVendaProfissional,
		&i.ValorEntrada,
		&i.Estoque,
		&i.EstoqueMinimo,
		&i.EstoqueMaximo,
		&i.Unidade,
		&i.Fornecedor,
		&i.CategoriaProduto,
		&i.CentroCusto,
		&i.UnidadeMedida,
		&i.QuantidadeAtual,
		&i.QuantidadeMinima,
		&i.Localizacao,
		&i.Lote,
		&i.DataValidade,
		&i.Ncm,
		&i.PermiteVenda,
		&i.ControlaValidade,
		&i.LeadTimeDias,
		&i.Imagem,
		&i.Observacoes,
		&i.Ativo,
		&i.UnitID,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getProdutoBySKU = `-- name: GetProdutoBySKU :one
SELECT id, tenant_id, categoria_id, categoria_produto_id, fornecedor_id, nome, descricao, sku, codigo_barras, preco, custo, valor_venda_profissional, valor_entrada, estoque, estoque_minimo, estoque_maximo, unidade, fornecedor, categoria_produto, centro_custo, unidade_medida, quantidade_atual, quantidade_minima, localizacao, lote, data_validade, ncm, permite_venda, controla_validade, lead_time_dias, imagem, observacoes, ativo, unit_id, criado_em, atualizado_em FROM produtos
WHERE sku = $1 AND tenant_id = $2
`

type GetProdutoBySKUParams struct {
	Sku      *string     `json:"sku"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetProdutoBySKU(ctx context.Context, arg GetProdutoBySKUParams) (Produto, error) {
	row := q.db.QueryRow(ctx, getProdutoBySKU, arg.Sku, arg.TenantID)
	var i Produto
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoriaID,
		&i.CategoriaProdutoID,
		&i.FornecedorID,
		&i.Nome,
		&i.Descricao,
		&i.Sku,
		&i.CodigoBarras,
		&i.Preco,
		&i.Custo,
		&i.ValorVendaProfissional,
		&i.ValorEntrada,
		&i.Estoque,
		&i.EstoqueMinimo,
		&i.EstoqueMaximo,
		&i.Unidade,
		&i.Fornecedor,
		&i.CategoriaProduto,
		&i.CentroCusto,
		&i.UnidadeMedida,
		&i.QuantidadeAtual,
		&i.QuantidadeMinima,
		&i.Localizacao,
		&i.Lote,
		&i.DataValidade,
		&i.Ncm,
		&i.PermiteVenda,
		&i.ControlaValidade,
		&i.LeadTimeDias,
		&i.Imagem,
		&i.Observacoes,
		&i.Ativo,
		&i.UnitID,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getProdutoFornecedor = `-- name: GetProdutoFornecedor :one
SELECT id, tenant_id, produto_id, fornecedor_id, codigo_fornecedor, preco_compra, prazo_entrega_dias, fornecedor_preferencial, ativo, criado_em, atualizado_em FROM produto_fornecedor
WHERE produto_id = $1
  AND fornecedor_id = $2
  AND tenant_id = $3
`

type GetProdutoFornecedorParams struct {
	ProdutoID    pgtype.UUID `json:"produto_id"`
	FornecedorID pgtype.UUID `json:"fornecedor_id"`
	TenantID     pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetProdutoFornecedor(ctx context.Context, arg GetProdutoFornecedorParams) (ProdutoFornecedor, error) {
	row := q.db.QueryRow(ctx, getProdutoFornecedor, arg.ProdutoID, arg.FornecedorID, arg.TenantID)
	var i ProdutoFornecedor
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProdutoID,
		&i.FornecedorID,
		&i.CodigoFornecedor,
		&i.PrecoCompra,
		&i.PrazoEntregaDias,
		&i.FornecedorPreferencial,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getProdutosComEstoqueBaixo = `-- name: GetProdutosComEstoqueBaixo :many

SELECT
    p.id, p.tenant_id, p.categoria_id, p.categoria_produto_id, p.fornecedor_id, p.nome, p.descricao, p.sku, p.codigo_barras, p.preco, p.custo, p.valor_venda_profissional, p.valor_entrada, p.estoque, p.estoque_minimo, p.estoque_maximo, p.unidade, p.fornecedor, p.categoria_produto, p.centro_custo, p.unidade_medida, p.quantidade_atual, p.quantidade_minima, p.localizacao, p.lote, p.data_validade, p.ncm, p.permite_venda, p.controla_validade, p.lead_time_dias, p.imagem, p.observacoes, p.ativo, p.unit_id, p.criado_em, p.atualizado_em,
    (p.quantidade_atual / NULLIF(p.quantidade_minima, 0)) * 100 as percentual_estoque
FROM produtos p
WHERE p.tenant_id = $1
  AND p.ativo = true
  AND p.quantidade_atual <= p.quantidade_minima
ORDER BY percentual_estoque ASC
`

type GetProdutosComEstoqueBaixoRow struct {
	ID                     pgtype.UUID        `json:"id"`
	TenantID               pgtype.UUID        `json:"tenant_id"`
	CategoriaID            pgtype.UUID        `json:"categoria_id"`
	CategoriaProdutoID     pgtype.UUID        `json:"categoria_produto_id"`
	FornecedorID           pgtype.UUID        `json:"fornecedor_id"`
	Nome                   string             `json:"nome"`
	Descricao              *string            `json:"descricao"`
	Sku                    *string            `json:"sku"`
	CodigoBarras           *string            `json:"codigo_barras"`
	Preco                  decimal.Decimal    `json:"preco"`
	Custo                  pgtype.Numeric     `json:"custo"`
	ValorVendaProfissional pgtype.Numeric     `json:"valor_venda_profissional"`
	ValorEntrada           pgtype.Numeric     `json:"valor_entrada"`
	Estoque                *int32             `json:"estoque"`
	EstoqueMinimo          *int32             `json:"estoque_minimo"`
	EstoqueMaximo          *int32             `json:"estoque_maximo"`
	Unidade                *string            `json:"unidade"`
	Fornecedor             *string            `json:"fornecedor"`
	CategoriaProduto       string             `json:"categoria_produto"`
	CentroCusto            *string            `json:"centro_custo"`
	UnidadeMedida          string             `json:"unidade_medida"`
	QuantidadeAtual        decimal.Decimal    `json:"quantidade_atual"`
	QuantidadeMinima       decimal.Decimal    `json:"quantidade_minima"`
	Localizacao            *string            `json:"localizacao"`
	Lote                   *string            `json:"lote"`
	DataValidade           pgtype.Date        `json:"data_validade"`
	Ncm                    *string            `json:"ncm"`
	PermiteVenda           bool               `json:"permite_venda"`
	ControlaValidade       *bool              `json:"controla_validade"`
	LeadTimeDias           *int32             `json:"lead_time_dias"`
	Imagem                 *string            `json:"imagem"`
	Observacoes            *string            `json:"observacoes"`
	Ativo                  *bool              `json:"ativo"`
	UnitID                 pgtype.UUID        `json:"unit_id"`
	CriadoEm               pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm           pgtype.Timestamptz `json:"atualizado_em"`
	PercentualEstoque      int32              `json:"percentual_estoque"`
}

// ========================================
// RELATÓRIOS E CONSULTAS ESPECIAIS
// ========================================
func (q *Queries) GetProdutosComEstoqueBaixo(ctx context.Context, tenantID pgtype.UUID) ([]GetProdutosComEstoqueBaixoRow, error) {
	rows, err := q.db.Query(ctx, getProdutosComEstoqueBaixo, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProdutosComEstoqueBaixoRow{}
	for rows.Next() {
		var i GetProdutosComEstoqueBaixoRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoriaID,
			&i.CategoriaProdutoID,
			&i.FornecedorID,
			&i.Nome,
			&i.Descricao,
			&i.Sku,
			&i.CodigoBarras,
			&i.Preco,
			&i.Custo,
			&i.ValorVendaProfissional,
			&i.ValorEntrada,
			&i.Estoque,
			&i.EstoqueMinimo,
			&i.EstoqueMaximo,
			&i.Unidade,
			&i.Fornecedor,
			&i.CategoriaProduto,
			&i.CentroCusto,
			&i.UnidadeMedida,
			&i.QuantidadeAtual,
			&i.QuantidadeMinima,
			&i.Localizacao,
			&i.Lote,
			&i.DataValidade,
			&i.Ncm,
			&i.PermiteVenda,
			&i.ControlaValidade,
			&i.LeadTimeDias,
			&i.Imagem,
			&i.Observacoes,
			&i.Ativo,
			&i.UnitID,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.PercentualEstoque,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalPorTipo = `-- name: GetTotalPorTipo :one
SELECT
    tipo_movimentacao,
    SUM(quantidade) as total_quantidade,
    SUM(valor_total) as total_valor
FROM movimentacoes_estoque
WHERE tenant_id = $1
  AND tipo_movimentacao = $2
  AND data_movimentacao >= $3
  AND data_movimentacao <= $4
GROUP BY tipo_movimentacao
`

type GetTotalPorTipoParams struct {
	TenantID           pgtype.UUID        `json:"tenant_id"`
	TipoMovimentacao   string             `json:"tipo_movimentacao"`
	DataMovimentacao   pgtype.Timestamptz `json:"data_movimentacao"`
	DataMovimentacao_2 pgtype.Timestamptz `json:"data_movimentacao_2"`
}

type GetTotalPorTipoRow struct {
	TipoMovimentacao string `json:"tipo_movimentacao"`
	TotalQuantidade  int64  `json:"total_quantidade"`
	TotalValor       int64  `json:"total_valor"`
}

func (q *Queries) GetTotalPorTipo(ctx context.Context, arg GetTotalPorTipoParams) (GetTotalPorTipoRow, error) {
	row := q.db.QueryRow(ctx, getTotalPorTipo,
		arg.TenantID,
		arg.TipoMovimentacao,
		arg.DataMovimentacao,
		arg.DataMovimentacao_2,
	)
	var i GetTotalPorTipoRow
	err := row.Scan(&i.TipoMovimentacao, &i.TotalQuantidade, &i.TotalValor)
	return i, err
}

const getValorTotalEstoque = `-- name: GetValorTotalEstoque :one
SELECT
    SUM(quantidade_atual * COALESCE(custo, 0)) as valor_total_estoque,
    COUNT(*) as total_produtos
FROM produtos
WHERE tenant_id = $1 AND ativo = true
`

type GetValorTotalEstoqueRow struct {
	ValorTotalEstoque int64 `json:"valor_total_estoque"`
	TotalProdutos     int64 `json:"total_produtos"`
}

func (q *Queries) GetValorTotalEstoque(ctx context.Context, tenantID pgtype.UUID) (GetValorTotalEstoqueRow, error) {
	row := q.db.QueryRow(ctx, getValorTotalEstoque, tenantID)
	var i GetValorTotalEstoqueRow
	err := row.Scan(&i.ValorTotalEstoque, &i.TotalProdutos)
	return i, err
}

const listFornecedores = `-- name: ListFornecedores :many
SELECT id, tenant_id, razao_social, nome_fantasia, cnpj, email, telefone, celular, endereco_logradouro, endereco_numero, endereco_complemento, endereco_bairro, endereco_cidade, endereco_estado, endereco_cep, banco, agencia, conta, observacoes, ativo, criado_em, atualizado_em FROM fornecedores
WHERE tenant_id = $1
ORDER BY razao_social
`

func (q *Queries) ListFornecedores(ctx context.Context, tenantID pgtype.UUID) ([]Fornecedore, error) {
	rows, err := q.db.Query(ctx, listFornecedores, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Fornecedore{}
	for rows.Next() {
		var i Fornecedore
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.RazaoSocial,
			&i.NomeFantasia,
			&i.Cnpj,
			&i.Email,
			&i.Telefone,
			&i.Celular,
			&i.EnderecoLogradouro,
			&i.EnderecoNumero,
			&i.EnderecoComplemento,
			&i.EnderecoBairro,
			&i.EnderecoCidade,
			&i.EnderecoEstado,
			&i.EnderecoCep,
			&i.Banco,
			&i.Agencia,
			&i.Conta,
			&i.Observacoes,
			&i.Ativo,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFornecedoresAtivos = `-- name: ListFornecedoresAtivos :many
SELECT id, tenant_id, razao_social, nome_fantasia, cnpj, email, telefone, celular, endereco_logradouro, endereco_numero, endereco_complemento, endereco_bairro, endereco_cidade, endereco_estado, endereco_cep, banco, agencia, conta, observacoes, ativo, criado_em, atualizado_em FROM fornecedores
WHERE tenant_id = $1 AND ativo = true
ORDER BY razao_social
`

func (q *Queries) ListFornecedoresAtivos(ctx context.Context, tenantID pgtype.UUID) ([]Fornecedore, error) {
	rows, err := q.db.Query(ctx, listFornecedoresAtivos, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Fornecedore{}
	for rows.Next() {
		var i Fornecedore
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.RazaoSocial,
			&i.NomeFantasia,
			&i.Cnpj,
			&i.Email,
			&i.Telefone,
			&i.Celular,
			&i.EnderecoLogradouro,
			&i.EnderecoNumero,
			&i.EnderecoComplemento,
			&i.EnderecoBairro,
			&i.EnderecoCidade,
			&i.EnderecoEstado,
			&i.EnderecoCep,
			&i.Banco,
			&i.Agencia,
			&i.Conta,
			&i.Observacoes,
			&i.Ativo,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFornecedoresByProduto = `-- name: ListFornecedoresByProduto :many
SELECT
    pf.id, pf.tenant_id, pf.produto_id, pf.fornecedor_id, pf.codigo_fornecedor, pf.preco_compra, pf.prazo_entrega_dias, pf.fornecedor_preferencial, pf.ativo, pf.criado_em, pf.atualizado_em,
    f.razao_social,
    f.nome_fantasia,
    f.cnpj,
    f.email,
    f.telefone
FROM produto_fornecedor pf
JOIN fornecedores f ON pf.fornecedor_id = f.id
WHERE pf.produto_id = $1
  AND pf.tenant_id = $2
  AND pf.ativo = true
ORDER BY pf.fornecedor_preferencial DESC, f.razao_social
`

type ListFornecedoresByProdutoParams struct {
	ProdutoID pgtype.UUID `json:"produto_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

type ListFornecedoresByProdutoRow struct {
	ID                     pgtype.UUID        `json:"id"`
	TenantID               pgtype.UUID        `json:"tenant_id"`
	ProdutoID              pgtype.UUID        `json:"produto_id"`
	FornecedorID           pgtype.UUID        `json:"fornecedor_id"`
	CodigoFornecedor       *string            `json:"codigo_fornecedor"`
	PrecoCompra            pgtype.Numeric     `json:"preco_compra"`
	PrazoEntregaDias       *int32             `json:"prazo_entrega_dias"`
	FornecedorPreferencial *bool              `json:"fornecedor_preferencial"`
	Ativo                  bool               `json:"ativo"`
	CriadoEm               pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm           pgtype.Timestamptz `json:"atualizado_em"`
	RazaoSocial            string             `json:"razao_social"`
	NomeFantasia           *string            `json:"nome_fantasia"`
	Cnpj                   string             `json:"cnpj"`
	Email                  *string            `json:"email"`
	Telefone               *string            `json:"telefone"`
}

func (q *Queries) ListFornecedoresByProduto(ctx context.Context, arg ListFornecedoresByProdutoParams) ([]ListFornecedoresByProdutoRow, error) {
	rows, err := q.db.Query(ctx, listFornecedoresByProduto, arg.ProdutoID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFornecedoresByProdutoRow{}
	for rows.Next() {
		var i ListFornecedoresByProdutoRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProdutoID,
			&i.FornecedorID,
			&i.CodigoFornecedor,
			&i.PrecoCompra,
			&i.PrazoEntregaDias,
			&i.FornecedorPreferencial,
			&i.Ativo,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.RazaoSocial,
			&i.NomeFantasia,
			&i.Cnpj,
			&i.Email,
			&i.Telefone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovimentacoesByFornecedor = `-- name: ListMovimentacoesByFornecedor :many
SELECT m.id, m.tenant_id, m.produto_id, m.tipo_movimentacao, m.quantidade, m.valor_unitario, m.valor_total, m.fornecedor_id, m.usuario_id, m.data_movimentacao, m.observacoes, m.documento, m.criado_em, m.atualizado_em
FROM movimentacoes_estoque m
WHERE m.tenant_id = $1 AND m.fornecedor_id = $2
ORDER BY m.data_movimentacao DESC
LIMIT $3 OFFSET $4
`

type ListMovimentacoesByFornecedorParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	FornecedorID pgtype.UUID `json:"fornecedor_id"`
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
}

func (q *Queries) ListMovimentacoesByFornecedor(ctx context.Context, arg ListMovimentacoesByFornecedorParams) ([]MovimentacoesEstoque, error) {
	rows, err := q.db.Query(ctx, listMovimentacoesByFornecedor,
		arg.TenantID,
		arg.FornecedorID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovimentacoesEstoque{}
	for rows.Next() {
		var i MovimentacoesEstoque
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProdutoID,
			&i.TipoMovimentacao,
			&i.Quantidade,
			&i.ValorUnitario,
			&i.ValorTotal,
			&i.FornecedorID,
			&i.UsuarioID,
			&i.DataMovimentacao,
			&i.Observacoes,
			&i.Documento,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovimentacoesByPeriodo = `-- name: ListMovimentacoesByPeriodo :many
SELECT m.id, m.tenant_id, m.produto_id, m.tipo_movimentacao, m.quantidade, m.valor_unitario, m.valor_total, m.fornecedor_id, m.usuario_id, m.data_movimentacao, m.observacoes, m.documento, m.criado_em, m.atualizado_em
FROM movimentacoes_estoque m
WHERE m.tenant_id = $1
  AND m.data_movimentacao >= $2
  AND m.data_movimentacao <= $3
ORDER BY m.data_movimentacao DESC
`

type ListMovimentacoesByPeriodoParams struct {
	TenantID           pgtype.UUID        `json:"tenant_id"`
	DataMovimentacao   pgtype.Timestamptz `json:"data_movimentacao"`
	DataMovimentacao_2 pgtype.Timestamptz `json:"data_movimentacao_2"`
}

func (q *Queries) ListMovimentacoesByPeriodo(ctx context.Context, arg ListMovimentacoesByPeriodoParams) ([]MovimentacoesEstoque, error) {
	rows, err := q.db.Query(ctx, listMovimentacoesByPeriodo, arg.TenantID, arg.DataMovimentacao, arg.DataMovimentacao_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovimentacoesEstoque{}
	for rows.Next() {
		var i MovimentacoesEstoque
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProdutoID,
			&i.TipoMovimentacao,
			&i.Quantidade,
			&i.ValorUnitario,
			&i.ValorTotal,
			&i.FornecedorID,
			&i.UsuarioID,
			&i.DataMovimentacao,
			&i.Observacoes,
			&i.Documento,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovimentacoesByProduto = `-- name: ListMovimentacoesByProduto :many
SELECT m.id, m.tenant_id, m.produto_id, m.tipo_movimentacao, m.quantidade, m.valor_unitario, m.valor_total, m.fornecedor_id, m.usuario_id, m.data_movimentacao, m.observacoes, m.documento, m.criado_em, m.atualizado_em
FROM movimentacoes_estoque m
WHERE m.tenant_id = $1 AND m.produto_id = $2
ORDER BY m.data_movimentacao DESC
LIMIT $3 OFFSET $4
`

type ListMovimentacoesByProdutoParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	ProdutoID pgtype.UUID `json:"produto_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListMovimentacoesByProduto(ctx context.Context, arg ListMovimentacoesByProdutoParams) ([]MovimentacoesEstoque, error) {
	rows, err := q.db.Query(ctx, listMovimentacoesByProduto,
		arg.TenantID,
		arg.ProdutoID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovimentacoesEstoque{}
	for rows.Next() {
		var i MovimentacoesEstoque
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProdutoID,
			&i.TipoMovimentacao,
			&i.Quantidade,
			&i.ValorUnitario,
			&i.ValorTotal,
			&i.FornecedorID,
			&i.UsuarioID,
			&i.DataMovimentacao,
			&i.Observacoes,
			&i.Documento,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMovimentacoesByTipo = `-- name: ListMovimentacoesByTipo :many
SELECT m.id, m.tenant_id, m.produto_id, m.tipo_movimentacao, m.quantidade, m.valor_unitario, m.valor_total, m.fornecedor_id, m.usuario_id, m.data_movimentacao, m.observacoes, m.documento, m.criado_em, m.atualizado_em
FROM movimentacoes_estoque m
WHERE m.tenant_id = $1 AND m.tipo_movimentacao = $2
ORDER BY m.data_movimentacao DESC
LIMIT $3 OFFSET $4
`

type ListMovimentacoesByTipoParams struct {
	TenantID         pgtype.UUID `json:"tenant_id"`
	TipoMovimentacao string      `json:"tipo_movimentacao"`
	Limit            int32       `json:"limit"`
	Offset           int32       `json:"offset"`
}

func (q *Queries) ListMovimentacoesByTipo(ctx context.Context, arg ListMovimentacoesByTipoParams) ([]MovimentacoesEstoque, error) {
	rows, err := q.db.Query(ctx, listMovimentacoesByTipo,
		arg.TenantID,
		arg.TipoMovimentacao,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MovimentacoesEstoque{}
	for rows.Next() {
		var i MovimentacoesEstoque
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProdutoID,
			&i.TipoMovimentacao,
			&i.Quantidade,
			&i.ValorUnitario,
			&i.ValorTotal,
			&i.FornecedorID,
			&i.UsuarioID,
			&i.DataMovimentacao,
			&i.Observacoes,
			&i.Documento,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProdutos = `-- name: ListProdutos :many
SELECT id, tenant_id, categoria_id, categoria_produto_id, fornecedor_id, nome, descricao, sku, codigo_barras, preco, custo, valor_venda_profissional, valor_entrada, estoque, estoque_minimo, estoque_maximo, unidade, fornecedor, categoria_produto, centro_custo, unidade_medida, quantidade_atual, quantidade_minima, localizacao, lote, data_validade, ncm, permite_venda, controla_validade, lead_time_dias, imagem, observacoes, ativo, unit_id, criado_em, atualizado_em FROM produtos
WHERE tenant_id = $1
ORDER BY nome
`

func (q *Queries) ListProdutos(ctx context.Context, tenantID pgtype.UUID) ([]Produto, error) {
	rows, err := q.db.Query(ctx, listProdutos, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Produto{}
	for rows.Next() {
		var i Produto
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoriaID,
			&i.CategoriaProdutoID,
			&i.FornecedorID,
			&i.Nome,
			&i.Descricao,
			&i.Sku,
			&i.CodigoBarras,
			&i.Preco,
			&i.Custo,
			&i.ValorVendaProfissional,
			&i.ValorEntrada,
			&i.Estoque,
			&i.EstoqueMinimo,
			&i.EstoqueMaximo,
			&i.Unidade,
			&i.Fornecedor,
			&i.CategoriaProduto,
			&i.CentroCusto,
			&i.UnidadeMedida,
			&i.QuantidadeAtual,
			&i.QuantidadeMinima,
			&i.Localizacao,
			&i.Lote,
			&i.DataValidade,
			&i.Ncm,
			&i.PermiteVenda,
			&i.ControlaValidade,
			&i.LeadTimeDias,
			&i.Imagem,
			&i.Observacoes,
			&i.Ativo,
			&i.UnitID,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProdutosAbaixoDoMinimo = `-- name: ListProdutosAbaixoDoMinimo :many
SELECT id, tenant_id, categoria_id, categoria_produto_id, fornecedor_id, nome, descricao, sku, codigo_barras, preco, custo, valor_venda_profissional, valor_entrada, estoque, estoque_minimo, estoque_maximo, unidade, fornecedor, categoria_produto, centro_custo, unidade_medida, quantidade_atual, quantidade_minima, localizacao, lote, data_validade, ncm, permite_venda, controla_validade, lead_time_dias, imagem, observacoes, ativo, unit_id, criado_em, atualizado_em FROM produtos
WHERE tenant_id = $1
  AND ativo = true
  AND quantidade_atual <= quantidade_minima
ORDER BY (quantidade_atual / NULLIF(quantidade_minima, 0)) ASC
`

func (q *Queries) ListProdutosAbaixoDoMinimo(ctx context.Context, tenantID pgtype.UUID) ([]Produto, error) {
	rows, err := q.db.Query(ctx, listProdutosAbaixoDoMinimo, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Produto{}
	for rows.Next() {
		var i Produto
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoriaID,
			&i.CategoriaProdutoID,
			&i.FornecedorID,
			&i.Nome,
			&i.Descricao,
			&i.Sku,
			&i.CodigoBarras,
			&i.Preco,
			&i.Custo,
			&i.ValorVendaProfissional,
			&i.ValorEntrada,
			&i.Estoque,
			&i.EstoqueMinimo,
			&i.EstoqueMaximo,
			&i.Unidade,
			&i.Fornecedor,
			&i.CategoriaProduto,
			&i.CentroCusto,
			&i.UnidadeMedida,
			&i.QuantidadeAtual,
			&i.QuantidadeMinima,
			&i.Localizacao,
			&i.Lote,
			&i.DataValidade,
			&i.Ncm,
			&i.PermiteVenda,
			&i.ControlaValidade,
			&i.LeadTimeDias,
			&i.Imagem,
			&i.Observacoes,
			&i.Ativo,
			&i.UnitID,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProdutosAtivos = `-- name: ListProdutosAtivos :many
SELECT id, tenant_id, categoria_id, categoria_produto_id, fornecedor_id, nome, descricao, sku, codigo_barras, preco, custo, valor_venda_profissional, valor_entrada, estoque, estoque_minimo, estoque_maximo, unidade, fornecedor, categoria_produto, centro_custo, unidade_medida, quantidade_atual, quantidade_minima, localizacao, lote, data_validade, ncm, permite_venda, controla_validade, lead_time_dias, imagem, observacoes, ativo, unit_id, criado_em, atualizado_em FROM produtos
WHERE tenant_id = $1 AND ativo = true
ORDER BY nome
`

func (q *Queries) ListProdutosAtivos(ctx context.Context, tenantID pgtype.UUID) ([]Produto, error) {
	rows, err := q.db.Query(ctx, listProdutosAtivos, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Produto{}
	for rows.Next() {
		var i Produto
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoriaID,
			&i.CategoriaProdutoID,
			&i.FornecedorID,
			&i.Nome,
			&i.Descricao,
			&i.Sku,
			&i.CodigoBarras,
			&i.Preco,
			&i.Custo,
			&i.ValorVendaProfissional,
			&i.ValorEntrada,
			&i.Estoque,
			&i.EstoqueMinimo,
			&i.EstoqueMaximo,
			&i.Unidade,
			&i.Fornecedor,
			&i.CategoriaProduto,
			&i.CentroCusto,
			&i.UnidadeMedida,
			&i.QuantidadeAtual,
			&i.QuantidadeMinima,
			&i.Localizacao,
			&i.Lote,
			&i.DataValidade,
			&i.Ncm,
			&i.PermiteVenda,
			&i.ControlaValidade,
			&i.LeadTimeDias,
			&i.Imagem,
			&i.Observacoes,
			&i.Ativo,
			&i.UnitID,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProdutosByCategoria = `-- name: ListProdutosByCategoria :many
SELECT id, tenant_id, categoria_id, categoria_produto_id, fornecedor_id, nome, descricao, sku, codigo_barras, preco, custo, valor_venda_profissional, valor_entrada, estoque, estoque_minimo, estoque_maximo, unidade, fornecedor, categoria_produto, centro_custo, unidade_medida, quantidade_atual, quantidade_minima, localizacao, lote, data_validade, ncm, permite_venda, controla_validade, lead_time_dias, imagem, observacoes, ativo, unit_id, criado_em, atualizado_em FROM produtos
WHERE tenant_id = $1 AND categoria_produto = $2 AND ativo = true
ORDER BY nome
`

type ListProdutosByCategoriaParams struct {
	TenantID         pgtype.UUID `json:"tenant_id"`
	CategoriaProduto string      `json:"categoria_produto"`
}

func (q *Queries) ListProdutosByCategoria(ctx context.Context, arg ListProdutosByCategoriaParams) ([]Produto, error) {
	rows, err := q.db.Query(ctx, listProdutosByCategoria, arg.TenantID, arg.CategoriaProduto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Produto{}
	for rows.Next() {
		var i Produto
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoriaID,
			&i.CategoriaProdutoID,
			&i.FornecedorID,
			&i.Nome,
			&i.Descricao,
			&i.Sku,
			&i.CodigoBarras,
			&i.Preco,
			&i.Custo,
			&i.ValorVendaProfissional,
			&i.ValorEntrada,
			&i.Estoque,
			&i.EstoqueMinimo,
			&i.EstoqueMaximo,
			&i.Unidade,
			&i.Fornecedor,
			&i.CategoriaProduto,
			&i.CentroCusto,
			&i.UnidadeMedida,
			&i.QuantidadeAtual,
			&i.QuantidadeMinima,
			&i.Localizacao,
			&i.Lote,
			&i.DataValidade,
			&i.Ncm,
			&i.PermiteVenda,
			&i.ControlaValidade,
			&i.LeadTimeDias,
			&i.Imagem,
			&i.Observacoes,
			&i.Ativo,
			&i.UnitID,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProdutosByFornecedor = `-- name: ListProdutosByFornecedor :many
SELECT
    pf.id, pf.tenant_id, pf.produto_id, pf.fornecedor_id, pf.codigo_fornecedor, pf.preco_compra, pf.prazo_entrega_dias, pf.fornecedor_preferencial, pf.ativo, pf.criado_em, pf.atualizado_em,
    p.nome,
    p.sku,
    p.categoria_produto,
    p.unidade_medida
FROM produto_fornecedor pf
JOIN produtos p ON pf.produto_id = p.id
WHERE pf.fornecedor_id = $1
  AND pf.tenant_id = $2
  AND pf.ativo = true
ORDER BY p.nome
`

type ListProdutosByFornecedorParams struct {
	FornecedorID pgtype.UUID `json:"fornecedor_id"`
	TenantID     pgtype.UUID `json:"tenant_id"`
}

type ListProdutosByFornecedorRow struct {
	ID                     pgtype.UUID        `json:"id"`
	TenantID               pgtype.UUID        `json:"tenant_id"`
	ProdutoID              pgtype.UUID        `json:"produto_id"`
	FornecedorID           pgtype.UUID        `json:"fornecedor_id"`
	CodigoFornecedor       *string            `json:"codigo_fornecedor"`
	PrecoCompra            pgtype.Numeric     `json:"preco_compra"`
	PrazoEntregaDias       *int32             `json:"prazo_entrega_dias"`
	FornecedorPreferencial *bool              `json:"fornecedor_preferencial"`
	Ativo                  bool               `json:"ativo"`
	CriadoEm               pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm           pgtype.Timestamptz `json:"atualizado_em"`
	Nome                   string             `json:"nome"`
	Sku                    *string            `json:"sku"`
	CategoriaProduto       string             `json:"categoria_produto"`
	UnidadeMedida          string             `json:"unidade_medida"`
}

func (q *Queries) ListProdutosByFornecedor(ctx context.Context, arg ListProdutosByFornecedorParams) ([]ListProdutosByFornecedorRow, error) {
	rows, err := q.db.Query(ctx, listProdutosByFornecedor, arg.FornecedorID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProdutosByFornecedorRow{}
	for rows.Next() {
		var i ListProdutosByFornecedorRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProdutoID,
			&i.FornecedorID,
			&i.CodigoFornecedor,
			&i.PrecoCompra,
			&i.PrazoEntregaDias,
			&i.FornecedorPreferencial,
			&i.Ativo,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.Nome,
			&i.Sku,
			&i.CategoriaProduto,
			&i.UnidadeMedida,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reativarFornecedor = `-- name: ReativarFornecedor :exec
UPDATE fornecedores
SET ativo = true, atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
`

type ReativarFornecedorParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) ReativarFornecedor(ctx context.Context, arg ReativarFornecedorParams) error {
	_, err := q.db.Exec(ctx, reativarFornecedor, arg.ID, arg.TenantID)
	return err
}

const updateFornecedor = `-- name: UpdateFornecedor :one
UPDATE fornecedores
SET
    razao_social = $3,
    nome_fantasia = $4,
    email = $5,
    telefone = $6,
    celular = $7,
    endereco_logradouro = $8,
    endereco_numero = $9,
    endereco_complemento = $10,
    endereco_bairro = $11,
    endereco_cidade = $12,
    endereco_estado = $13,
    endereco_cep = $14,
    banco = $15,
    agencia = $16,
    conta = $17,
    observacoes = $18,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, razao_social, nome_fantasia, cnpj, email, telefone, celular, endereco_logradouro, endereco_numero, endereco_complemento, endereco_bairro, endereco_cidade, endereco_estado, endereco_cep, banco, agencia, conta, observacoes, ativo, criado_em, atualizado_em
`

type UpdateFornecedorParams struct {
	ID                  pgtype.UUID `json:"id"`
	TenantID            pgtype.UUID `json:"tenant_id"`
	RazaoSocial         string      `json:"razao_social"`
	NomeFantasia        *string     `json:"nome_fantasia"`
	Email               *string     `json:"email"`
	Telefone            *string     `json:"telefone"`
	Celular             *string     `json:"celular"`
	EnderecoLogradouro  *string     `json:"endereco_logradouro"`
	EnderecoNumero      *string     `json:"endereco_numero"`
	EnderecoComplemento *string     `json:"endereco_complemento"`
	EnderecoBairro      *string     `json:"endereco_bairro"`
	EnderecoCidade      *string     `json:"endereco_cidade"`
	EnderecoEstado      *string     `json:"endereco_estado"`
	EnderecoCep         *string     `json:"endereco_cep"`
	Banco               *string     `json:"banco"`
	Agencia             *string     `json:"agencia"`
	Conta               *string     `json:"conta"`
	Observacoes         *string     `json:"observacoes"`
}

func (q *Queries) UpdateFornecedor(ctx context.Context, arg UpdateFornecedorParams) (Fornecedore, error) {
	row := q.db.QueryRow(ctx, updateFornecedor,
		arg.ID,
		arg.TenantID,
		arg.RazaoSocial,
		arg.NomeFantasia,
		arg.Email,
		arg.Telefone,
		arg.Celular,
		arg.EnderecoLogradouro,
		arg.EnderecoNumero,
		arg.EnderecoComplemento,
		arg.EnderecoBairro,
		arg.EnderecoCidade,
		arg.EnderecoEstado,
		arg.EnderecoCep,
		arg.Banco,
		arg.Agencia,
		arg.Conta,
		arg.Observacoes,
	)
	var i Fornecedore
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RazaoSocial,
		&i.NomeFantasia,
		&i.Cnpj,
		&i.Email,
		&i.Telefone,
		&i.Celular,
		&i.EnderecoLogradouro,
		&i.EnderecoNumero,
		&i.EnderecoComplemento,
		&i.EnderecoBairro,
		&i.EnderecoCidade,
		&i.EnderecoEstado,
		&i.EnderecoCep,
		&i.Banco,
		&i.Agencia,
		&i.Conta,
		&i.Observacoes,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const updateProduto = `-- name: UpdateProduto :one
UPDATE produtos
SET
    categoria_produto_id = $3,
    nome = $4,
    descricao = $5,
    sku = $6,
    codigo_barras = $7,
    preco = $8,
    custo = $9,
    unidade_medida = $10,
    quantidade_minima = $11,
    quantidade_atual = $12,
    estoque_maximo = $13,
    valor_venda_profissional = $14,
    valor_entrada = $15,
    fornecedor_id = $16,
    localizacao = $17,
    lote = $18,
    data_validade = $19,
    ncm = $20,
    permite_venda = $21,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, categoria_id, categoria_produto_id, fornecedor_id, nome, descricao, sku, codigo_barras, preco, custo, valor_venda_profissional, valor_entrada, estoque, estoque_minimo, estoque_maximo, unidade, fornecedor, categoria_produto, centro_custo, unidade_medida, quantidade_atual, quantidade_minima, localizacao, lote, data_validade, ncm, permite_venda, controla_validade, lead_time_dias, imagem, observacoes, ativo, unit_id, criado_em, atualizado_em
`

type UpdateProdutoParams struct {
	ID                     pgtype.UUID     `json:"id"`
	TenantID               pgtype.UUID     `json:"tenant_id"`
	CategoriaProdutoID     pgtype.UUID     `json:"categoria_produto_id"`
	Nome                   string          `json:"nome"`
	Descricao              *string         `json:"descricao"`
	Sku                    *string         `json:"sku"`
	CodigoBarras           *string         `json:"codigo_barras"`
	Preco                  decimal.Decimal `json:"preco"`
	Custo                  pgtype.Numeric  `json:"custo"`
	UnidadeMedida          string          `json:"unidade_medida"`
	QuantidadeMinima       decimal.Decimal `json:"quantidade_minima"`
	QuantidadeAtual        decimal.Decimal `json:"quantidade_atual"`
	EstoqueMaximo          *int32          `json:"estoque_maximo"`
	ValorVendaProfissional pgtype.Numeric  `json:"valor_venda_profissional"`
	ValorEntrada           pgtype.Numeric  `json:"valor_entrada"`
	FornecedorID           pgtype.UUID     `json:"fornecedor_id"`
	Localizacao            *string         `json:"localizacao"`
	Lote                   *string         `json:"lote"`
	DataValidade           pgtype.Date     `json:"data_validade"`
	Ncm                    *string         `json:"ncm"`
	PermiteVenda           bool            `json:"permite_venda"`
}

func (q *Queries) UpdateProduto(ctx context.Context, arg UpdateProdutoParams) (Produto, error) {
	row := q.db.QueryRow(ctx, updateProduto,
		arg.ID,
		arg.TenantID,
		arg.CategoriaProdutoID,
		arg.Nome,
		arg.Descricao,
		arg.Sku,
		arg.CodigoBarras,
		arg.Preco,
		arg.Custo,
		arg.UnidadeMedida,
		arg.QuantidadeMinima,
		arg.QuantidadeAtual,
		arg.EstoqueMaximo,
		arg.ValorVendaProfissional,
		arg.ValorEntrada,
		arg.FornecedorID,
		arg.Localizacao,
		arg.Lote,
		arg.DataValidade,
		arg.Ncm,
		arg.PermiteVenda,
	)
	var i Produto
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoriaID,
		&i.CategoriaProdutoID,
		&i.FornecedorID,
		&i.Nome,
		&i.Descricao,
		&i.Sku,
		&i.CodigoBarras,
		&i.Preco,
		&i.Custo,
		&i.ValorVendaProfissional,
		&i.ValorEntrada,
		&i.Estoque,
		&i.EstoqueMinimo,
		&i.EstoqueMaximo,
		&i.Unidade,
		&i.Fornecedor,
		&i.CategoriaProduto,
		&i.CentroCusto,
		&i.UnidadeMedida,
		&i.QuantidadeAtual,
		&i.QuantidadeMinima,
		&i.Localizacao,
		&i.Lote,
		&i.DataValidade,
		&i.Ncm,
		&i.PermiteVenda,
		&i.ControlaValidade,
		&i.LeadTimeDias,
		&i.Imagem,
		&i.Observacoes,
		&i.Ativo,
		&i.UnitID,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const updateProdutoFornecedor = `-- name: UpdateProdutoFornecedor :one
UPDATE produto_fornecedor
SET
    codigo_fornecedor = $4,
    preco_compra = $5,
    prazo_entrega_dias = $6,
    fornecedor_preferencial = $7,
    atualizado_em = NOW()
WHERE produto_id = $1
  AND fornecedor_id = $2
  AND tenant_id = $3
RETURNING id, tenant_id, produto_id, fornecedor_id, codigo_fornecedor, preco_compra, prazo_entrega_dias, fornecedor_preferencial, ativo, criado_em, atualizado_em
`

type UpdateProdutoFornecedorParams struct {
	ProdutoID              pgtype.UUID    `json:"produto_id"`
	FornecedorID           pgtype.UUID    `json:"fornecedor_id"`
	TenantID               pgtype.UUID    `json:"tenant_id"`
	CodigoFornecedor       *string        `json:"codigo_fornecedor"`
	PrecoCompra            pgtype.Numeric `json:"preco_compra"`
	PrazoEntregaDias       *int32         `json:"prazo_entrega_dias"`
	FornecedorPreferencial *bool          `json:"fornecedor_preferencial"`
}

func (q *Queries) UpdateProdutoFornecedor(ctx context.Context, arg UpdateProdutoFornecedorParams) (ProdutoFornecedor, error) {
	row := q.db.QueryRow(ctx, updateProdutoFornecedor,
		arg.ProdutoID,
		arg.FornecedorID,
		arg.TenantID,
		arg.CodigoFornecedor,
		arg.PrecoCompra,
		arg.PrazoEntregaDias,
		arg.FornecedorPreferencial,
	)
	var i ProdutoFornecedor
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProdutoID,
		&i.FornecedorID,
		&i.CodigoFornecedor,
		&i.PrecoCompra,
		&i.PrazoEntregaDias,
		&i.FornecedorPreferencial,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}
