package handler
package handler

import (
	"net/http"
	"time"

	"github.com/andviana23/barber-analytics-backend/internal/application/dto"
	"github.com/andviana23/barber-analytics-backend/internal/application/usecase/user"
	"github.com/andviana23/barber-analytics-backend/internal/infra/http/middleware"
	"github.com/labstack/echo/v4"
	"go.uber.org/zap"
)

// LGPDHandler gerencia endpoints de conformidade LGPD
type LGPDHandler struct {
	getPrefsUseCase    *user.GetUserPreferencesUseCase
	updatePrefsUseCase *user.UpdateUserPreferencesUseCase
	exportDataUseCase  *user.ExportDataUseCase

































































































































































































}	return c.JSON(http.StatusOK, response)	}		DeletedAt: time.Now(),		Message:   "Conta excluída com sucesso. Seus dados foram anonimizados conforme LGPD.",	response := &dto.DeleteAccountResponse{	}		return echo.NewHTTPError(http.StatusInternalServerError, "Erro ao deletar conta")		)			zap.Error(err),			zap.String("user_id", userID),		h.logger.Error("Erro ao deletar conta",	if err := h.deleteAcctUseCase.Execute(c.Request().Context(), deleteReq); err != nil {	}		Reason:   req.Reason,		Password: req.Password,		TenantID: tenantID,		UserID:   userID,	deleteReq := user.DeleteAccountRequest{	// TODO: Registrar em audit log antes de deletar	// TODO: Validar senha antes de deletar	)		zap.String("ip", c.RealIP()),		zap.String("reason", req.Reason),		zap.String("user_id", userID),		zap.String("tenant_id", tenantID),	h.logger.Warn("Solicitação de exclusão de conta (LGPD)",	}		return echo.NewHTTPError(http.StatusBadRequest, err.Error())	if err := c.Validate(&req); err != nil {	}		return echo.NewHTTPError(http.StatusBadRequest, "Dados inválidos")	if err := c.Bind(&req); err != nil {	var req dto.DeleteAccountRequest	userID := middleware.GetUserIDFromContext(c)	tenantID := middleware.GetTenantIDFromContext(c)func (h *LGPDHandler) DeleteAccount(c echo.Context) error {// @Router /api/v1/me [delete]// @Failure 500 {object} ErrorResponse// @Failure 401 {object} ErrorResponse "Senha incorreta"// @Failure 400 {object} ErrorResponse// @Success 200 {object} dto.DeleteAccountResponse// @Param request body dto.DeleteAccountRequest true "Senha para confirmar exclusão"// @Produce json// @Accept json// @Tags LGPD// @Description Realiza soft delete e anonimização de dados pessoais do usuário// @Summary Deletar conta (LGPD - Direito ao Esquecimento)// DeleteAccount deleta a conta do usuário (direito ao esquecimento LGPD Art. 18, VI)}	return c.JSON(http.StatusOK, data)	c.Response().Header().Set("Content-Type", "application/json")	c.Response().Header().Set("Content-Disposition", "attachment; filename=meus-dados.json")	// Configurar headers para download	}		return echo.NewHTTPError(http.StatusInternalServerError, "Erro ao exportar dados")		)			zap.Error(err),			zap.String("user_id", userID),		h.logger.Error("Erro ao exportar dados do usuário",	if err != nil {	data, err := h.exportDataUseCase.Execute(c.Request().Context(), tenantID, userID)	// TODO: Registrar em audit log	// TODO: Rate limiting - 1 export por dia por usuário	)		zap.String("ip", c.RealIP()),		zap.String("user_id", userID),		zap.String("tenant_id", tenantID),	h.logger.Info("Solicitação de exportação de dados (LGPD)",	userID := middleware.GetUserIDFromContext(c)	tenantID := middleware.GetTenantIDFromContext(c)func (h *LGPDHandler) ExportUserData(c echo.Context) error {// @Router /api/v1/me/export [get]// @Failure 500 {object} ErrorResponse// @Failure 429 {object} ErrorResponse "Rate limit: 1 export/dia"// @Failure 401 {object} ErrorResponse// @Success 200 {object} dto.ExportUserDataResponse// @Produce json// @Tags LGPD// @Description Retorna todos os dados pessoais do usuário em formato JSON (direito à portabilidade)// @Summary Exportar dados pessoais (LGPD - Portabilidade)// ExportUserData exporta todos os dados do usuário (portabilidade LGPD Art. 18, V)}	return c.JSON(http.StatusOK, response)	}		UpdatedAt:              time.Now(),		PersonalizedAdsConsent: req.PersonalizedAdsConsent,		ThirdPartyConsent:      req.ThirdPartyConsent,		AnalyticsConsent:       req.AnalyticsConsent,		MarketingConsent:       req.MarketingConsent,		DataSharingConsent:     req.DataSharingConsent,	response := &dto.GetUserPreferencesResponse{	)		zap.Bool("marketing", req.MarketingConsent),		zap.Bool("analytics", req.AnalyticsConsent),		zap.String("user_id", userID),	h.logger.Info("Preferências de privacidade atualizadas",	// prefs, err := h.updatePrefsUseCase.Execute(c.Request().Context(), tenantID, userID, req)	// TODO: Implementar use case de update	}		return echo.NewHTTPError(http.StatusBadRequest, "Dados inválidos")	if err := c.Bind(&req); err != nil {	var req dto.UpdateUserPreferencesRequest	userID := middleware.GetUserIDFromContext(c)	tenantID := middleware.GetTenantIDFromContext(c)func (h *LGPDHandler) UpdateUserPreferences(c echo.Context) error {// @Router /api/v1/me/preferences [put]// @Failure 500 {object} ErrorResponse// @Failure 401 {object} ErrorResponse// @Failure 400 {object} ErrorResponse// @Success 200 {object} dto.GetUserPreferencesResponse// @Param request body dto.UpdateUserPreferencesRequest true "Novas preferências"// @Produce json// @Accept json// @Tags LGPD// @Description Atualiza os consentimentos de privacidade do usuário autenticado// @Summary Atualizar preferências de privacidade (LGPD)// UpdateUserPreferences atualiza as preferências de privacidade}	return c.JSON(http.StatusOK, response)	}		UpdatedAt:              prefs.AtualizadoEm,		PersonalizedAdsConsent: prefs.PersonalizedAdsConsent,		ThirdPartyConsent:      prefs.ThirdPartyConsent,		AnalyticsConsent:       prefs.AnalyticsConsent,		MarketingConsent:       prefs.MarketingConsent,		DataSharingConsent:     prefs.DataSharingConsent,	response := &dto.GetUserPreferencesResponse{	}		return echo.NewHTTPError(http.StatusInternalServerError, "Erro ao buscar preferências")		)			zap.Error(err),			zap.String("user_id", userID),		h.logger.Error("Erro ao buscar preferências",	if err != nil {	prefs, err := h.getPrefsUseCase.Execute(c.Request().Context(), tenantID, userID)	userID := middleware.GetUserIDFromContext(c)	tenantID := middleware.GetTenantIDFromContext(c)func (h *LGPDHandler) GetUserPreferences(c echo.Context) error {// @Router /api/v1/me/preferences [get]// @Failure 500 {object} ErrorResponse// @Failure 401 {object} ErrorResponse// @Success 200 {object} dto.GetUserPreferencesResponse// @Produce json// @Tags LGPD// @Description Retorna os consentimentos de privacidade do usuário autenticado// @Summary Obter preferências de privacidade (LGPD)// GetUserPreferences retorna as preferências de privacidade do usuário}	}		logger:             logger,		deleteAcctUseCase:  deleteAcctUseCase,		exportDataUseCase:  exportDataUseCase,		updatePrefsUseCase: updatePrefsUseCase,		getPrefsUseCase:    getPrefsUseCase,	return &LGPDHandler{) *LGPDHandler {	logger *zap.Logger,	deleteAcctUseCase *user.DeleteAccountUseCase,	exportDataUseCase *user.ExportDataUseCase,	updatePrefsUseCase *user.UpdateUserPreferencesUseCase,	getPrefsUseCase *user.GetUserPreferencesUseCase,func NewLGPDHandler(// NewLGPDHandler cria um novo handler LGPD}	logger             *zap.Logger	deleteAcctUseCase  *user.DeleteAccountUseCase
