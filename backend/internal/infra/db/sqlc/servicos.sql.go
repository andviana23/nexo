// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: servicos.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const checkServicoNomeExists = `-- name: CheckServicoNomeExists :one
SELECT EXISTS(
    SELECT 1 
    FROM servicos 
    WHERE tenant_id = $1 
      AND ($4::uuid IS NULL OR unit_id = $4)
      AND LOWER(nome) = LOWER($2)
      AND id != COALESCE($3, '00000000-0000-0000-0000-000000000000'::uuid)
) AS exists
`

type CheckServicoNomeExistsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Lower    string      `json:"lower"`
	ID       pgtype.UUID `json:"id"`
	UnitID   pgtype.UUID `json:"unit_id"`
}

func (q *Queries) CheckServicoNomeExists(ctx context.Context, arg CheckServicoNomeExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkServicoNomeExists,
		arg.TenantID,
		arg.Lower,
		arg.ID,
		arg.UnitID,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countServicosAtivosByTenant = `-- name: CountServicosAtivosByTenant :one
SELECT COUNT(*) AS total
FROM servicos
WHERE tenant_id = $1 
  AND ($2::uuid IS NULL OR unit_id = $2)
  AND ativo = true
`

type CountServicosAtivosByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UnitID   pgtype.UUID `json:"unit_id"`
}

func (q *Queries) CountServicosAtivosByTenant(ctx context.Context, arg CountServicosAtivosByTenantParams) (int64, error) {
	row := q.db.QueryRow(ctx, countServicosAtivosByTenant, arg.TenantID, arg.UnitID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countServicosByTenant = `-- name: CountServicosByTenant :one

SELECT COUNT(*) AS total
FROM servicos
WHERE tenant_id = $1
  AND ($2::uuid IS NULL OR unit_id = $2)
`

type CountServicosByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UnitID   pgtype.UUID `json:"unit_id"`
}

// ============================================================================
// QUERIES AUXILIARES
// ============================================================================
func (q *Queries) CountServicosByTenant(ctx context.Context, arg CountServicosByTenantParams) (int64, error) {
	row := q.db.QueryRow(ctx, countServicosByTenant, arg.TenantID, arg.UnitID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createServico = `-- name: CreateServico :one


INSERT INTO servicos (
    id,
    tenant_id,
    unit_id,
    categoria_id,
    nome,
    descricao,
    preco,
    duracao,
    comissao,
    cor,
    imagem,
    profissionais_ids,
    observacoes,
    tags,
    ativo,
    criado_em,
    atualizado_em
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, NOW(), NOW()
) RETURNING id, tenant_id, unit_id, categoria_id, nome, descricao, preco, duracao, comissao, cor, imagem, profissionais_ids, observacoes, tags, ativo, criado_em, atualizado_em
`

type CreateServicoParams struct {
	ID               pgtype.UUID     `json:"id"`
	TenantID         pgtype.UUID     `json:"tenant_id"`
	UnitID           pgtype.UUID     `json:"unit_id"`
	CategoriaID      pgtype.UUID     `json:"categoria_id"`
	Nome             string          `json:"nome"`
	Descricao        *string         `json:"descricao"`
	Preco            decimal.Decimal `json:"preco"`
	Duracao          int32           `json:"duracao"`
	Comissao         pgtype.Numeric  `json:"comissao"`
	Cor              *string         `json:"cor"`
	Imagem           *string         `json:"imagem"`
	ProfissionaisIds []pgtype.UUID   `json:"profissionais_ids"`
	Observacoes      *string         `json:"observacoes"`
	Tags             []string        `json:"tags"`
	Ativo            *bool           `json:"ativo"`
}

// ============================================================================
// SERVIÇOS QUERIES (sqlc)
// Módulo de Cadastro de Serviços — NEXO v1.0
// Tabela: servicos (vinculada a categorias_servicos)
// ============================================================================
// ============================================================================
// CREATE
// ============================================================================
func (q *Queries) CreateServico(ctx context.Context, arg CreateServicoParams) (Servico, error) {
	row := q.db.QueryRow(ctx, createServico,
		arg.ID,
		arg.TenantID,
		arg.UnitID,
		arg.CategoriaID,
		arg.Nome,
		arg.Descricao,
		arg.Preco,
		arg.Duracao,
		arg.Comissao,
		arg.Cor,
		arg.Imagem,
		arg.ProfissionaisIds,
		arg.Observacoes,
		arg.Tags,
		arg.Ativo,
	)
	var i Servico
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.CategoriaID,
		&i.Nome,
		&i.Descricao,
		&i.Preco,
		&i.Duracao,
		&i.Comissao,
		&i.Cor,
		&i.Imagem,
		&i.ProfissionaisIds,
		&i.Observacoes,
		&i.Tags,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const deleteServico = `-- name: DeleteServico :exec

DELETE FROM servicos
WHERE id = $1 AND tenant_id = $2
`

type DeleteServicoParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// ============================================================================
// DELETE
// ============================================================================
func (q *Queries) DeleteServico(ctx context.Context, arg DeleteServicoParams) error {
	_, err := q.db.Exec(ctx, deleteServico, arg.ID, arg.TenantID)
	return err
}

const deleteServicosByCategoria = `-- name: DeleteServicosByCategoria :exec
DELETE FROM servicos
WHERE categoria_id = $1 AND tenant_id = $2
`

type DeleteServicosByCategoriaParams struct {
	CategoriaID pgtype.UUID `json:"categoria_id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteServicosByCategoria(ctx context.Context, arg DeleteServicosByCategoriaParams) error {
	_, err := q.db.Exec(ctx, deleteServicosByCategoria, arg.CategoriaID, arg.TenantID)
	return err
}

const getServicoByID = `-- name: GetServicoByID :one

SELECT 
    s.id,
    s.tenant_id,
    s.categoria_id,
    s.nome,
    s.descricao,
    s.preco,
    s.duracao,
    s.comissao,
    s.cor,
    s.imagem,
    s.profissionais_ids,
    s.observacoes,
    s.tags,
    s.ativo,
    s.criado_em,
    s.atualizado_em,
    cs.nome AS categoria_nome,
    cs.cor AS categoria_cor
FROM servicos s
LEFT JOIN categorias_servicos cs ON cs.id = s.categoria_id AND cs.tenant_id = s.tenant_id
WHERE s.id = $1 AND s.tenant_id = $2
  AND ($3::uuid IS NULL OR s.unit_id = $3)
`

type GetServicoByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	UnitID   pgtype.UUID `json:"unit_id"`
}

type GetServicoByIDRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	CategoriaID      pgtype.UUID        `json:"categoria_id"`
	Nome             string             `json:"nome"`
	Descricao        *string            `json:"descricao"`
	Preco            decimal.Decimal    `json:"preco"`
	Duracao          int32              `json:"duracao"`
	Comissao         pgtype.Numeric     `json:"comissao"`
	Cor              *string            `json:"cor"`
	Imagem           *string            `json:"imagem"`
	ProfissionaisIds []pgtype.UUID      `json:"profissionais_ids"`
	Observacoes      *string            `json:"observacoes"`
	Tags             []string           `json:"tags"`
	Ativo            *bool              `json:"ativo"`
	CriadoEm         pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm     pgtype.Timestamptz `json:"atualizado_em"`
	CategoriaNome    *string            `json:"categoria_nome"`
	CategoriaCor     *string            `json:"categoria_cor"`
}

// ============================================================================
// READ
// ============================================================================
func (q *Queries) GetServicoByID(ctx context.Context, arg GetServicoByIDParams) (GetServicoByIDRow, error) {
	row := q.db.QueryRow(ctx, getServicoByID, arg.ID, arg.TenantID, arg.UnitID)
	var i GetServicoByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoriaID,
		&i.Nome,
		&i.Descricao,
		&i.Preco,
		&i.Duracao,
		&i.Comissao,
		&i.Cor,
		&i.Imagem,
		&i.ProfissionaisIds,
		&i.Observacoes,
		&i.Tags,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
		&i.CategoriaNome,
		&i.CategoriaCor,
	)
	return i, err
}

const getServicosByIDs = `-- name: GetServicosByIDs :many
SELECT 
    s.id,
    s.tenant_id,
    s.categoria_id,
    s.nome,
    s.descricao,
    s.preco,
    s.duracao,
    s.comissao,
    s.cor,
    s.imagem,
    s.profissionais_ids,
    s.observacoes,
    s.tags,
    s.ativo,
    s.criado_em,
    s.atualizado_em,
    cs.nome AS categoria_nome,
    cs.cor AS categoria_cor
FROM servicos s
LEFT JOIN categorias_servicos cs ON cs.id = s.categoria_id AND cs.tenant_id = s.tenant_id
WHERE s.tenant_id = $1 AND s.id = ANY($2::uuid[])
ORDER BY s.nome ASC
`

type GetServicosByIDsParams struct {
	TenantID   pgtype.UUID   `json:"tenant_id"`
	ServicoIds []pgtype.UUID `json:"servico_ids"`
}

type GetServicosByIDsRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	CategoriaID      pgtype.UUID        `json:"categoria_id"`
	Nome             string             `json:"nome"`
	Descricao        *string            `json:"descricao"`
	Preco            decimal.Decimal    `json:"preco"`
	Duracao          int32              `json:"duracao"`
	Comissao         pgtype.Numeric     `json:"comissao"`
	Cor              *string            `json:"cor"`
	Imagem           *string            `json:"imagem"`
	ProfissionaisIds []pgtype.UUID      `json:"profissionais_ids"`
	Observacoes      *string            `json:"observacoes"`
	Tags             []string           `json:"tags"`
	Ativo            *bool              `json:"ativo"`
	CriadoEm         pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm     pgtype.Timestamptz `json:"atualizado_em"`
	CategoriaNome    *string            `json:"categoria_nome"`
	CategoriaCor     *string            `json:"categoria_cor"`
}

func (q *Queries) GetServicosByIDs(ctx context.Context, arg GetServicosByIDsParams) ([]GetServicosByIDsRow, error) {
	rows, err := q.db.Query(ctx, getServicosByIDs, arg.TenantID, arg.ServicoIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetServicosByIDsRow{}
	for rows.Next() {
		var i GetServicosByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoriaID,
			&i.Nome,
			&i.Descricao,
			&i.Preco,
			&i.Duracao,
			&i.Comissao,
			&i.Cor,
			&i.Imagem,
			&i.ProfissionaisIds,
			&i.Observacoes,
			&i.Tags,
			&i.Ativo,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.CategoriaNome,
			&i.CategoriaCor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServicosStats = `-- name: GetServicosStats :one
SELECT 
    COUNT(*) AS total_servicos,
    COUNT(*) FILTER (WHERE ativo = true) AS servicos_ativos,
    COUNT(*) FILTER (WHERE ativo = false) AS servicos_inativos,
    COALESCE(AVG(preco), 0) AS preco_medio,
    COALESCE(AVG(duracao), 0) AS duracao_media,
    COALESCE(AVG(comissao), 0) AS comissao_media
FROM servicos
WHERE tenant_id = $1
  AND ($2::uuid IS NULL OR unit_id = $2)
`

type GetServicosStatsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UnitID   pgtype.UUID `json:"unit_id"`
}

type GetServicosStatsRow struct {
	TotalServicos    int64       `json:"total_servicos"`
	ServicosAtivos   int64       `json:"servicos_ativos"`
	ServicosInativos int64       `json:"servicos_inativos"`
	PrecoMedio       interface{} `json:"preco_medio"`
	DuracaoMedia     interface{} `json:"duracao_media"`
	ComissaoMedia    interface{} `json:"comissao_media"`
}

func (q *Queries) GetServicosStats(ctx context.Context, arg GetServicosStatsParams) (GetServicosStatsRow, error) {
	row := q.db.QueryRow(ctx, getServicosStats, arg.TenantID, arg.UnitID)
	var i GetServicosStatsRow
	err := row.Scan(
		&i.TotalServicos,
		&i.ServicosAtivos,
		&i.ServicosInativos,
		&i.PrecoMedio,
		&i.DuracaoMedia,
		&i.ComissaoMedia,
	)
	return i, err
}

const listServicos = `-- name: ListServicos :many
SELECT 
    s.id,
    s.tenant_id,
    s.categoria_id,
    s.nome,
    s.descricao,
    s.preco,
    s.duracao,
    s.comissao,
    s.cor,
    s.imagem,
    s.profissionais_ids,
    s.observacoes,
    s.tags,
    s.ativo,
    s.criado_em,
    s.atualizado_em,
    cs.nome AS categoria_nome,
    cs.cor AS categoria_cor
FROM servicos s
LEFT JOIN categorias_servicos cs ON cs.id = s.categoria_id AND cs.tenant_id = s.tenant_id
WHERE s.tenant_id = $1
  AND ($2::uuid IS NULL OR s.unit_id = $2)
ORDER BY s.nome ASC
`

type ListServicosParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UnitID   pgtype.UUID `json:"unit_id"`
}

type ListServicosRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	CategoriaID      pgtype.UUID        `json:"categoria_id"`
	Nome             string             `json:"nome"`
	Descricao        *string            `json:"descricao"`
	Preco            decimal.Decimal    `json:"preco"`
	Duracao          int32              `json:"duracao"`
	Comissao         pgtype.Numeric     `json:"comissao"`
	Cor              *string            `json:"cor"`
	Imagem           *string            `json:"imagem"`
	ProfissionaisIds []pgtype.UUID      `json:"profissionais_ids"`
	Observacoes      *string            `json:"observacoes"`
	Tags             []string           `json:"tags"`
	Ativo            *bool              `json:"ativo"`
	CriadoEm         pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm     pgtype.Timestamptz `json:"atualizado_em"`
	CategoriaNome    *string            `json:"categoria_nome"`
	CategoriaCor     *string            `json:"categoria_cor"`
}

func (q *Queries) ListServicos(ctx context.Context, arg ListServicosParams) ([]ListServicosRow, error) {
	rows, err := q.db.Query(ctx, listServicos, arg.TenantID, arg.UnitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServicosRow{}
	for rows.Next() {
		var i ListServicosRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoriaID,
			&i.Nome,
			&i.Descricao,
			&i.Preco,
			&i.Duracao,
			&i.Comissao,
			&i.Cor,
			&i.Imagem,
			&i.ProfissionaisIds,
			&i.Observacoes,
			&i.Tags,
			&i.Ativo,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.CategoriaNome,
			&i.CategoriaCor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicosAtivos = `-- name: ListServicosAtivos :many
SELECT 
    s.id,
    s.tenant_id,
    s.categoria_id,
    s.nome,
    s.descricao,
    s.preco,
    s.duracao,
    s.comissao,
    s.cor,
    s.imagem,
    s.profissionais_ids,
    s.observacoes,
    s.tags,
    s.ativo,
    s.criado_em,
    s.atualizado_em,
    cs.nome AS categoria_nome,
    cs.cor AS categoria_cor
FROM servicos s
LEFT JOIN categorias_servicos cs ON cs.id = s.categoria_id AND cs.tenant_id = s.tenant_id
WHERE s.tenant_id = $1
  AND ($2::uuid IS NULL OR s.unit_id = $2)
  AND s.ativo = true
ORDER BY s.nome ASC
`

type ListServicosAtivosParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UnitID   pgtype.UUID `json:"unit_id"`
}

type ListServicosAtivosRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	CategoriaID      pgtype.UUID        `json:"categoria_id"`
	Nome             string             `json:"nome"`
	Descricao        *string            `json:"descricao"`
	Preco            decimal.Decimal    `json:"preco"`
	Duracao          int32              `json:"duracao"`
	Comissao         pgtype.Numeric     `json:"comissao"`
	Cor              *string            `json:"cor"`
	Imagem           *string            `json:"imagem"`
	ProfissionaisIds []pgtype.UUID      `json:"profissionais_ids"`
	Observacoes      *string            `json:"observacoes"`
	Tags             []string           `json:"tags"`
	Ativo            *bool              `json:"ativo"`
	CriadoEm         pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm     pgtype.Timestamptz `json:"atualizado_em"`
	CategoriaNome    *string            `json:"categoria_nome"`
	CategoriaCor     *string            `json:"categoria_cor"`
}

func (q *Queries) ListServicosAtivos(ctx context.Context, arg ListServicosAtivosParams) ([]ListServicosAtivosRow, error) {
	rows, err := q.db.Query(ctx, listServicosAtivos, arg.TenantID, arg.UnitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServicosAtivosRow{}
	for rows.Next() {
		var i ListServicosAtivosRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoriaID,
			&i.Nome,
			&i.Descricao,
			&i.Preco,
			&i.Duracao,
			&i.Comissao,
			&i.Cor,
			&i.Imagem,
			&i.ProfissionaisIds,
			&i.Observacoes,
			&i.Tags,
			&i.Ativo,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.CategoriaNome,
			&i.CategoriaCor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicosByCategoria = `-- name: ListServicosByCategoria :many
SELECT 
    s.id,
    s.tenant_id,
    s.categoria_id,
    s.nome,
    s.descricao,
    s.preco,
    s.duracao,
    s.comissao,
    s.cor,
    s.imagem,
    s.profissionais_ids,
    s.observacoes,
    s.tags,
    s.ativo,
    s.criado_em,
    s.atualizado_em,
    cs.nome AS categoria_nome,
    cs.cor AS categoria_cor
FROM servicos s
LEFT JOIN categorias_servicos cs ON cs.id = s.categoria_id AND cs.tenant_id = s.tenant_id
WHERE s.tenant_id = $1 
  AND ($3::uuid IS NULL OR s.unit_id = $3)
  AND s.categoria_id = $2
ORDER BY s.nome ASC
`

type ListServicosByCategoriaParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	CategoriaID pgtype.UUID `json:"categoria_id"`
	UnitID      pgtype.UUID `json:"unit_id"`
}

type ListServicosByCategoriaRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	CategoriaID      pgtype.UUID        `json:"categoria_id"`
	Nome             string             `json:"nome"`
	Descricao        *string            `json:"descricao"`
	Preco            decimal.Decimal    `json:"preco"`
	Duracao          int32              `json:"duracao"`
	Comissao         pgtype.Numeric     `json:"comissao"`
	Cor              *string            `json:"cor"`
	Imagem           *string            `json:"imagem"`
	ProfissionaisIds []pgtype.UUID      `json:"profissionais_ids"`
	Observacoes      *string            `json:"observacoes"`
	Tags             []string           `json:"tags"`
	Ativo            *bool              `json:"ativo"`
	CriadoEm         pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm     pgtype.Timestamptz `json:"atualizado_em"`
	CategoriaNome    *string            `json:"categoria_nome"`
	CategoriaCor     *string            `json:"categoria_cor"`
}

func (q *Queries) ListServicosByCategoria(ctx context.Context, arg ListServicosByCategoriaParams) ([]ListServicosByCategoriaRow, error) {
	rows, err := q.db.Query(ctx, listServicosByCategoria, arg.TenantID, arg.CategoriaID, arg.UnitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServicosByCategoriaRow{}
	for rows.Next() {
		var i ListServicosByCategoriaRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoriaID,
			&i.Nome,
			&i.Descricao,
			&i.Preco,
			&i.Duracao,
			&i.Comissao,
			&i.Cor,
			&i.Imagem,
			&i.ProfissionaisIds,
			&i.Observacoes,
			&i.Tags,
			&i.Ativo,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.CategoriaNome,
			&i.CategoriaCor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicosByProfissional = `-- name: ListServicosByProfissional :many
SELECT 
    s.id,
    s.tenant_id,
    s.categoria_id,
    s.nome,
    s.descricao,
    s.preco,
    s.duracao,
    s.comissao,
    s.cor,
    s.imagem,
    s.profissionais_ids,
    s.observacoes,
    s.tags,
    s.ativo,
    s.criado_em,
    s.atualizado_em,
    cs.nome AS categoria_nome,
    cs.cor AS categoria_cor
FROM servicos s
LEFT JOIN categorias_servicos cs ON cs.id = s.categoria_id AND cs.tenant_id = s.tenant_id
WHERE s.tenant_id = $1 
  AND ($2::uuid IS NULL OR s.unit_id = $2)
  AND s.ativo = true
  AND $3::uuid = ANY(s.profissionais_ids)
ORDER BY s.nome ASC
`

type ListServicosByProfissionalParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	UnitID         pgtype.UUID `json:"unit_id"`
	ProfissionalID pgtype.UUID `json:"profissional_id"`
}

type ListServicosByProfissionalRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	CategoriaID      pgtype.UUID        `json:"categoria_id"`
	Nome             string             `json:"nome"`
	Descricao        *string            `json:"descricao"`
	Preco            decimal.Decimal    `json:"preco"`
	Duracao          int32              `json:"duracao"`
	Comissao         pgtype.Numeric     `json:"comissao"`
	Cor              *string            `json:"cor"`
	Imagem           *string            `json:"imagem"`
	ProfissionaisIds []pgtype.UUID      `json:"profissionais_ids"`
	Observacoes      *string            `json:"observacoes"`
	Tags             []string           `json:"tags"`
	Ativo            *bool              `json:"ativo"`
	CriadoEm         pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm     pgtype.Timestamptz `json:"atualizado_em"`
	CategoriaNome    *string            `json:"categoria_nome"`
	CategoriaCor     *string            `json:"categoria_cor"`
}

func (q *Queries) ListServicosByProfissional(ctx context.Context, arg ListServicosByProfissionalParams) ([]ListServicosByProfissionalRow, error) {
	rows, err := q.db.Query(ctx, listServicosByProfissional, arg.TenantID, arg.UnitID, arg.ProfissionalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServicosByProfissionalRow{}
	for rows.Next() {
		var i ListServicosByProfissionalRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoriaID,
			&i.Nome,
			&i.Descricao,
			&i.Preco,
			&i.Duracao,
			&i.Comissao,
			&i.Cor,
			&i.Imagem,
			&i.ProfissionaisIds,
			&i.Observacoes,
			&i.Tags,
			&i.Ativo,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.CategoriaNome,
			&i.CategoriaCor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicosComCategoria = `-- name: ListServicosComCategoria :many
SELECT 
    s.id,
    s.tenant_id,
    s.categoria_id,
    s.nome,
    s.descricao,
    s.preco,
    s.duracao,
    s.comissao,
    s.cor,
    s.imagem,
    s.profissionais_ids,
    s.observacoes,
    s.tags,
    s.ativo,
    s.criado_em,
    s.atualizado_em,
    cs.nome AS categoria_nome,
    cs.cor AS categoria_cor,
    cs.icone AS categoria_icone
FROM servicos s
INNER JOIN categorias_servicos cs ON cs.id = s.categoria_id AND cs.tenant_id = s.tenant_id
WHERE s.tenant_id = $1
ORDER BY cs.nome ASC, s.nome ASC
`

type ListServicosComCategoriaRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	CategoriaID      pgtype.UUID        `json:"categoria_id"`
	Nome             string             `json:"nome"`
	Descricao        *string            `json:"descricao"`
	Preco            decimal.Decimal    `json:"preco"`
	Duracao          int32              `json:"duracao"`
	Comissao         pgtype.Numeric     `json:"comissao"`
	Cor              *string            `json:"cor"`
	Imagem           *string            `json:"imagem"`
	ProfissionaisIds []pgtype.UUID      `json:"profissionais_ids"`
	Observacoes      *string            `json:"observacoes"`
	Tags             []string           `json:"tags"`
	Ativo            *bool              `json:"ativo"`
	CriadoEm         pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm     pgtype.Timestamptz `json:"atualizado_em"`
	CategoriaNome    string             `json:"categoria_nome"`
	CategoriaCor     *string            `json:"categoria_cor"`
	CategoriaIcone   *string            `json:"categoria_icone"`
}

func (q *Queries) ListServicosComCategoria(ctx context.Context, tenantID pgtype.UUID) ([]ListServicosComCategoriaRow, error) {
	rows, err := q.db.Query(ctx, listServicosComCategoria, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServicosComCategoriaRow{}
	for rows.Next() {
		var i ListServicosComCategoriaRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoriaID,
			&i.Nome,
			&i.Descricao,
			&i.Preco,
			&i.Duracao,
			&i.Comissao,
			&i.Cor,
			&i.Imagem,
			&i.ProfissionaisIds,
			&i.Observacoes,
			&i.Tags,
			&i.Ativo,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.CategoriaNome,
			&i.CategoriaCor,
			&i.CategoriaIcone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicosSemCategoria = `-- name: ListServicosSemCategoria :many
SELECT 
    s.id,
    s.tenant_id,
    s.categoria_id,
    s.nome,
    s.descricao,
    s.preco,
    s.duracao,
    s.comissao,
    s.cor,
    s.imagem,
    s.profissionais_ids,
    s.observacoes,
    s.tags,
    s.ativo,
    s.criado_em,
    s.atualizado_em
FROM servicos s
WHERE s.tenant_id = $1 AND s.categoria_id IS NULL
ORDER BY s.nome ASC
`

type ListServicosSemCategoriaRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	CategoriaID      pgtype.UUID        `json:"categoria_id"`
	Nome             string             `json:"nome"`
	Descricao        *string            `json:"descricao"`
	Preco            decimal.Decimal    `json:"preco"`
	Duracao          int32              `json:"duracao"`
	Comissao         pgtype.Numeric     `json:"comissao"`
	Cor              *string            `json:"cor"`
	Imagem           *string            `json:"imagem"`
	ProfissionaisIds []pgtype.UUID      `json:"profissionais_ids"`
	Observacoes      *string            `json:"observacoes"`
	Tags             []string           `json:"tags"`
	Ativo            *bool              `json:"ativo"`
	CriadoEm         pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm     pgtype.Timestamptz `json:"atualizado_em"`
}

func (q *Queries) ListServicosSemCategoria(ctx context.Context, tenantID pgtype.UUID) ([]ListServicosSemCategoriaRow, error) {
	rows, err := q.db.Query(ctx, listServicosSemCategoria, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServicosSemCategoriaRow{}
	for rows.Next() {
		var i ListServicosSemCategoriaRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoriaID,
			&i.Nome,
			&i.Descricao,
			&i.Preco,
			&i.Duracao,
			&i.Comissao,
			&i.Cor,
			&i.Imagem,
			&i.ProfissionaisIds,
			&i.Observacoes,
			&i.Tags,
			&i.Ativo,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchServicos = `-- name: SearchServicos :many
SELECT 
    s.id,
    s.tenant_id,
    s.categoria_id,
    s.nome,
    s.descricao,
    s.preco,
    s.duracao,
    s.comissao,
    s.cor,
    s.imagem,
    s.profissionais_ids,
    s.observacoes,
    s.tags,
    s.ativo,
    s.criado_em,
    s.atualizado_em,
    cs.nome AS categoria_nome,
    cs.cor AS categoria_cor
FROM servicos s
LEFT JOIN categorias_servicos cs ON cs.id = s.categoria_id AND cs.tenant_id = s.tenant_id
WHERE s.tenant_id = $1 
  AND ($2::uuid IS NULL OR s.unit_id = $2)
  AND (
      LOWER(s.nome) LIKE LOWER('%' || $3::text || '%')
      OR LOWER(s.descricao) LIKE LOWER('%' || $3::text || '%')
      OR $3::text = ANY(s.tags)
  )
ORDER BY s.nome ASC
`

type SearchServicosParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	UnitID     pgtype.UUID `json:"unit_id"`
	SearchTerm string      `json:"search_term"`
}

type SearchServicosRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	CategoriaID      pgtype.UUID        `json:"categoria_id"`
	Nome             string             `json:"nome"`
	Descricao        *string            `json:"descricao"`
	Preco            decimal.Decimal    `json:"preco"`
	Duracao          int32              `json:"duracao"`
	Comissao         pgtype.Numeric     `json:"comissao"`
	Cor              *string            `json:"cor"`
	Imagem           *string            `json:"imagem"`
	ProfissionaisIds []pgtype.UUID      `json:"profissionais_ids"`
	Observacoes      *string            `json:"observacoes"`
	Tags             []string           `json:"tags"`
	Ativo            *bool              `json:"ativo"`
	CriadoEm         pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm     pgtype.Timestamptz `json:"atualizado_em"`
	CategoriaNome    *string            `json:"categoria_nome"`
	CategoriaCor     *string            `json:"categoria_cor"`
}

func (q *Queries) SearchServicos(ctx context.Context, arg SearchServicosParams) ([]SearchServicosRow, error) {
	rows, err := q.db.Query(ctx, searchServicos, arg.TenantID, arg.UnitID, arg.SearchTerm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchServicosRow{}
	for rows.Next() {
		var i SearchServicosRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoriaID,
			&i.Nome,
			&i.Descricao,
			&i.Preco,
			&i.Duracao,
			&i.Comissao,
			&i.Cor,
			&i.Imagem,
			&i.ProfissionaisIds,
			&i.Observacoes,
			&i.Tags,
			&i.Ativo,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.CategoriaNome,
			&i.CategoriaCor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleServicoStatus = `-- name: ToggleServicoStatus :one
UPDATE servicos SET
    ativo = $3,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, unit_id, categoria_id, nome, descricao, preco, duracao, comissao, cor, imagem, profissionais_ids, observacoes, tags, ativo, criado_em, atualizado_em
`

type ToggleServicoStatusParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Ativo    *bool       `json:"ativo"`
}

func (q *Queries) ToggleServicoStatus(ctx context.Context, arg ToggleServicoStatusParams) (Servico, error) {
	row := q.db.QueryRow(ctx, toggleServicoStatus, arg.ID, arg.TenantID, arg.Ativo)
	var i Servico
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.CategoriaID,
		&i.Nome,
		&i.Descricao,
		&i.Preco,
		&i.Duracao,
		&i.Comissao,
		&i.Cor,
		&i.Imagem,
		&i.ProfissionaisIds,
		&i.Observacoes,
		&i.Tags,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const updateServico = `-- name: UpdateServico :one

UPDATE servicos SET
    categoria_id = $3,
    nome = $4,
    descricao = $5,
    preco = $6,
    duracao = $7,
    comissao = $8,
    cor = $9,
    imagem = $10,
    profissionais_ids = $11,
    observacoes = $12,
    tags = $13,
    unit_id = COALESCE($14, unit_id),
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, unit_id, categoria_id, nome, descricao, preco, duracao, comissao, cor, imagem, profissionais_ids, observacoes, tags, ativo, criado_em, atualizado_em
`

type UpdateServicoParams struct {
	ID               pgtype.UUID     `json:"id"`
	TenantID         pgtype.UUID     `json:"tenant_id"`
	CategoriaID      pgtype.UUID     `json:"categoria_id"`
	Nome             string          `json:"nome"`
	Descricao        *string         `json:"descricao"`
	Preco            decimal.Decimal `json:"preco"`
	Duracao          int32           `json:"duracao"`
	Comissao         pgtype.Numeric  `json:"comissao"`
	Cor              *string         `json:"cor"`
	Imagem           *string         `json:"imagem"`
	ProfissionaisIds []pgtype.UUID   `json:"profissionais_ids"`
	Observacoes      *string         `json:"observacoes"`
	Tags             []string        `json:"tags"`
	UnitID           pgtype.UUID     `json:"unit_id"`
}

// ============================================================================
// UPDATE
// ============================================================================
func (q *Queries) UpdateServico(ctx context.Context, arg UpdateServicoParams) (Servico, error) {
	row := q.db.QueryRow(ctx, updateServico,
		arg.ID,
		arg.TenantID,
		arg.CategoriaID,
		arg.Nome,
		arg.Descricao,
		arg.Preco,
		arg.Duracao,
		arg.Comissao,
		arg.Cor,
		arg.Imagem,
		arg.ProfissionaisIds,
		arg.Observacoes,
		arg.Tags,
		arg.UnitID,
	)
	var i Servico
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.CategoriaID,
		&i.Nome,
		&i.Descricao,
		&i.Preco,
		&i.Duracao,
		&i.Comissao,
		&i.Cor,
		&i.Imagem,
		&i.ProfissionaisIds,
		&i.Observacoes,
		&i.Tags,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const updateServicoCategoria = `-- name: UpdateServicoCategoria :one
UPDATE servicos SET
    categoria_id = $3,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, unit_id, categoria_id, nome, descricao, preco, duracao, comissao, cor, imagem, profissionais_ids, observacoes, tags, ativo, criado_em, atualizado_em
`

type UpdateServicoCategoriaParams struct {
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	CategoriaID pgtype.UUID `json:"categoria_id"`
}

func (q *Queries) UpdateServicoCategoria(ctx context.Context, arg UpdateServicoCategoriaParams) (Servico, error) {
	row := q.db.QueryRow(ctx, updateServicoCategoria, arg.ID, arg.TenantID, arg.CategoriaID)
	var i Servico
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.CategoriaID,
		&i.Nome,
		&i.Descricao,
		&i.Preco,
		&i.Duracao,
		&i.Comissao,
		&i.Cor,
		&i.Imagem,
		&i.ProfissionaisIds,
		&i.Observacoes,
		&i.Tags,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const updateServicoProfissionais = `-- name: UpdateServicoProfissionais :one
UPDATE servicos SET
    profissionais_ids = $3,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, unit_id, categoria_id, nome, descricao, preco, duracao, comissao, cor, imagem, profissionais_ids, observacoes, tags, ativo, criado_em, atualizado_em
`

type UpdateServicoProfissionaisParams struct {
	ID               pgtype.UUID   `json:"id"`
	TenantID         pgtype.UUID   `json:"tenant_id"`
	ProfissionaisIds []pgtype.UUID `json:"profissionais_ids"`
}

func (q *Queries) UpdateServicoProfissionais(ctx context.Context, arg UpdateServicoProfissionaisParams) (Servico, error) {
	row := q.db.QueryRow(ctx, updateServicoProfissionais, arg.ID, arg.TenantID, arg.ProfissionaisIds)
	var i Servico
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.CategoriaID,
		&i.Nome,
		&i.Descricao,
		&i.Preco,
		&i.Duracao,
		&i.Comissao,
		&i.Cor,
		&i.Imagem,
		&i.ProfissionaisIds,
		&i.Observacoes,
		&i.Tags,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}
