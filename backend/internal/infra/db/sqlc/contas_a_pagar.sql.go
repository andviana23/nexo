// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: contas_a_pagar.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const countContasPagarByStatus = `-- name: CountContasPagarByStatus :one
SELECT COUNT(*) FROM contas_a_pagar
WHERE tenant_id = $1 AND status = $2
`

type CountContasPagarByStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   *string     `json:"status"`
}

func (q *Queries) CountContasPagarByStatus(ctx context.Context, arg CountContasPagarByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countContasPagarByStatus, arg.TenantID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countContasPagarByTenant = `-- name: CountContasPagarByTenant :one
SELECT COUNT(*) FROM contas_a_pagar
WHERE tenant_id = $1
`

func (q *Queries) CountContasPagarByTenant(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countContasPagarByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createContaPagar = `-- name: CreateContaPagar :one
INSERT INTO contas_a_pagar (
    tenant_id,
    unit_id,
    descricao,
    categoria_id,
    fornecedor,
    valor,
    tipo,
    recorrente,
    periodicidade,
    data_vencimento,
    data_pagamento,
    status,
    comprovante_url,
    pix_code,
    observacoes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
) RETURNING id, tenant_id, descricao, categoria_id, fornecedor, valor, tipo, recorrente, periodicidade, data_vencimento, data_pagamento, status, unit_id, comprovante_url, pix_code, observacoes, criado_em, atualizado_em
`

type CreateContaPagarParams struct {
	TenantID       pgtype.UUID     `json:"tenant_id"`
	UnitID         pgtype.UUID     `json:"unit_id"`
	Descricao      string          `json:"descricao"`
	CategoriaID    pgtype.UUID     `json:"categoria_id"`
	Fornecedor     *string         `json:"fornecedor"`
	Valor          decimal.Decimal `json:"valor"`
	Tipo           *string         `json:"tipo"`
	Recorrente     *bool           `json:"recorrente"`
	Periodicidade  *string         `json:"periodicidade"`
	DataVencimento pgtype.Date     `json:"data_vencimento"`
	DataPagamento  pgtype.Date     `json:"data_pagamento"`
	Status         *string         `json:"status"`
	ComprovanteUrl *string         `json:"comprovante_url"`
	PixCode        *string         `json:"pix_code"`
	Observacoes    *string         `json:"observacoes"`
}

func (q *Queries) CreateContaPagar(ctx context.Context, arg CreateContaPagarParams) (ContasAPagar, error) {
	row := q.db.QueryRow(ctx, createContaPagar,
		arg.TenantID,
		arg.UnitID,
		arg.Descricao,
		arg.CategoriaID,
		arg.Fornecedor,
		arg.Valor,
		arg.Tipo,
		arg.Recorrente,
		arg.Periodicidade,
		arg.DataVencimento,
		arg.DataPagamento,
		arg.Status,
		arg.ComprovanteUrl,
		arg.PixCode,
		arg.Observacoes,
	)
	var i ContasAPagar
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Descricao,
		&i.CategoriaID,
		&i.Fornecedor,
		&i.Valor,
		&i.Tipo,
		&i.Recorrente,
		&i.Periodicidade,
		&i.DataVencimento,
		&i.DataPagamento,
		&i.Status,
		&i.UnitID,
		&i.ComprovanteUrl,
		&i.PixCode,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const deleteContaPagar = `-- name: DeleteContaPagar :exec
DELETE FROM contas_a_pagar
WHERE id = $1 AND tenant_id = $2
`

type DeleteContaPagarParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteContaPagar(ctx context.Context, arg DeleteContaPagarParams) error {
	_, err := q.db.Exec(ctx, deleteContaPagar, arg.ID, arg.TenantID)
	return err
}

const getContaPagarByID = `-- name: GetContaPagarByID :one
SELECT id, tenant_id, descricao, categoria_id, fornecedor, valor, tipo, recorrente, periodicidade, data_vencimento, data_pagamento, status, unit_id, comprovante_url, pix_code, observacoes, criado_em, atualizado_em FROM contas_a_pagar
WHERE id = $1 AND tenant_id = $2
`

type GetContaPagarByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetContaPagarByID(ctx context.Context, arg GetContaPagarByIDParams) (ContasAPagar, error) {
	row := q.db.QueryRow(ctx, getContaPagarByID, arg.ID, arg.TenantID)
	var i ContasAPagar
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Descricao,
		&i.CategoriaID,
		&i.Fornecedor,
		&i.Valor,
		&i.Tipo,
		&i.Recorrente,
		&i.Periodicidade,
		&i.DataVencimento,
		&i.DataPagamento,
		&i.Status,
		&i.UnitID,
		&i.ComprovanteUrl,
		&i.PixCode,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const listContasPagarByPeriod = `-- name: ListContasPagarByPeriod :many
SELECT id, tenant_id, descricao, categoria_id, fornecedor, valor, tipo, recorrente, periodicidade, data_vencimento, data_pagamento, status, unit_id, comprovante_url, pix_code, observacoes, criado_em, atualizado_em FROM contas_a_pagar
WHERE tenant_id = $1
  AND ($4::uuid IS NULL OR unit_id = $4)
  AND data_vencimento >= $2
  AND data_vencimento <= $3
ORDER BY data_vencimento ASC
`

type ListContasPagarByPeriodParams struct {
	TenantID         pgtype.UUID `json:"tenant_id"`
	DataVencimento   pgtype.Date `json:"data_vencimento"`
	DataVencimento_2 pgtype.Date `json:"data_vencimento_2"`
	UnitID           pgtype.UUID `json:"unit_id"`
}

func (q *Queries) ListContasPagarByPeriod(ctx context.Context, arg ListContasPagarByPeriodParams) ([]ContasAPagar, error) {
	rows, err := q.db.Query(ctx, listContasPagarByPeriod,
		arg.TenantID,
		arg.DataVencimento,
		arg.DataVencimento_2,
		arg.UnitID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContasAPagar{}
	for rows.Next() {
		var i ContasAPagar
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Descricao,
			&i.CategoriaID,
			&i.Fornecedor,
			&i.Valor,
			&i.Tipo,
			&i.Recorrente,
			&i.Periodicidade,
			&i.DataVencimento,
			&i.DataPagamento,
			&i.Status,
			&i.UnitID,
			&i.ComprovanteUrl,
			&i.PixCode,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContasPagarByStatus = `-- name: ListContasPagarByStatus :many
SELECT id, tenant_id, descricao, categoria_id, fornecedor, valor, tipo, recorrente, periodicidade, data_vencimento, data_pagamento, status, unit_id, comprovante_url, pix_code, observacoes, criado_em, atualizado_em FROM contas_a_pagar
WHERE tenant_id = $1
  AND ($5::uuid IS NULL OR unit_id = $5)
  AND status = $2
ORDER BY data_vencimento ASC
LIMIT $3 OFFSET $4
`

type ListContasPagarByStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   *string     `json:"status"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	UnitID   pgtype.UUID `json:"unit_id"`
}

func (q *Queries) ListContasPagarByStatus(ctx context.Context, arg ListContasPagarByStatusParams) ([]ContasAPagar, error) {
	rows, err := q.db.Query(ctx, listContasPagarByStatus,
		arg.TenantID,
		arg.Status,
		arg.Limit,
		arg.Offset,
		arg.UnitID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContasAPagar{}
	for rows.Next() {
		var i ContasAPagar
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Descricao,
			&i.CategoriaID,
			&i.Fornecedor,
			&i.Valor,
			&i.Tipo,
			&i.Recorrente,
			&i.Periodicidade,
			&i.DataVencimento,
			&i.DataPagamento,
			&i.Status,
			&i.UnitID,
			&i.ComprovanteUrl,
			&i.PixCode,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContasPagarByTenant = `-- name: ListContasPagarByTenant :many
SELECT id, tenant_id, descricao, categoria_id, fornecedor, valor, tipo, recorrente, periodicidade, data_vencimento, data_pagamento, status, unit_id, comprovante_url, pix_code, observacoes, criado_em, atualizado_em FROM contas_a_pagar
WHERE tenant_id = $1
  AND ($4::uuid IS NULL OR unit_id = $4)
ORDER BY data_vencimento DESC
LIMIT $2 OFFSET $3
`

type ListContasPagarByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	UnitID   pgtype.UUID `json:"unit_id"`
}

func (q *Queries) ListContasPagarByTenant(ctx context.Context, arg ListContasPagarByTenantParams) ([]ContasAPagar, error) {
	rows, err := q.db.Query(ctx, listContasPagarByTenant,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
		arg.UnitID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContasAPagar{}
	for rows.Next() {
		var i ContasAPagar
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Descricao,
			&i.CategoriaID,
			&i.Fornecedor,
			&i.Valor,
			&i.Tipo,
			&i.Recorrente,
			&i.Periodicidade,
			&i.DataVencimento,
			&i.DataPagamento,
			&i.Status,
			&i.UnitID,
			&i.ComprovanteUrl,
			&i.PixCode,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContasPagarFiltered = `-- name: ListContasPagarFiltered :many
SELECT id, tenant_id, descricao, categoria_id, fornecedor, valor, tipo, recorrente, periodicidade, data_vencimento, data_pagamento, status, unit_id, comprovante_url, pix_code, observacoes, criado_em, atualizado_em FROM contas_a_pagar
WHERE tenant_id = $1
  AND ($4::uuid IS NULL OR unit_id = $4)
  AND ($5::text IS NULL OR status = $5)
  AND ($6::text IS NULL OR tipo = $6)
  AND ($7::uuid IS NULL OR categoria_id = $7)
  AND ($8::date IS NULL OR data_vencimento >= $8)
  AND ($9::date IS NULL OR data_vencimento <= $9)
ORDER BY data_vencimento DESC
LIMIT $2 OFFSET $3
`

type ListContasPagarFilteredParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	UnitID      pgtype.UUID `json:"unit_id"`
	Status      *string     `json:"status"`
	Tipo        *string     `json:"tipo"`
	CategoriaID pgtype.UUID `json:"categoria_id"`
	DataInicio  pgtype.Date `json:"data_inicio"`
	DataFim     pgtype.Date `json:"data_fim"`
}

func (q *Queries) ListContasPagarFiltered(ctx context.Context, arg ListContasPagarFilteredParams) ([]ContasAPagar, error) {
	rows, err := q.db.Query(ctx, listContasPagarFiltered,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
		arg.UnitID,
		arg.Status,
		arg.Tipo,
		arg.CategoriaID,
		arg.DataInicio,
		arg.DataFim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContasAPagar{}
	for rows.Next() {
		var i ContasAPagar
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Descricao,
			&i.CategoriaID,
			&i.Fornecedor,
			&i.Valor,
			&i.Tipo,
			&i.Recorrente,
			&i.Periodicidade,
			&i.DataVencimento,
			&i.DataPagamento,
			&i.Status,
			&i.UnitID,
			&i.ComprovanteUrl,
			&i.PixCode,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContasPagarRecorrentes = `-- name: ListContasPagarRecorrentes :many
SELECT id, tenant_id, descricao, categoria_id, fornecedor, valor, tipo, recorrente, periodicidade, data_vencimento, data_pagamento, status, unit_id, comprovante_url, pix_code, observacoes, criado_em, atualizado_em FROM contas_a_pagar
WHERE tenant_id = $1 AND recorrente = true
ORDER BY data_vencimento DESC
`

func (q *Queries) ListContasPagarRecorrentes(ctx context.Context, tenantID pgtype.UUID) ([]ContasAPagar, error) {
	rows, err := q.db.Query(ctx, listContasPagarRecorrentes, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContasAPagar{}
	for rows.Next() {
		var i ContasAPagar
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Descricao,
			&i.CategoriaID,
			&i.Fornecedor,
			&i.Valor,
			&i.Tipo,
			&i.Recorrente,
			&i.Periodicidade,
			&i.DataVencimento,
			&i.DataPagamento,
			&i.Status,
			&i.UnitID,
			&i.ComprovanteUrl,
			&i.PixCode,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContasPagarVencidas = `-- name: ListContasPagarVencidas :many
SELECT id, tenant_id, descricao, categoria_id, fornecedor, valor, tipo, recorrente, periodicidade, data_vencimento, data_pagamento, status, unit_id, comprovante_url, pix_code, observacoes, criado_em, atualizado_em FROM contas_a_pagar
WHERE tenant_id = $1
  AND ($3::uuid IS NULL OR unit_id = $3)
  AND status IN ('ABERTO', 'ATRASADO')
  AND data_vencimento < $2
ORDER BY data_vencimento ASC
`

type ListContasPagarVencidasParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	DataVencimento pgtype.Date `json:"data_vencimento"`
	UnitID         pgtype.UUID `json:"unit_id"`
}

func (q *Queries) ListContasPagarVencidas(ctx context.Context, arg ListContasPagarVencidasParams) ([]ContasAPagar, error) {
	rows, err := q.db.Query(ctx, listContasPagarVencidas, arg.TenantID, arg.DataVencimento, arg.UnitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContasAPagar{}
	for rows.Next() {
		var i ContasAPagar
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Descricao,
			&i.CategoriaID,
			&i.Fornecedor,
			&i.Valor,
			&i.Tipo,
			&i.Recorrente,
			&i.Periodicidade,
			&i.DataVencimento,
			&i.DataPagamento,
			&i.Status,
			&i.UnitID,
			&i.ComprovanteUrl,
			&i.PixCode,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const marcarContaPagarComoAtrasada = `-- name: MarcarContaPagarComoAtrasada :exec
UPDATE contas_a_pagar
SET
    status = 'ATRASADO',
    atualizado_em = NOW()
WHERE tenant_id = $1
  AND status = 'ABERTO'
  AND data_vencimento < $2
`

type MarcarContaPagarComoAtrasadaParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	DataVencimento pgtype.Date `json:"data_vencimento"`
}

func (q *Queries) MarcarContaPagarComoAtrasada(ctx context.Context, arg MarcarContaPagarComoAtrasadaParams) error {
	_, err := q.db.Exec(ctx, marcarContaPagarComoAtrasada, arg.TenantID, arg.DataVencimento)
	return err
}

const marcarContaPagarComoPaga = `-- name: MarcarContaPagarComoPaga :one
UPDATE contas_a_pagar
SET
    status = 'PAGO',
    data_pagamento = $3,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, descricao, categoria_id, fornecedor, valor, tipo, recorrente, periodicidade, data_vencimento, data_pagamento, status, unit_id, comprovante_url, pix_code, observacoes, criado_em, atualizado_em
`

type MarcarContaPagarComoPagaParams struct {
	ID            pgtype.UUID `json:"id"`
	TenantID      pgtype.UUID `json:"tenant_id"`
	DataPagamento pgtype.Date `json:"data_pagamento"`
}

func (q *Queries) MarcarContaPagarComoPaga(ctx context.Context, arg MarcarContaPagarComoPagaParams) (ContasAPagar, error) {
	row := q.db.QueryRow(ctx, marcarContaPagarComoPaga, arg.ID, arg.TenantID, arg.DataPagamento)
	var i ContasAPagar
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Descricao,
		&i.CategoriaID,
		&i.Fornecedor,
		&i.Valor,
		&i.Tipo,
		&i.Recorrente,
		&i.Periodicidade,
		&i.DataVencimento,
		&i.DataPagamento,
		&i.Status,
		&i.UnitID,
		&i.ComprovanteUrl,
		&i.PixCode,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const sumContasPagarByPeriod = `-- name: SumContasPagarByPeriod :one
SELECT
    COALESCE(SUM(valor), 0) as total_a_pagar
FROM contas_a_pagar
WHERE tenant_id = $1
  AND ($4::uuid IS NULL OR unit_id = $4)
  AND data_vencimento >= $2
  AND data_vencimento <= $3
  AND status != 'CANCELADO'
`

type SumContasPagarByPeriodParams struct {
	TenantID         pgtype.UUID `json:"tenant_id"`
	DataVencimento   pgtype.Date `json:"data_vencimento"`
	DataVencimento_2 pgtype.Date `json:"data_vencimento_2"`
	UnitID           pgtype.UUID `json:"unit_id"`
}

func (q *Queries) SumContasPagarByPeriod(ctx context.Context, arg SumContasPagarByPeriodParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, sumContasPagarByPeriod,
		arg.TenantID,
		arg.DataVencimento,
		arg.DataVencimento_2,
		arg.UnitID,
	)
	var total_a_pagar interface{}
	err := row.Scan(&total_a_pagar)
	return total_a_pagar, err
}

const sumContasPagasByPeriod = `-- name: SumContasPagasByPeriod :one
SELECT
    COALESCE(SUM(valor), 0) as total_pago
FROM contas_a_pagar
WHERE tenant_id = $1
  AND ($4::uuid IS NULL OR unit_id = $4)
  AND data_pagamento >= $2
  AND data_pagamento <= $3
  AND status = 'PAGO'
`

type SumContasPagasByPeriodParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	DataPagamento   pgtype.Date `json:"data_pagamento"`
	DataPagamento_2 pgtype.Date `json:"data_pagamento_2"`
	UnitID          pgtype.UUID `json:"unit_id"`
}

func (q *Queries) SumContasPagasByPeriod(ctx context.Context, arg SumContasPagasByPeriodParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, sumContasPagasByPeriod,
		arg.TenantID,
		arg.DataPagamento,
		arg.DataPagamento_2,
		arg.UnitID,
	)
	var total_pago interface{}
	err := row.Scan(&total_pago)
	return total_pago, err
}

const updateContaPagar = `-- name: UpdateContaPagar :one
UPDATE contas_a_pagar
SET
    descricao = $3,
    categoria_id = $4,
    fornecedor = $5,
    valor = $6,
    tipo = $7,
    recorrente = $8,
    periodicidade = $9,
    data_vencimento = $10,
    data_pagamento = $11,
    status = $12,
    comprovante_url = $13,
    pix_code = $14,
    observacoes = $15,
    unit_id = COALESCE($16, unit_id),
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, descricao, categoria_id, fornecedor, valor, tipo, recorrente, periodicidade, data_vencimento, data_pagamento, status, unit_id, comprovante_url, pix_code, observacoes, criado_em, atualizado_em
`

type UpdateContaPagarParams struct {
	ID             pgtype.UUID     `json:"id"`
	TenantID       pgtype.UUID     `json:"tenant_id"`
	Descricao      string          `json:"descricao"`
	CategoriaID    pgtype.UUID     `json:"categoria_id"`
	Fornecedor     *string         `json:"fornecedor"`
	Valor          decimal.Decimal `json:"valor"`
	Tipo           *string         `json:"tipo"`
	Recorrente     *bool           `json:"recorrente"`
	Periodicidade  *string         `json:"periodicidade"`
	DataVencimento pgtype.Date     `json:"data_vencimento"`
	DataPagamento  pgtype.Date     `json:"data_pagamento"`
	Status         *string         `json:"status"`
	ComprovanteUrl *string         `json:"comprovante_url"`
	PixCode        *string         `json:"pix_code"`
	Observacoes    *string         `json:"observacoes"`
	UnitID         pgtype.UUID     `json:"unit_id"`
}

func (q *Queries) UpdateContaPagar(ctx context.Context, arg UpdateContaPagarParams) (ContasAPagar, error) {
	row := q.db.QueryRow(ctx, updateContaPagar,
		arg.ID,
		arg.TenantID,
		arg.Descricao,
		arg.CategoriaID,
		arg.Fornecedor,
		arg.Valor,
		arg.Tipo,
		arg.Recorrente,
		arg.Periodicidade,
		arg.DataVencimento,
		arg.DataPagamento,
		arg.Status,
		arg.ComprovanteUrl,
		arg.PixCode,
		arg.Observacoes,
		arg.UnitID,
	)
	var i ContasAPagar
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Descricao,
		&i.CategoriaID,
		&i.Fornecedor,
		&i.Valor,
		&i.Tipo,
		&i.Recorrente,
		&i.Periodicidade,
		&i.DataVencimento,
		&i.DataPagamento,
		&i.Status,
		&i.UnitID,
		&i.ComprovanteUrl,
		&i.PixCode,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}
