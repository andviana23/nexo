// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: barber_turn.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addBarberToTurnList = `-- name: AddBarberToTurnList :one


INSERT INTO barbers_turn_list (
    id,
    tenant_id,
    professional_id,
    current_points,
    last_turn_at,
    is_active,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, 0, NULL, true, NOW(), NOW()
) RETURNING id, tenant_id, professional_id, current_points, last_turn_at, is_active, created_at, updated_at
`

type AddBarberToTurnListParams struct {
	ID             pgtype.UUID `json:"id"`
	TenantID       pgtype.UUID `json:"tenant_id"`
	ProfessionalID pgtype.UUID `json:"professional_id"`
}

// ============================================================================
// BARBER TURN QUERIES (sqlc)
// Módulo Lista da Vez — NEXO v1.0
// Conforme FLUXO_LISTA_DA_VEZ.md
// ============================================================================
// ============================================================================
// CREATE / ADD
// ============================================================================
// Adiciona um barbeiro à lista da vez
func (q *Queries) AddBarberToTurnList(ctx context.Context, arg AddBarberToTurnListParams) (BarbersTurnList, error) {
	row := q.db.QueryRow(ctx, addBarberToTurnList, arg.ID, arg.TenantID, arg.ProfessionalID)
	var i BarbersTurnList
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CurrentPoints,
		&i.LastTurnAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const checkProfessionalInTurnList = `-- name: CheckProfessionalInTurnList :one

SELECT EXISTS (
    SELECT 1 FROM barbers_turn_list
    WHERE tenant_id = $1 AND professional_id = $2
) as exists
`

type CheckProfessionalInTurnListParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ProfessionalID pgtype.UUID `json:"professional_id"`
}

// ============================================================================
// VALIDAÇÕES
// ============================================================================
// Verifica se profissional já está na lista
func (q *Queries) CheckProfessionalInTurnList(ctx context.Context, arg CheckProfessionalInTurnListParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkProfessionalInTurnList, arg.TenantID, arg.ProfessionalID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkProfessionalIsBarber = `-- name: CheckProfessionalIsBarber :one
SELECT EXISTS (
    SELECT 1 FROM profissionais
    WHERE id = $1 
      AND tenant_id = $2 
      AND tipo = 'BARBEIRO'
      AND status = 'ATIVO'
) as exists
`

type CheckProfessionalIsBarberParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Verifica se profissional é do tipo BARBEIRO
func (q *Queries) CheckProfessionalIsBarber(ctx context.Context, arg CheckProfessionalIsBarberParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkProfessionalIsBarber, arg.ID, arg.TenantID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countBarbersTurnList = `-- name: CountBarbersTurnList :one
SELECT 
    COUNT(*) FILTER (WHERE is_active = true) as total_ativos,
    COUNT(*) FILTER (WHERE is_active = false) as total_pausados,
    COUNT(*) as total_geral,
    COALESCE(SUM(current_points), 0) as total_pontos
FROM barbers_turn_list
WHERE tenant_id = $1
`

type CountBarbersTurnListRow struct {
	TotalAtivos   int64       `json:"total_ativos"`
	TotalPausados int64       `json:"total_pausados"`
	TotalGeral    int64       `json:"total_geral"`
	TotalPontos   interface{} `json:"total_pontos"`
}

func (q *Queries) CountBarbersTurnList(ctx context.Context, tenantID pgtype.UUID) (CountBarbersTurnListRow, error) {
	row := q.db.QueryRow(ctx, countBarbersTurnList, tenantID)
	var i CountBarbersTurnListRow
	err := row.Scan(
		&i.TotalAtivos,
		&i.TotalPausados,
		&i.TotalGeral,
		&i.TotalPontos,
	)
	return i, err
}

const getAvailableBarbersForTurnList = `-- name: GetAvailableBarbersForTurnList :many
SELECT 
    p.id,
    p.nome,
    p.foto,
    p.status
FROM profissionais p
WHERE p.tenant_id = $1
  AND p.tipo = 'BARBEIRO'
  AND p.status = 'ATIVO'
  AND NOT EXISTS (
    SELECT 1 FROM barbers_turn_list btl
    WHERE btl.professional_id = p.id AND btl.tenant_id = p.tenant_id
  )
ORDER BY p.nome ASC
`

type GetAvailableBarbersForTurnListRow struct {
	ID     pgtype.UUID `json:"id"`
	Nome   string      `json:"nome"`
	Foto   *string     `json:"foto"`
	Status *string     `json:"status"`
}

// Lista barbeiros ativos que ainda não estão na lista da vez
func (q *Queries) GetAvailableBarbersForTurnList(ctx context.Context, tenantID pgtype.UUID) ([]GetAvailableBarbersForTurnListRow, error) {
	rows, err := q.db.Query(ctx, getAvailableBarbersForTurnList, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableBarbersForTurnListRow{}
	for rows.Next() {
		var i GetAvailableBarbersForTurnListRow
		if err := rows.Scan(
			&i.ID,
			&i.Nome,
			&i.Foto,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBarberTurnByID = `-- name: GetBarberTurnByID :one

SELECT 
    btl.id, btl.tenant_id, btl.professional_id, btl.current_points, btl.last_turn_at, btl.is_active, btl.created_at, btl.updated_at,
    p.nome as professional_name,
    p.tipo as professional_type,
    p.status as professional_status
FROM barbers_turn_list btl
JOIN profissionais p ON p.id = btl.professional_id
WHERE btl.id = $1 AND btl.tenant_id = $2
`

type GetBarberTurnByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetBarberTurnByIDRow struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	ProfessionalID     pgtype.UUID        `json:"professional_id"`
	CurrentPoints      int32              `json:"current_points"`
	LastTurnAt         pgtype.Timestamptz `json:"last_turn_at"`
	IsActive           bool               `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ProfessionalName   string             `json:"professional_name"`
	ProfessionalType   string             `json:"professional_type"`
	ProfessionalStatus *string            `json:"professional_status"`
}

// ============================================================================
// READ / LIST
// ============================================================================
func (q *Queries) GetBarberTurnByID(ctx context.Context, arg GetBarberTurnByIDParams) (GetBarberTurnByIDRow, error) {
	row := q.db.QueryRow(ctx, getBarberTurnByID, arg.ID, arg.TenantID)
	var i GetBarberTurnByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CurrentPoints,
		&i.LastTurnAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProfessionalName,
		&i.ProfessionalType,
		&i.ProfessionalStatus,
	)
	return i, err
}

const getBarberTurnByProfessionalID = `-- name: GetBarberTurnByProfessionalID :one
SELECT 
    btl.id, btl.tenant_id, btl.professional_id, btl.current_points, btl.last_turn_at, btl.is_active, btl.created_at, btl.updated_at,
    p.nome as professional_name,
    p.tipo as professional_type,
    p.status as professional_status
FROM barbers_turn_list btl
JOIN profissionais p ON p.id = btl.professional_id
WHERE btl.professional_id = $1 AND btl.tenant_id = $2
`

type GetBarberTurnByProfessionalIDParams struct {
	ProfessionalID pgtype.UUID `json:"professional_id"`
	TenantID       pgtype.UUID `json:"tenant_id"`
}

type GetBarberTurnByProfessionalIDRow struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	ProfessionalID     pgtype.UUID        `json:"professional_id"`
	CurrentPoints      int32              `json:"current_points"`
	LastTurnAt         pgtype.Timestamptz `json:"last_turn_at"`
	IsActive           bool               `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ProfessionalName   string             `json:"professional_name"`
	ProfessionalType   string             `json:"professional_type"`
	ProfessionalStatus *string            `json:"professional_status"`
}

func (q *Queries) GetBarberTurnByProfessionalID(ctx context.Context, arg GetBarberTurnByProfessionalIDParams) (GetBarberTurnByProfessionalIDRow, error) {
	row := q.db.QueryRow(ctx, getBarberTurnByProfessionalID, arg.ProfessionalID, arg.TenantID)
	var i GetBarberTurnByProfessionalIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CurrentPoints,
		&i.LastTurnAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProfessionalName,
		&i.ProfessionalType,
		&i.ProfessionalStatus,
	)
	return i, err
}

const getDailyReportByDate = `-- name: GetDailyReportByDate :many
WITH daily_points AS (
    SELECT 
        btl.id, btl.tenant_id, btl.professional_id, btl.current_points, btl.last_turn_at, btl.is_active, btl.created_at, btl.updated_at,
        p.nome as professional_name,
        -- Assumindo que last_turn_at é atualizado a cada atendimento do dia
        CASE 
            WHEN DATE(btl.last_turn_at) = $2::date THEN 1
            ELSE 0
        END as atendeu_hoje
    FROM barbers_turn_list btl
    JOIN profissionais p ON p.id = btl.professional_id
    WHERE btl.tenant_id = $1
)
SELECT 
    professional_id,
    professional_name,
    current_points,
    atendeu_hoje,
    last_turn_at
FROM daily_points
WHERE atendeu_hoje = 1 OR current_points > 0
ORDER BY current_points DESC, last_turn_at DESC
`

type GetDailyReportByDateParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Column2  pgtype.Date `json:"column_2"`
}

type GetDailyReportByDateRow struct {
	ProfessionalID   pgtype.UUID        `json:"professional_id"`
	ProfessionalName string             `json:"professional_name"`
	CurrentPoints    int32              `json:"current_points"`
	AtendeuHoje      int32              `json:"atendeu_hoje"`
	LastTurnAt       pgtype.Timestamptz `json:"last_turn_at"`
}

// Relatório diário: pontos ganhos em uma data específica
// Nota: Esta query usa CTE para calcular incrementos comparando com o dia anterior
func (q *Queries) GetDailyReportByDate(ctx context.Context, arg GetDailyReportByDateParams) ([]GetDailyReportByDateRow, error) {
	rows, err := q.db.Query(ctx, getDailyReportByDate, arg.TenantID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDailyReportByDateRow{}
	for rows.Next() {
		var i GetDailyReportByDateRow
		if err := rows.Scan(
			&i.ProfessionalID,
			&i.ProfessionalName,
			&i.CurrentPoints,
			&i.AtendeuHoje,
			&i.LastTurnAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextBarber = `-- name: GetNextBarber :one
SELECT 
    btl.id, btl.tenant_id, btl.professional_id, btl.current_points, btl.last_turn_at, btl.is_active, btl.created_at, btl.updated_at,
    p.nome as professional_name,
    p.tipo as professional_type,
    p.status as professional_status,
    p.foto as professional_photo
FROM barbers_turn_list btl
JOIN profissionais p ON p.id = btl.professional_id
WHERE btl.tenant_id = $1
  AND btl.is_active = true
  AND p.status = 'ATIVO'
ORDER BY 
    btl.current_points ASC,
    btl.last_turn_at ASC NULLS FIRST,
    btl.created_at ASC
LIMIT 1
`

type GetNextBarberRow struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	ProfessionalID     pgtype.UUID        `json:"professional_id"`
	CurrentPoints      int32              `json:"current_points"`
	LastTurnAt         pgtype.Timestamptz `json:"last_turn_at"`
	IsActive           bool               `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ProfessionalName   string             `json:"professional_name"`
	ProfessionalType   string             `json:"professional_type"`
	ProfessionalStatus *string            `json:"professional_status"`
	ProfessionalPhoto  *string            `json:"professional_photo"`
}

// Retorna o próximo barbeiro da vez (topo da fila ativa)
func (q *Queries) GetNextBarber(ctx context.Context, tenantID pgtype.UUID) (GetNextBarberRow, error) {
	row := q.db.QueryRow(ctx, getNextBarber, tenantID)
	var i GetNextBarberRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CurrentPoints,
		&i.LastTurnAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProfessionalName,
		&i.ProfessionalType,
		&i.ProfessionalStatus,
		&i.ProfessionalPhoto,
	)
	return i, err
}

const getTodayStats = `-- name: GetTodayStats :one

SELECT 
    COUNT(*) FILTER (WHERE DATE(last_turn_at) = CURRENT_DATE) as atendimentos_hoje,
    SUM(current_points) as total_pontos_mes,
    COUNT(*) FILTER (WHERE is_active = true) as barbeiros_ativos,
    MAX(last_turn_at) as ultimo_atendimento
FROM barbers_turn_list
WHERE tenant_id = $1
`

type GetTodayStatsRow struct {
	AtendimentosHoje  int64       `json:"atendimentos_hoje"`
	TotalPontosMes    int64       `json:"total_pontos_mes"`
	BarbeirosAtivos   int64       `json:"barbeiros_ativos"`
	UltimoAtendimento interface{} `json:"ultimo_atendimento"`
}

// ============================================================================
// ESTATÍSTICAS DIÁRIAS
// ============================================================================
// Estatísticas do dia atual
func (q *Queries) GetTodayStats(ctx context.Context, tenantID pgtype.UUID) (GetTodayStatsRow, error) {
	row := q.db.QueryRow(ctx, getTodayStats, tenantID)
	var i GetTodayStatsRow
	err := row.Scan(
		&i.AtendimentosHoje,
		&i.TotalPontosMes,
		&i.BarbeirosAtivos,
		&i.UltimoAtendimento,
	)
	return i, err
}

const getTurnHistoryByMonth = `-- name: GetTurnHistoryByMonth :many
SELECT 
    bth.id, bth.tenant_id, bth.professional_id, bth.month_year, bth.total_turns, bth.final_points, bth.created_at,
    p.nome as professional_name
FROM barber_turn_history bth
JOIN profissionais p ON p.id = bth.professional_id
WHERE bth.tenant_id = $1
  AND bth.month_year = $2
ORDER BY bth.final_points DESC
`

type GetTurnHistoryByMonthParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	MonthYear string      `json:"month_year"`
}

type GetTurnHistoryByMonthRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	ProfessionalID   pgtype.UUID        `json:"professional_id"`
	MonthYear        string             `json:"month_year"`
	TotalTurns       int32              `json:"total_turns"`
	FinalPoints      int32              `json:"final_points"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	ProfessionalName string             `json:"professional_name"`
}

// Busca histórico de um mês específico
func (q *Queries) GetTurnHistoryByMonth(ctx context.Context, arg GetTurnHistoryByMonthParams) ([]GetTurnHistoryByMonthRow, error) {
	rows, err := q.db.Query(ctx, getTurnHistoryByMonth, arg.TenantID, arg.MonthYear)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTurnHistoryByMonthRow{}
	for rows.Next() {
		var i GetTurnHistoryByMonthRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProfessionalID,
			&i.MonthYear,
			&i.TotalTurns,
			&i.FinalPoints,
			&i.CreatedAt,
			&i.ProfessionalName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTurnHistorySummary = `-- name: GetTurnHistorySummary :many
SELECT 
    month_year,
    COUNT(*) as total_barbeiros,
    SUM(total_turns) as total_atendimentos,
    AVG(total_turns) as media_atendimentos
FROM barber_turn_history
WHERE tenant_id = $1
GROUP BY month_year
ORDER BY month_year DESC
LIMIT 12
`

type GetTurnHistorySummaryRow struct {
	MonthYear         string  `json:"month_year"`
	TotalBarbeiros    int64   `json:"total_barbeiros"`
	TotalAtendimentos int64   `json:"total_atendimentos"`
	MediaAtendimentos float64 `json:"media_atendimentos"`
}

// Resumo dos últimos 12 meses
func (q *Queries) GetTurnHistorySummary(ctx context.Context, tenantID pgtype.UUID) ([]GetTurnHistorySummaryRow, error) {
	rows, err := q.db.Query(ctx, getTurnHistorySummary, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTurnHistorySummaryRow{}
	for rows.Next() {
		var i GetTurnHistorySummaryRow
		if err := rows.Scan(
			&i.MonthYear,
			&i.TotalBarbeiros,
			&i.TotalAtendimentos,
			&i.MediaAtendimentos,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveBarbersTurnList = `-- name: ListActiveBarbersTurnList :many
SELECT 
    btl.id, btl.tenant_id, btl.professional_id, btl.current_points, btl.last_turn_at, btl.is_active, btl.created_at, btl.updated_at,
    p.nome as professional_name,
    p.tipo as professional_type,
    p.status as professional_status,
    p.foto as professional_photo,
    ROW_NUMBER() OVER (
        ORDER BY 
            btl.current_points ASC,
            btl.last_turn_at ASC NULLS FIRST,
            btl.created_at ASC
    ) as position
FROM barbers_turn_list btl
JOIN profissionais p ON p.id = btl.professional_id
WHERE btl.tenant_id = $1
  AND btl.is_active = true
  AND p.status = 'ATIVO'
ORDER BY 
    btl.current_points ASC,
    btl.last_turn_at ASC NULLS FIRST,
    btl.created_at ASC
`

type ListActiveBarbersTurnListRow struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	ProfessionalID     pgtype.UUID        `json:"professional_id"`
	CurrentPoints      int32              `json:"current_points"`
	LastTurnAt         pgtype.Timestamptz `json:"last_turn_at"`
	IsActive           bool               `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ProfessionalName   string             `json:"professional_name"`
	ProfessionalType   string             `json:"professional_type"`
	ProfessionalStatus *string            `json:"professional_status"`
	ProfessionalPhoto  *string            `json:"professional_photo"`
	Position           int64              `json:"position"`
}

// Lista apenas barbeiros ativos na fila (is_active = true)
func (q *Queries) ListActiveBarbersTurnList(ctx context.Context, tenantID pgtype.UUID) ([]ListActiveBarbersTurnListRow, error) {
	rows, err := q.db.Query(ctx, listActiveBarbersTurnList, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveBarbersTurnListRow{}
	for rows.Next() {
		var i ListActiveBarbersTurnListRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProfessionalID,
			&i.CurrentPoints,
			&i.LastTurnAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProfessionalName,
			&i.ProfessionalType,
			&i.ProfessionalStatus,
			&i.ProfessionalPhoto,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBarbersTurnList = `-- name: ListBarbersTurnList :many
SELECT 
    btl.id, btl.tenant_id, btl.professional_id, btl.current_points, btl.last_turn_at, btl.is_active, btl.created_at, btl.updated_at,
    p.nome as professional_name,
    p.tipo as professional_type,
    p.status as professional_status,
    p.foto as professional_photo,
    ROW_NUMBER() OVER (
        ORDER BY 
            btl.current_points ASC,
            btl.last_turn_at ASC NULLS FIRST,
            btl.created_at ASC
    ) as position
FROM barbers_turn_list btl
JOIN profissionais p ON p.id = btl.professional_id
WHERE btl.tenant_id = $1
  AND ($2::bool IS NULL OR btl.is_active = $2)
ORDER BY 
    btl.current_points ASC,
    btl.last_turn_at ASC NULLS FIRST,
    btl.created_at ASC
`

type ListBarbersTurnListParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	IsActive *bool       `json:"is_active"`
}

type ListBarbersTurnListRow struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	ProfessionalID     pgtype.UUID        `json:"professional_id"`
	CurrentPoints      int32              `json:"current_points"`
	LastTurnAt         pgtype.Timestamptz `json:"last_turn_at"`
	IsActive           bool               `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ProfessionalName   string             `json:"professional_name"`
	ProfessionalType   string             `json:"professional_type"`
	ProfessionalStatus *string            `json:"professional_status"`
	ProfessionalPhoto  *string            `json:"professional_photo"`
	Position           int64              `json:"position"`
}

// Lista todos os barbeiros na fila ordenados por pontuação
// Menor pontuação = topo da fila
// Critério de desempate: last_turn_at mais antigo ou nulo (nunca atendeu) → topo
// Segundo desempate: ordem de criação (created_at ASC)
func (q *Queries) ListBarbersTurnList(ctx context.Context, arg ListBarbersTurnListParams) ([]ListBarbersTurnListRow, error) {
	rows, err := q.db.Query(ctx, listBarbersTurnList, arg.TenantID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBarbersTurnListRow{}
	for rows.Next() {
		var i ListBarbersTurnListRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProfessionalID,
			&i.CurrentPoints,
			&i.LastTurnAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProfessionalName,
			&i.ProfessionalType,
			&i.ProfessionalStatus,
			&i.ProfessionalPhoto,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTurnHistory = `-- name: ListTurnHistory :many

SELECT 
    bth.id, bth.tenant_id, bth.professional_id, bth.month_year, bth.total_turns, bth.final_points, bth.created_at,
    p.nome as professional_name
FROM barber_turn_history bth
JOIN profissionais p ON p.id = bth.professional_id
WHERE bth.tenant_id = $1
  AND ($2::varchar(7) IS NULL OR bth.month_year = $2)
ORDER BY bth.month_year DESC, bth.final_points DESC
`

type ListTurnHistoryParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Column2  string      `json:"column_2"`
}

type ListTurnHistoryRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	ProfessionalID   pgtype.UUID        `json:"professional_id"`
	MonthYear        string             `json:"month_year"`
	TotalTurns       int32              `json:"total_turns"`
	FinalPoints      int32              `json:"final_points"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	ProfessionalName string             `json:"professional_name"`
}

// ============================================================================
// HISTÓRICO
// ============================================================================
// Lista histórico mensal de atendimentos
func (q *Queries) ListTurnHistory(ctx context.Context, arg ListTurnHistoryParams) ([]ListTurnHistoryRow, error) {
	rows, err := q.db.Query(ctx, listTurnHistory, arg.TenantID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTurnHistoryRow{}
	for rows.Next() {
		var i ListTurnHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProfessionalID,
			&i.MonthYear,
			&i.TotalTurns,
			&i.FinalPoints,
			&i.CreatedAt,
			&i.ProfessionalName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordTurn = `-- name: RecordTurn :one

UPDATE barbers_turn_list
SET
    current_points = current_points + 1,
    last_turn_at = NOW(),
    updated_at = NOW()
WHERE professional_id = $1 AND tenant_id = $2
RETURNING id, tenant_id, professional_id, current_points, last_turn_at, is_active, created_at, updated_at
`

type RecordTurnParams struct {
	ProfessionalID pgtype.UUID `json:"professional_id"`
	TenantID       pgtype.UUID `json:"tenant_id"`
}

// ============================================================================
// UPDATE
// ============================================================================
// Registra um atendimento: incrementa pontos (+1) e atualiza timestamp
func (q *Queries) RecordTurn(ctx context.Context, arg RecordTurnParams) (BarbersTurnList, error) {
	row := q.db.QueryRow(ctx, recordTurn, arg.ProfessionalID, arg.TenantID)
	var i BarbersTurnList
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CurrentPoints,
		&i.LastTurnAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const removeBarberFromTurnList = `-- name: RemoveBarberFromTurnList :exec

DELETE FROM barbers_turn_list
WHERE professional_id = $1 AND tenant_id = $2
`

type RemoveBarberFromTurnListParams struct {
	ProfessionalID pgtype.UUID `json:"professional_id"`
	TenantID       pgtype.UUID `json:"tenant_id"`
}

// ============================================================================
// DELETE
// ============================================================================
// Remove barbeiro da lista da vez
func (q *Queries) RemoveBarberFromTurnList(ctx context.Context, arg RemoveBarberFromTurnListParams) error {
	_, err := q.db.Exec(ctx, removeBarberFromTurnList, arg.ProfessionalID, arg.TenantID)
	return err
}

const resetAllTurnPoints = `-- name: ResetAllTurnPoints :exec

UPDATE barbers_turn_list
SET
    current_points = 0,
    last_turn_at = NULL,
    updated_at = NOW()
WHERE tenant_id = $1
`

// ============================================================================
// RESET MENSAL
// ============================================================================
// Zera todos os pontos e last_turn_at para reset mensal
func (q *Queries) ResetAllTurnPoints(ctx context.Context, tenantID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, resetAllTurnPoints, tenantID)
	return err
}

const saveTurnHistoryBeforeReset = `-- name: SaveTurnHistoryBeforeReset :exec
INSERT INTO barber_turn_history (
    id,
    tenant_id,
    professional_id,
    month_year,
    total_turns,
    final_points,
    created_at
)
SELECT
    gen_random_uuid(),
    btl.tenant_id,
    btl.professional_id,
    $2::varchar(7), -- month_year no formato 'YYYY-MM'
    btl.current_points,
    btl.current_points,
    NOW()
FROM barbers_turn_list btl
WHERE btl.tenant_id = $1
  AND btl.is_active = true
ON CONFLICT (professional_id, tenant_id, month_year) 
DO UPDATE SET
    total_turns = EXCLUDED.total_turns,
    final_points = EXCLUDED.final_points
`

type SaveTurnHistoryBeforeResetParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Column2  string      `json:"column_2"`
}

// Salva snapshot no histórico antes do reset
func (q *Queries) SaveTurnHistoryBeforeReset(ctx context.Context, arg SaveTurnHistoryBeforeResetParams) error {
	_, err := q.db.Exec(ctx, saveTurnHistoryBeforeReset, arg.TenantID, arg.Column2)
	return err
}

const setBarberTurnActive = `-- name: SetBarberTurnActive :one
UPDATE barbers_turn_list
SET
    is_active = true,
    updated_at = NOW()
WHERE professional_id = $1 AND tenant_id = $2
RETURNING id, tenant_id, professional_id, current_points, last_turn_at, is_active, created_at, updated_at
`

type SetBarberTurnActiveParams struct {
	ProfessionalID pgtype.UUID `json:"professional_id"`
	TenantID       pgtype.UUID `json:"tenant_id"`
}

// Ativa um barbeiro na fila
func (q *Queries) SetBarberTurnActive(ctx context.Context, arg SetBarberTurnActiveParams) (BarbersTurnList, error) {
	row := q.db.QueryRow(ctx, setBarberTurnActive, arg.ProfessionalID, arg.TenantID)
	var i BarbersTurnList
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CurrentPoints,
		&i.LastTurnAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setBarberTurnInactive = `-- name: SetBarberTurnInactive :one
UPDATE barbers_turn_list
SET
    is_active = false,
    updated_at = NOW()
WHERE professional_id = $1 AND tenant_id = $2
RETURNING id, tenant_id, professional_id, current_points, last_turn_at, is_active, created_at, updated_at
`

type SetBarberTurnInactiveParams struct {
	ProfessionalID pgtype.UUID `json:"professional_id"`
	TenantID       pgtype.UUID `json:"tenant_id"`
}

// Pausa um barbeiro na fila
func (q *Queries) SetBarberTurnInactive(ctx context.Context, arg SetBarberTurnInactiveParams) (BarbersTurnList, error) {
	row := q.db.QueryRow(ctx, setBarberTurnInactive, arg.ProfessionalID, arg.TenantID)
	var i BarbersTurnList
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CurrentPoints,
		&i.LastTurnAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const toggleBarberTurnStatus = `-- name: ToggleBarberTurnStatus :one
UPDATE barbers_turn_list
SET
    is_active = NOT is_active,
    updated_at = NOW()
WHERE professional_id = $1 AND tenant_id = $2
RETURNING id, tenant_id, professional_id, current_points, last_turn_at, is_active, created_at, updated_at
`

type ToggleBarberTurnStatusParams struct {
	ProfessionalID pgtype.UUID `json:"professional_id"`
	TenantID       pgtype.UUID `json:"tenant_id"`
}

// Alterna status ativo/inativo de um barbeiro na fila
func (q *Queries) ToggleBarberTurnStatus(ctx context.Context, arg ToggleBarberTurnStatusParams) (BarbersTurnList, error) {
	row := q.db.QueryRow(ctx, toggleBarberTurnStatus, arg.ProfessionalID, arg.TenantID)
	var i BarbersTurnList
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CurrentPoints,
		&i.LastTurnAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
