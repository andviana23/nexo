// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: customers.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkCPFExists = `-- name: CheckCPFExists :one
SELECT EXISTS (
    SELECT 1 FROM clientes
    WHERE tenant_id = $1 
      AND cpf = $2 
      AND ativo = true
      AND ($3::uuid IS NULL OR id != $3)
) as exists
`

type CheckCPFExistsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Cpf      *string     `json:"cpf"`
	Column3  pgtype.UUID `json:"column_3"`
}

func (q *Queries) CheckCPFExists(ctx context.Context, arg CheckCPFExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkCPFExists, arg.TenantID, arg.Cpf, arg.Column3)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkEmailExists = `-- name: CheckEmailExists :one
SELECT EXISTS (
    SELECT 1 FROM clientes
    WHERE tenant_id = $1 
      AND email = $2 
      AND ativo = true
      AND ($3::uuid IS NULL OR id != $3)
) as exists
`

type CheckEmailExistsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Email    *string     `json:"email"`
	Column3  pgtype.UUID `json:"column_3"`
}

func (q *Queries) CheckEmailExists(ctx context.Context, arg CheckEmailExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkEmailExists, arg.TenantID, arg.Email, arg.Column3)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkPhoneExists = `-- name: CheckPhoneExists :one

SELECT EXISTS (
    SELECT 1 FROM clientes
    WHERE tenant_id = $1 
      AND telefone = $2 
      AND ativo = true
      AND ($3::uuid IS NULL OR id != $3)
) as exists
`

type CheckPhoneExistsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Telefone string      `json:"telefone"`
	Column3  pgtype.UUID `json:"column_3"`
}

// ============================================================================
// VALIDAÇÕES
// ============================================================================
func (q *Queries) CheckPhoneExists(ctx context.Context, arg CheckPhoneExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkPhoneExists, arg.TenantID, arg.Telefone, arg.Column3)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countCustomers = `-- name: CountCustomers :one
SELECT COUNT(*) FROM clientes
WHERE tenant_id = $1
  AND ($2::bool IS NULL OR ativo = $2)
  AND (
    $3::text IS NULL 
    OR nome ILIKE '%' || $3 || '%'
    OR telefone ILIKE '%' || $3 || '%'
    OR cpf ILIKE '%' || $3 || '%'
    OR email ILIKE '%' || $3 || '%'
  )
  AND ($4::text[] IS NULL OR tags && $4)
`

type CountCustomersParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Ativo    *bool       `json:"ativo"`
	Search   *string     `json:"search"`
	Tags     []string    `json:"tags"`
}

func (q *Queries) CountCustomers(ctx context.Context, arg CountCustomersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countCustomers,
		arg.TenantID,
		arg.Ativo,
		arg.Search,
		arg.Tags,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCustomer = `-- name: CreateCustomer :one


INSERT INTO clientes (
    id,
    tenant_id,
    nome,
    telefone,
    email,
    cpf,
    data_nascimento,
    genero,
    endereco_logradouro,
    endereco_numero,
    endereco_complemento,
    endereco_bairro,
    endereco_cidade,
    endereco_estado,
    endereco_cep,
    observacoes,
    tags,
    ativo,
    criado_em,
    atualizado_em
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, true, NOW(), NOW()
) RETURNING id, tenant_id, nome, email, telefone, cpf, data_nascimento, genero, endereco_logradouro, endereco_numero, endereco_complemento, endereco_bairro, endereco_cidade, endereco_estado, endereco_cep, observacoes, tags, ativo, criado_em, atualizado_em
`

type CreateCustomerParams struct {
	ID                  pgtype.UUID `json:"id"`
	TenantID            pgtype.UUID `json:"tenant_id"`
	Nome                string      `json:"nome"`
	Telefone            string      `json:"telefone"`
	Email               *string     `json:"email"`
	Cpf                 *string     `json:"cpf"`
	DataNascimento      pgtype.Date `json:"data_nascimento"`
	Genero              *string     `json:"genero"`
	EnderecoLogradouro  *string     `json:"endereco_logradouro"`
	EnderecoNumero      *string     `json:"endereco_numero"`
	EnderecoComplemento *string     `json:"endereco_complemento"`
	EnderecoBairro      *string     `json:"endereco_bairro"`
	EnderecoCidade      *string     `json:"endereco_cidade"`
	EnderecoEstado      *string     `json:"endereco_estado"`
	EnderecoCep         *string     `json:"endereco_cep"`
	Observacoes         *string     `json:"observacoes"`
	Tags                []string    `json:"tags"`
}

// ============================================================================
// CUSTOMERS QUERIES (sqlc)
// Módulo de Cadastro de Clientes — NEXO v1.0
// Conforme FLUXO_CADASTROS_CLIENTE.md
// ============================================================================
// ============================================================================
// CREATE
// ============================================================================
func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Cliente, error) {
	row := q.db.QueryRow(ctx, createCustomer,
		arg.ID,
		arg.TenantID,
		arg.Nome,
		arg.Telefone,
		arg.Email,
		arg.Cpf,
		arg.DataNascimento,
		arg.Genero,
		arg.EnderecoLogradouro,
		arg.EnderecoNumero,
		arg.EnderecoComplemento,
		arg.EnderecoBairro,
		arg.EnderecoCidade,
		arg.EnderecoEstado,
		arg.EnderecoCep,
		arg.Observacoes,
		arg.Tags,
	)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Email,
		&i.Telefone,
		&i.Cpf,
		&i.DataNascimento,
		&i.Genero,
		&i.EnderecoLogradouro,
		&i.EnderecoNumero,
		&i.EnderecoComplemento,
		&i.EnderecoBairro,
		&i.EnderecoCidade,
		&i.EnderecoEstado,
		&i.EnderecoCep,
		&i.Observacoes,
		&i.Tags,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getCustomerByCPF = `-- name: GetCustomerByCPF :one
SELECT id, tenant_id, nome, email, telefone, cpf, data_nascimento, genero, endereco_logradouro, endereco_numero, endereco_complemento, endereco_bairro, endereco_cidade, endereco_estado, endereco_cep, observacoes, tags, ativo, criado_em, atualizado_em FROM clientes
WHERE tenant_id = $1 AND cpf = $2 AND ativo = true
`

type GetCustomerByCPFParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Cpf      *string     `json:"cpf"`
}

func (q *Queries) GetCustomerByCPF(ctx context.Context, arg GetCustomerByCPFParams) (Cliente, error) {
	row := q.db.QueryRow(ctx, getCustomerByCPF, arg.TenantID, arg.Cpf)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Email,
		&i.Telefone,
		&i.Cpf,
		&i.DataNascimento,
		&i.Genero,
		&i.EnderecoLogradouro,
		&i.EnderecoNumero,
		&i.EnderecoComplemento,
		&i.EnderecoBairro,
		&i.EnderecoCidade,
		&i.EnderecoEstado,
		&i.EnderecoCep,
		&i.Observacoes,
		&i.Tags,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getCustomerByID = `-- name: GetCustomerByID :one

SELECT id, tenant_id, nome, email, telefone, cpf, data_nascimento, genero, endereco_logradouro, endereco_numero, endereco_complemento, endereco_bairro, endereco_cidade, endereco_estado, endereco_cep, observacoes, tags, ativo, criado_em, atualizado_em FROM clientes
WHERE id = $1 AND tenant_id = $2
`

type GetCustomerByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// ============================================================================
// READ
// ============================================================================
func (q *Queries) GetCustomerByID(ctx context.Context, arg GetCustomerByIDParams) (Cliente, error) {
	row := q.db.QueryRow(ctx, getCustomerByID, arg.ID, arg.TenantID)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Email,
		&i.Telefone,
		&i.Cpf,
		&i.DataNascimento,
		&i.Genero,
		&i.EnderecoLogradouro,
		&i.EnderecoNumero,
		&i.EnderecoComplemento,
		&i.EnderecoBairro,
		&i.EnderecoCidade,
		&i.EnderecoEstado,
		&i.EnderecoCep,
		&i.Observacoes,
		&i.Tags,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getCustomerByPhone = `-- name: GetCustomerByPhone :one
SELECT id, tenant_id, nome, email, telefone, cpf, data_nascimento, genero, endereco_logradouro, endereco_numero, endereco_complemento, endereco_bairro, endereco_cidade, endereco_estado, endereco_cep, observacoes, tags, ativo, criado_em, atualizado_em FROM clientes
WHERE tenant_id = $1 AND telefone = $2 AND ativo = true
`

type GetCustomerByPhoneParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Telefone string      `json:"telefone"`
}

func (q *Queries) GetCustomerByPhone(ctx context.Context, arg GetCustomerByPhoneParams) (Cliente, error) {
	row := q.db.QueryRow(ctx, getCustomerByPhone, arg.TenantID, arg.Telefone)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Email,
		&i.Telefone,
		&i.Cpf,
		&i.DataNascimento,
		&i.Genero,
		&i.EnderecoLogradouro,
		&i.EnderecoNumero,
		&i.EnderecoComplemento,
		&i.EnderecoBairro,
		&i.EnderecoCidade,
		&i.EnderecoEstado,
		&i.EnderecoCep,
		&i.Observacoes,
		&i.Tags,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getCustomerDataForExport = `-- name: GetCustomerDataForExport :one

SELECT 
    c.id, c.tenant_id, c.nome, c.email, c.telefone, c.cpf, c.data_nascimento, c.genero, c.endereco_logradouro, c.endereco_numero, c.endereco_complemento, c.endereco_bairro, c.endereco_cidade, c.endereco_estado, c.endereco_cep, c.observacoes, c.tags, c.ativo, c.criado_em, c.atualizado_em,
    COALESCE(
        (SELECT json_agg(json_build_object(
            'data', a.start_time,
            'status', a.status,
            'valor_total', a.total_price,
            'profissional', p.nome
        ) ORDER BY a.start_time DESC)
        FROM appointments a
        JOIN profissionais p ON p.id = a.professional_id
        WHERE a.customer_id = c.id AND a.tenant_id = c.tenant_id
        ), '[]'::json
    ) as historico_atendimentos
FROM clientes c
WHERE c.id = $1 AND c.tenant_id = $2
`

type GetCustomerDataForExportParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetCustomerDataForExportRow struct {
	ID                    pgtype.UUID        `json:"id"`
	TenantID              pgtype.UUID        `json:"tenant_id"`
	Nome                  string             `json:"nome"`
	Email                 *string            `json:"email"`
	Telefone              string             `json:"telefone"`
	Cpf                   *string            `json:"cpf"`
	DataNascimento        pgtype.Date        `json:"data_nascimento"`
	Genero                *string            `json:"genero"`
	EnderecoLogradouro    *string            `json:"endereco_logradouro"`
	EnderecoNumero        *string            `json:"endereco_numero"`
	EnderecoComplemento   *string            `json:"endereco_complemento"`
	EnderecoBairro        *string            `json:"endereco_bairro"`
	EnderecoCidade        *string            `json:"endereco_cidade"`
	EnderecoEstado        *string            `json:"endereco_estado"`
	EnderecoCep           *string            `json:"endereco_cep"`
	Observacoes           *string            `json:"observacoes"`
	Tags                  []string           `json:"tags"`
	Ativo                 *bool              `json:"ativo"`
	CriadoEm              pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm          pgtype.Timestamptz `json:"atualizado_em"`
	HistoricoAtendimentos interface{}        `json:"historico_atendimentos"`
}

// ============================================================================
// EXPORTAÇÃO LGPD
// ============================================================================
func (q *Queries) GetCustomerDataForExport(ctx context.Context, arg GetCustomerDataForExportParams) (GetCustomerDataForExportRow, error) {
	row := q.db.QueryRow(ctx, getCustomerDataForExport, arg.ID, arg.TenantID)
	var i GetCustomerDataForExportRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Email,
		&i.Telefone,
		&i.Cpf,
		&i.DataNascimento,
		&i.Genero,
		&i.EnderecoLogradouro,
		&i.EnderecoNumero,
		&i.EnderecoComplemento,
		&i.EnderecoBairro,
		&i.EnderecoCidade,
		&i.EnderecoEstado,
		&i.EnderecoCep,
		&i.Observacoes,
		&i.Tags,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
		&i.HistoricoAtendimentos,
	)
	return i, err
}

const getCustomerStats = `-- name: GetCustomerStats :one

SELECT 
    COUNT(*) FILTER (WHERE ativo = true) as total_ativos,
    COUNT(*) FILTER (WHERE ativo = false) as total_inativos,
    COUNT(*) FILTER (WHERE criado_em >= NOW() - INTERVAL '30 days') as novos_ultimos_30_dias,
    COUNT(*) as total_geral
FROM clientes
WHERE tenant_id = $1
`

type GetCustomerStatsRow struct {
	TotalAtivos        int64 `json:"total_ativos"`
	TotalInativos      int64 `json:"total_inativos"`
	NovosUltimos30Dias int64 `json:"novos_ultimos_30_dias"`
	TotalGeral         int64 `json:"total_geral"`
}

// ============================================================================
// ESTATÍSTICAS E RELATÓRIOS
// ============================================================================
func (q *Queries) GetCustomerStats(ctx context.Context, tenantID pgtype.UUID) (GetCustomerStatsRow, error) {
	row := q.db.QueryRow(ctx, getCustomerStats, tenantID)
	var i GetCustomerStatsRow
	err := row.Scan(
		&i.TotalAtivos,
		&i.TotalInativos,
		&i.NovosUltimos30Dias,
		&i.TotalGeral,
	)
	return i, err
}

const getCustomerWithHistory = `-- name: GetCustomerWithHistory :one
SELECT 
    c.id, c.tenant_id, c.nome, c.email, c.telefone, c.cpf, c.data_nascimento, c.genero, c.endereco_logradouro, c.endereco_numero, c.endereco_complemento, c.endereco_bairro, c.endereco_cidade, c.endereco_estado, c.endereco_cep, c.observacoes, c.tags, c.ativo, c.criado_em, c.atualizado_em,
    COALESCE(stats.total_atendimentos, 0) as total_atendimentos,
    COALESCE(stats.total_gasto, 0) as total_gasto,
    stats.ultimo_atendimento
FROM clientes c
LEFT JOIN LATERAL (
    SELECT 
        COUNT(*) as total_atendimentos,
        SUM(total_price) as total_gasto,
        MAX(start_time) as ultimo_atendimento
    FROM appointments
    WHERE customer_id = c.id 
      AND tenant_id = c.tenant_id
      AND status = 'DONE'
) stats ON true
WHERE c.id = $1 AND c.tenant_id = $2
`

type GetCustomerWithHistoryParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetCustomerWithHistoryRow struct {
	ID                  pgtype.UUID        `json:"id"`
	TenantID            pgtype.UUID        `json:"tenant_id"`
	Nome                string             `json:"nome"`
	Email               *string            `json:"email"`
	Telefone            string             `json:"telefone"`
	Cpf                 *string            `json:"cpf"`
	DataNascimento      pgtype.Date        `json:"data_nascimento"`
	Genero              *string            `json:"genero"`
	EnderecoLogradouro  *string            `json:"endereco_logradouro"`
	EnderecoNumero      *string            `json:"endereco_numero"`
	EnderecoComplemento *string            `json:"endereco_complemento"`
	EnderecoBairro      *string            `json:"endereco_bairro"`
	EnderecoCidade      *string            `json:"endereco_cidade"`
	EnderecoEstado      *string            `json:"endereco_estado"`
	EnderecoCep         *string            `json:"endereco_cep"`
	Observacoes         *string            `json:"observacoes"`
	Tags                []string           `json:"tags"`
	Ativo               *bool              `json:"ativo"`
	CriadoEm            pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm        pgtype.Timestamptz `json:"atualizado_em"`
	TotalAtendimentos   int64              `json:"total_atendimentos"`
	TotalGasto          int64              `json:"total_gasto"`
	UltimoAtendimento   interface{}        `json:"ultimo_atendimento"`
}

func (q *Queries) GetCustomerWithHistory(ctx context.Context, arg GetCustomerWithHistoryParams) (GetCustomerWithHistoryRow, error) {
	row := q.db.QueryRow(ctx, getCustomerWithHistory, arg.ID, arg.TenantID)
	var i GetCustomerWithHistoryRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Email,
		&i.Telefone,
		&i.Cpf,
		&i.DataNascimento,
		&i.Genero,
		&i.EnderecoLogradouro,
		&i.EnderecoNumero,
		&i.EnderecoComplemento,
		&i.EnderecoBairro,
		&i.EnderecoCidade,
		&i.EnderecoEstado,
		&i.EnderecoCep,
		&i.Observacoes,
		&i.Tags,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
		&i.TotalAtendimentos,
		&i.TotalGasto,
		&i.UltimoAtendimento,
	)
	return i, err
}

const inactivateCustomer = `-- name: InactivateCustomer :exec

UPDATE clientes
SET
    ativo = false,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
`

type InactivateCustomerParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// ============================================================================
// DELETE (Soft Delete)
// ============================================================================
func (q *Queries) InactivateCustomer(ctx context.Context, arg InactivateCustomerParams) error {
	_, err := q.db.Exec(ctx, inactivateCustomer, arg.ID, arg.TenantID)
	return err
}

const listActiveCustomers = `-- name: ListActiveCustomers :many
SELECT id, nome, telefone, email, tags
FROM clientes
WHERE tenant_id = $1 AND ativo = true
ORDER BY nome ASC
LIMIT 100
`

type ListActiveCustomersRow struct {
	ID       pgtype.UUID `json:"id"`
	Nome     string      `json:"nome"`
	Telefone string      `json:"telefone"`
	Email    *string     `json:"email"`
	Tags     []string    `json:"tags"`
}

func (q *Queries) ListActiveCustomers(ctx context.Context, tenantID pgtype.UUID) ([]ListActiveCustomersRow, error) {
	rows, err := q.db.Query(ctx, listActiveCustomers, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveCustomersRow{}
	for rows.Next() {
		var i ListActiveCustomersRow
		if err := rows.Scan(
			&i.ID,
			&i.Nome,
			&i.Telefone,
			&i.Email,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomers = `-- name: ListCustomers :many
SELECT id, tenant_id, nome, email, telefone, cpf, data_nascimento, genero, endereco_logradouro, endereco_numero, endereco_complemento, endereco_bairro, endereco_cidade, endereco_estado, endereco_cep, observacoes, tags, ativo, criado_em, atualizado_em FROM clientes
WHERE tenant_id = $1
  AND ($2::bool IS NULL OR ativo = $2)
  AND (
    $3::text IS NULL 
    OR nome ILIKE '%' || $3 || '%'
    OR telefone ILIKE '%' || $3 || '%'
    OR cpf ILIKE '%' || $3 || '%'
    OR email ILIKE '%' || $3 || '%'
  )
  AND ($4::text[] IS NULL OR tags && $4)
ORDER BY 
  CASE WHEN $5 = 'nome' THEN nome END ASC,
  CASE WHEN $5 = 'criado_em' OR $5 IS NULL THEN criado_em END DESC,
  CASE WHEN $5 = 'atualizado_em' THEN atualizado_em END DESC
LIMIT $7 OFFSET $6
`

type ListCustomersParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	Ativo      *bool       `json:"ativo"`
	Search     *string     `json:"search"`
	Tags       []string    `json:"tags"`
	OrderBy    interface{} `json:"order_by"`
	PageOffset int32       `json:"page_offset"`
	PageSize   int32       `json:"page_size"`
}

func (q *Queries) ListCustomers(ctx context.Context, arg ListCustomersParams) ([]Cliente, error) {
	rows, err := q.db.Query(ctx, listCustomers,
		arg.TenantID,
		arg.Ativo,
		arg.Search,
		arg.Tags,
		arg.OrderBy,
		arg.PageOffset,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Cliente{}
	for rows.Next() {
		var i Cliente
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Nome,
			&i.Email,
			&i.Telefone,
			&i.Cpf,
			&i.DataNascimento,
			&i.Genero,
			&i.EnderecoLogradouro,
			&i.EnderecoNumero,
			&i.EnderecoComplemento,
			&i.EnderecoBairro,
			&i.EnderecoCidade,
			&i.EnderecoEstado,
			&i.EnderecoCep,
			&i.Observacoes,
			&i.Tags,
			&i.Ativo,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomersWithoutAppointments = `-- name: ListCustomersWithoutAppointments :many
SELECT c.id, c.tenant_id, c.nome, c.email, c.telefone, c.cpf, c.data_nascimento, c.genero, c.endereco_logradouro, c.endereco_numero, c.endereco_complemento, c.endereco_bairro, c.endereco_cidade, c.endereco_estado, c.endereco_cep, c.observacoes, c.tags, c.ativo, c.criado_em, c.atualizado_em
FROM clientes c
WHERE c.tenant_id = $1 
  AND c.ativo = true
  AND NOT EXISTS (
    SELECT 1 FROM appointments a
    WHERE a.customer_id = c.id
      AND a.start_time >= NOW() - INTERVAL '90 days'
  )
ORDER BY c.criado_em DESC
LIMIT $2 OFFSET $3
`

type ListCustomersWithoutAppointmentsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListCustomersWithoutAppointments(ctx context.Context, arg ListCustomersWithoutAppointmentsParams) ([]Cliente, error) {
	rows, err := q.db.Query(ctx, listCustomersWithoutAppointments, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Cliente{}
	for rows.Next() {
		var i Cliente
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Nome,
			&i.Email,
			&i.Telefone,
			&i.Cpf,
			&i.DataNascimento,
			&i.Genero,
			&i.EnderecoLogradouro,
			&i.EnderecoNumero,
			&i.EnderecoComplemento,
			&i.EnderecoBairro,
			&i.EnderecoCidade,
			&i.EnderecoEstado,
			&i.EnderecoCep,
			&i.Observacoes,
			&i.Tags,
			&i.Ativo,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reactivateCustomer = `-- name: ReactivateCustomer :exec
UPDATE clientes
SET
    ativo = true,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
`

type ReactivateCustomerParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) ReactivateCustomer(ctx context.Context, arg ReactivateCustomerParams) error {
	_, err := q.db.Exec(ctx, reactivateCustomer, arg.ID, arg.TenantID)
	return err
}

const searchCustomers = `-- name: SearchCustomers :many
SELECT id, nome, telefone, email, tags
FROM clientes
WHERE tenant_id = $1 
  AND ativo = true
  AND (
    nome ILIKE '%' || $2 || '%'
    OR telefone ILIKE '%' || $2 || '%'
    OR email ILIKE '%' || $2 || '%'
  )
ORDER BY nome ASC
LIMIT 20
`

type SearchCustomersParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Column2  *string     `json:"column_2"`
}

type SearchCustomersRow struct {
	ID       pgtype.UUID `json:"id"`
	Nome     string      `json:"nome"`
	Telefone string      `json:"telefone"`
	Email    *string     `json:"email"`
	Tags     []string    `json:"tags"`
}

func (q *Queries) SearchCustomers(ctx context.Context, arg SearchCustomersParams) ([]SearchCustomersRow, error) {
	rows, err := q.db.Query(ctx, searchCustomers, arg.TenantID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchCustomersRow{}
	for rows.Next() {
		var i SearchCustomersRow
		if err := rows.Scan(
			&i.ID,
			&i.Nome,
			&i.Telefone,
			&i.Email,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomer = `-- name: UpdateCustomer :one

UPDATE clientes
SET
    nome = COALESCE($3, nome),
    telefone = COALESCE($4, telefone),
    email = COALESCE($5, email),
    cpf = COALESCE($6, cpf),
    data_nascimento = COALESCE($7, data_nascimento),
    genero = COALESCE($8, genero),
    endereco_logradouro = COALESCE($9, endereco_logradouro),
    endereco_numero = COALESCE($10, endereco_numero),
    endereco_complemento = COALESCE($11, endereco_complemento),
    endereco_bairro = COALESCE($12, endereco_bairro),
    endereco_cidade = COALESCE($13, endereco_cidade),
    endereco_estado = COALESCE($14, endereco_estado),
    endereco_cep = COALESCE($15, endereco_cep),
    observacoes = COALESCE($16, observacoes),
    tags = COALESCE($17, tags),
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, nome, email, telefone, cpf, data_nascimento, genero, endereco_logradouro, endereco_numero, endereco_complemento, endereco_bairro, endereco_cidade, endereco_estado, endereco_cep, observacoes, tags, ativo, criado_em, atualizado_em
`

type UpdateCustomerParams struct {
	ID                  pgtype.UUID `json:"id"`
	TenantID            pgtype.UUID `json:"tenant_id"`
	Nome                string      `json:"nome"`
	Telefone            string      `json:"telefone"`
	Email               *string     `json:"email"`
	Cpf                 *string     `json:"cpf"`
	DataNascimento      pgtype.Date `json:"data_nascimento"`
	Genero              *string     `json:"genero"`
	EnderecoLogradouro  *string     `json:"endereco_logradouro"`
	EnderecoNumero      *string     `json:"endereco_numero"`
	EnderecoComplemento *string     `json:"endereco_complemento"`
	EnderecoBairro      *string     `json:"endereco_bairro"`
	EnderecoCidade      *string     `json:"endereco_cidade"`
	EnderecoEstado      *string     `json:"endereco_estado"`
	EnderecoCep         *string     `json:"endereco_cep"`
	Observacoes         *string     `json:"observacoes"`
	Tags                []string    `json:"tags"`
}

// ============================================================================
// UPDATE
// ============================================================================
func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (Cliente, error) {
	row := q.db.QueryRow(ctx, updateCustomer,
		arg.ID,
		arg.TenantID,
		arg.Nome,
		arg.Telefone,
		arg.Email,
		arg.Cpf,
		arg.DataNascimento,
		arg.Genero,
		arg.EnderecoLogradouro,
		arg.EnderecoNumero,
		arg.EnderecoComplemento,
		arg.EnderecoBairro,
		arg.EnderecoCidade,
		arg.EnderecoEstado,
		arg.EnderecoCep,
		arg.Observacoes,
		arg.Tags,
	)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Email,
		&i.Telefone,
		&i.Cpf,
		&i.DataNascimento,
		&i.Genero,
		&i.EnderecoLogradouro,
		&i.EnderecoNumero,
		&i.EnderecoComplemento,
		&i.EnderecoBairro,
		&i.EnderecoCidade,
		&i.EnderecoEstado,
		&i.EnderecoCep,
		&i.Observacoes,
		&i.Tags,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const updateCustomerTags = `-- name: UpdateCustomerTags :one
UPDATE clientes
SET
    tags = $3,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, nome, email, telefone, cpf, data_nascimento, genero, endereco_logradouro, endereco_numero, endereco_complemento, endereco_bairro, endereco_cidade, endereco_estado, endereco_cep, observacoes, tags, ativo, criado_em, atualizado_em
`

type UpdateCustomerTagsParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Tags     []string    `json:"tags"`
}

func (q *Queries) UpdateCustomerTags(ctx context.Context, arg UpdateCustomerTagsParams) (Cliente, error) {
	row := q.db.QueryRow(ctx, updateCustomerTags, arg.ID, arg.TenantID, arg.Tags)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Email,
		&i.Telefone,
		&i.Cpf,
		&i.DataNascimento,
		&i.Genero,
		&i.EnderecoLogradouro,
		&i.EnderecoNumero,
		&i.EnderecoComplemento,
		&i.EnderecoBairro,
		&i.EnderecoCidade,
		&i.EnderecoEstado,
		&i.EnderecoCep,
		&i.Observacoes,
		&i.Tags,
		&i.Ativo,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}
