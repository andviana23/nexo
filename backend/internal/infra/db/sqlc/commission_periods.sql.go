// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: commission_periods.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const cancelCommissionPeriod = `-- name: CancelCommissionPeriod :one
UPDATE commission_periods
SET
    status = 'CANCELADO',
    notes = $3,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, unit_id, reference_month, professional_id, total_gross, total_commission, total_advances, total_adjustments, total_net, items_count, status, period_start, period_end, closed_at, paid_at, conta_pagar_id, closed_by, paid_by, notes, created_at, updated_at
`

type CancelCommissionPeriodParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Notes    *string     `json:"notes"`
}

func (q *Queries) CancelCommissionPeriod(ctx context.Context, arg CancelCommissionPeriodParams) (CommissionPeriod, error) {
	row := q.db.QueryRow(ctx, cancelCommissionPeriod, arg.ID, arg.TenantID, arg.Notes)
	var i CommissionPeriod
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ReferenceMonth,
		&i.ProfessionalID,
		&i.TotalGross,
		&i.TotalCommission,
		&i.TotalAdvances,
		&i.TotalAdjustments,
		&i.TotalNet,
		&i.ItemsCount,
		&i.Status,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.ClosedAt,
		&i.PaidAt,
		&i.ContaPagarID,
		&i.ClosedBy,
		&i.PaidBy,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const closeCommissionPeriod = `-- name: CloseCommissionPeriod :one
UPDATE commission_periods
SET
    status = 'FECHADO',
    closed_at = NOW(),
    closed_by = $3,
    conta_pagar_id = $4,
    notes = COALESCE($5, notes),
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, unit_id, reference_month, professional_id, total_gross, total_commission, total_advances, total_adjustments, total_net, items_count, status, period_start, period_end, closed_at, paid_at, conta_pagar_id, closed_by, paid_by, notes, created_at, updated_at
`

type CloseCommissionPeriodParams struct {
	ID           pgtype.UUID `json:"id"`
	TenantID     pgtype.UUID `json:"tenant_id"`
	ClosedBy     pgtype.UUID `json:"closed_by"`
	ContaPagarID pgtype.UUID `json:"conta_pagar_id"`
	Notes        *string     `json:"notes"`
}

func (q *Queries) CloseCommissionPeriod(ctx context.Context, arg CloseCommissionPeriodParams) (CommissionPeriod, error) {
	row := q.db.QueryRow(ctx, closeCommissionPeriod,
		arg.ID,
		arg.TenantID,
		arg.ClosedBy,
		arg.ContaPagarID,
		arg.Notes,
	)
	var i CommissionPeriod
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ReferenceMonth,
		&i.ProfessionalID,
		&i.TotalGross,
		&i.TotalCommission,
		&i.TotalAdvances,
		&i.TotalAdjustments,
		&i.TotalNet,
		&i.ItemsCount,
		&i.Status,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.ClosedAt,
		&i.PaidAt,
		&i.ContaPagarID,
		&i.ClosedBy,
		&i.PaidBy,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCommissionPeriod = `-- name: CreateCommissionPeriod :one

INSERT INTO commission_periods (
    tenant_id,
    unit_id,
    reference_month,
    professional_id,
    total_gross,
    total_commission,
    total_advances,
    total_adjustments,
    total_net,
    items_count,
    status,
    period_start,
    period_end,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, tenant_id, unit_id, reference_month, professional_id, total_gross, total_commission, total_advances, total_adjustments, total_net, items_count, status, period_start, period_end, closed_at, paid_at, conta_pagar_id, closed_by, paid_by, notes, created_at, updated_at
`

type CreateCommissionPeriodParams struct {
	TenantID         pgtype.UUID     `json:"tenant_id"`
	UnitID           pgtype.UUID     `json:"unit_id"`
	ReferenceMonth   string          `json:"reference_month"`
	ProfessionalID   pgtype.UUID     `json:"professional_id"`
	TotalGross       decimal.Decimal `json:"total_gross"`
	TotalCommission  decimal.Decimal `json:"total_commission"`
	TotalAdvances    decimal.Decimal `json:"total_advances"`
	TotalAdjustments decimal.Decimal `json:"total_adjustments"`
	TotalNet         decimal.Decimal `json:"total_net"`
	ItemsCount       int32           `json:"items_count"`
	Status           string          `json:"status"`
	PeriodStart      pgtype.Date     `json:"period_start"`
	PeriodEnd        pgtype.Date     `json:"period_end"`
	Notes            *string         `json:"notes"`
}

// ============================================================================
// QUERIES: commission_periods
// Períodos de fechamento de comissões
// ============================================================================
func (q *Queries) CreateCommissionPeriod(ctx context.Context, arg CreateCommissionPeriodParams) (CommissionPeriod, error) {
	row := q.db.QueryRow(ctx, createCommissionPeriod,
		arg.TenantID,
		arg.UnitID,
		arg.ReferenceMonth,
		arg.ProfessionalID,
		arg.TotalGross,
		arg.TotalCommission,
		arg.TotalAdvances,
		arg.TotalAdjustments,
		arg.TotalNet,
		arg.ItemsCount,
		arg.Status,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.Notes,
	)
	var i CommissionPeriod
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ReferenceMonth,
		&i.ProfessionalID,
		&i.TotalGross,
		&i.TotalCommission,
		&i.TotalAdvances,
		&i.TotalAdjustments,
		&i.TotalNet,
		&i.ItemsCount,
		&i.Status,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.ClosedAt,
		&i.PaidAt,
		&i.ContaPagarID,
		&i.ClosedBy,
		&i.PaidBy,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCommissionPeriod = `-- name: DeleteCommissionPeriod :exec
DELETE FROM commission_periods
WHERE id = $1 AND tenant_id = $2 AND status = 'ABERTO'
`

type DeleteCommissionPeriodParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteCommissionPeriod(ctx context.Context, arg DeleteCommissionPeriodParams) error {
	_, err := q.db.Exec(ctx, deleteCommissionPeriod, arg.ID, arg.TenantID)
	return err
}

const getCommissionPeriodByID = `-- name: GetCommissionPeriodByID :one
SELECT id, tenant_id, unit_id, reference_month, professional_id, total_gross, total_commission, total_advances, total_adjustments, total_net, items_count, status, period_start, period_end, closed_at, paid_at, conta_pagar_id, closed_by, paid_by, notes, created_at, updated_at FROM commission_periods
WHERE id = $1 AND tenant_id = $2
`

type GetCommissionPeriodByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetCommissionPeriodByID(ctx context.Context, arg GetCommissionPeriodByIDParams) (CommissionPeriod, error) {
	row := q.db.QueryRow(ctx, getCommissionPeriodByID, arg.ID, arg.TenantID)
	var i CommissionPeriod
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ReferenceMonth,
		&i.ProfessionalID,
		&i.TotalGross,
		&i.TotalCommission,
		&i.TotalAdvances,
		&i.TotalAdjustments,
		&i.TotalNet,
		&i.ItemsCount,
		&i.Status,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.ClosedAt,
		&i.PaidAt,
		&i.ContaPagarID,
		&i.ClosedBy,
		&i.PaidBy,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCommissionPeriodByProfessionalAndMonth = `-- name: GetCommissionPeriodByProfessionalAndMonth :one
SELECT id, tenant_id, unit_id, reference_month, professional_id, total_gross, total_commission, total_advances, total_adjustments, total_net, items_count, status, period_start, period_end, closed_at, paid_at, conta_pagar_id, closed_by, paid_by, notes, created_at, updated_at FROM commission_periods
WHERE tenant_id = $1
  AND professional_id = $2
  AND reference_month = $3
  AND (unit_id = $4 OR ($4 IS NULL AND unit_id IS NULL))
`

type GetCommissionPeriodByProfessionalAndMonthParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ProfessionalID pgtype.UUID `json:"professional_id"`
	ReferenceMonth string      `json:"reference_month"`
	UnitID         pgtype.UUID `json:"unit_id"`
}

func (q *Queries) GetCommissionPeriodByProfessionalAndMonth(ctx context.Context, arg GetCommissionPeriodByProfessionalAndMonthParams) (CommissionPeriod, error) {
	row := q.db.QueryRow(ctx, getCommissionPeriodByProfessionalAndMonth,
		arg.TenantID,
		arg.ProfessionalID,
		arg.ReferenceMonth,
		arg.UnitID,
	)
	var i CommissionPeriod
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ReferenceMonth,
		&i.ProfessionalID,
		&i.TotalGross,
		&i.TotalCommission,
		&i.TotalAdvances,
		&i.TotalAdjustments,
		&i.TotalNet,
		&i.ItemsCount,
		&i.Status,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.ClosedAt,
		&i.PaidAt,
		&i.ContaPagarID,
		&i.ClosedBy,
		&i.PaidBy,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCommissionSummaryByProfessional = `-- name: GetCommissionSummaryByProfessional :many
SELECT
    professional_id,
    p.nome as professional_name,
    COUNT(*) as periods_count,
    SUM(total_gross)::NUMERIC(15,2) as sum_gross,
    SUM(total_commission)::NUMERIC(15,2) as sum_commission,
    SUM(total_advances)::NUMERIC(15,2) as sum_advances,
    SUM(total_net)::NUMERIC(15,2) as sum_net
FROM commission_periods cp
JOIN profissionais p ON cp.professional_id = p.id
WHERE cp.tenant_id = $1
  AND cp.reference_month >= $2
  AND cp.reference_month <= $3
GROUP BY professional_id, p.nome
ORDER BY sum_commission DESC
`

type GetCommissionSummaryByProfessionalParams struct {
	TenantID         pgtype.UUID `json:"tenant_id"`
	ReferenceMonth   string      `json:"reference_month"`
	ReferenceMonth_2 string      `json:"reference_month_2"`
}

type GetCommissionSummaryByProfessionalRow struct {
	ProfessionalID   pgtype.UUID     `json:"professional_id"`
	ProfessionalName string          `json:"professional_name"`
	PeriodsCount     int64           `json:"periods_count"`
	SumGross         decimal.Decimal `json:"sum_gross"`
	SumCommission    decimal.Decimal `json:"sum_commission"`
	SumAdvances      decimal.Decimal `json:"sum_advances"`
	SumNet           decimal.Decimal `json:"sum_net"`
}

func (q *Queries) GetCommissionSummaryByProfessional(ctx context.Context, arg GetCommissionSummaryByProfessionalParams) ([]GetCommissionSummaryByProfessionalRow, error) {
	rows, err := q.db.Query(ctx, getCommissionSummaryByProfessional, arg.TenantID, arg.ReferenceMonth, arg.ReferenceMonth_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCommissionSummaryByProfessionalRow{}
	for rows.Next() {
		var i GetCommissionSummaryByProfessionalRow
		if err := rows.Scan(
			&i.ProfessionalID,
			&i.ProfessionalName,
			&i.PeriodsCount,
			&i.SumGross,
			&i.SumCommission,
			&i.SumAdvances,
			&i.SumNet,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommissionPeriodsByMonth = `-- name: ListCommissionPeriodsByMonth :many
SELECT cp.id, cp.tenant_id, cp.unit_id, cp.reference_month, cp.professional_id, cp.total_gross, cp.total_commission, cp.total_advances, cp.total_adjustments, cp.total_net, cp.items_count, cp.status, cp.period_start, cp.period_end, cp.closed_at, cp.paid_at, cp.conta_pagar_id, cp.closed_by, cp.paid_by, cp.notes, cp.created_at, cp.updated_at,
       p.nome as professional_name,
       u.nome as unit_name
FROM commission_periods cp
LEFT JOIN profissionais p ON cp.professional_id = p.id
LEFT JOIN units u ON cp.unit_id = u.id
WHERE cp.tenant_id = $1
  AND cp.reference_month = $2
ORDER BY p.nome ASC
`

type ListCommissionPeriodsByMonthParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ReferenceMonth string      `json:"reference_month"`
}

type ListCommissionPeriodsByMonthRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	UnitID           pgtype.UUID        `json:"unit_id"`
	ReferenceMonth   string             `json:"reference_month"`
	ProfessionalID   pgtype.UUID        `json:"professional_id"`
	TotalGross       decimal.Decimal    `json:"total_gross"`
	TotalCommission  decimal.Decimal    `json:"total_commission"`
	TotalAdvances    decimal.Decimal    `json:"total_advances"`
	TotalAdjustments decimal.Decimal    `json:"total_adjustments"`
	TotalNet         decimal.Decimal    `json:"total_net"`
	ItemsCount       int32              `json:"items_count"`
	Status           string             `json:"status"`
	PeriodStart      pgtype.Date        `json:"period_start"`
	PeriodEnd        pgtype.Date        `json:"period_end"`
	ClosedAt         pgtype.Timestamptz `json:"closed_at"`
	PaidAt           pgtype.Timestamptz `json:"paid_at"`
	ContaPagarID     pgtype.UUID        `json:"conta_pagar_id"`
	ClosedBy         pgtype.UUID        `json:"closed_by"`
	PaidBy           pgtype.UUID        `json:"paid_by"`
	Notes            *string            `json:"notes"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	ProfessionalName *string            `json:"professional_name"`
	UnitName         *string            `json:"unit_name"`
}

func (q *Queries) ListCommissionPeriodsByMonth(ctx context.Context, arg ListCommissionPeriodsByMonthParams) ([]ListCommissionPeriodsByMonthRow, error) {
	rows, err := q.db.Query(ctx, listCommissionPeriodsByMonth, arg.TenantID, arg.ReferenceMonth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommissionPeriodsByMonthRow{}
	for rows.Next() {
		var i ListCommissionPeriodsByMonthRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ReferenceMonth,
			&i.ProfessionalID,
			&i.TotalGross,
			&i.TotalCommission,
			&i.TotalAdvances,
			&i.TotalAdjustments,
			&i.TotalNet,
			&i.ItemsCount,
			&i.Status,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.ClosedAt,
			&i.PaidAt,
			&i.ContaPagarID,
			&i.ClosedBy,
			&i.PaidBy,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProfessionalName,
			&i.UnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommissionPeriodsByProfessional = `-- name: ListCommissionPeriodsByProfessional :many
SELECT cp.id, cp.tenant_id, cp.unit_id, cp.reference_month, cp.professional_id, cp.total_gross, cp.total_commission, cp.total_advances, cp.total_adjustments, cp.total_net, cp.items_count, cp.status, cp.period_start, cp.period_end, cp.closed_at, cp.paid_at, cp.conta_pagar_id, cp.closed_by, cp.paid_by, cp.notes, cp.created_at, cp.updated_at,
       u.nome as unit_name
FROM commission_periods cp
LEFT JOIN units u ON cp.unit_id = u.id
WHERE cp.tenant_id = $1
  AND cp.professional_id = $2
ORDER BY cp.reference_month DESC
LIMIT $3 OFFSET $4
`

type ListCommissionPeriodsByProfessionalParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ProfessionalID pgtype.UUID `json:"professional_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

type ListCommissionPeriodsByProfessionalRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	UnitID           pgtype.UUID        `json:"unit_id"`
	ReferenceMonth   string             `json:"reference_month"`
	ProfessionalID   pgtype.UUID        `json:"professional_id"`
	TotalGross       decimal.Decimal    `json:"total_gross"`
	TotalCommission  decimal.Decimal    `json:"total_commission"`
	TotalAdvances    decimal.Decimal    `json:"total_advances"`
	TotalAdjustments decimal.Decimal    `json:"total_adjustments"`
	TotalNet         decimal.Decimal    `json:"total_net"`
	ItemsCount       int32              `json:"items_count"`
	Status           string             `json:"status"`
	PeriodStart      pgtype.Date        `json:"period_start"`
	PeriodEnd        pgtype.Date        `json:"period_end"`
	ClosedAt         pgtype.Timestamptz `json:"closed_at"`
	PaidAt           pgtype.Timestamptz `json:"paid_at"`
	ContaPagarID     pgtype.UUID        `json:"conta_pagar_id"`
	ClosedBy         pgtype.UUID        `json:"closed_by"`
	PaidBy           pgtype.UUID        `json:"paid_by"`
	Notes            *string            `json:"notes"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	UnitName         *string            `json:"unit_name"`
}

func (q *Queries) ListCommissionPeriodsByProfessional(ctx context.Context, arg ListCommissionPeriodsByProfessionalParams) ([]ListCommissionPeriodsByProfessionalRow, error) {
	rows, err := q.db.Query(ctx, listCommissionPeriodsByProfessional,
		arg.TenantID,
		arg.ProfessionalID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommissionPeriodsByProfessionalRow{}
	for rows.Next() {
		var i ListCommissionPeriodsByProfessionalRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ReferenceMonth,
			&i.ProfessionalID,
			&i.TotalGross,
			&i.TotalCommission,
			&i.TotalAdvances,
			&i.TotalAdjustments,
			&i.TotalNet,
			&i.ItemsCount,
			&i.Status,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.ClosedAt,
			&i.PaidAt,
			&i.ContaPagarID,
			&i.ClosedBy,
			&i.PaidBy,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommissionPeriodsByStatus = `-- name: ListCommissionPeriodsByStatus :many
SELECT cp.id, cp.tenant_id, cp.unit_id, cp.reference_month, cp.professional_id, cp.total_gross, cp.total_commission, cp.total_advances, cp.total_adjustments, cp.total_net, cp.items_count, cp.status, cp.period_start, cp.period_end, cp.closed_at, cp.paid_at, cp.conta_pagar_id, cp.closed_by, cp.paid_by, cp.notes, cp.created_at, cp.updated_at,
       p.nome as professional_name,
       u.nome as unit_name
FROM commission_periods cp
LEFT JOIN profissionais p ON cp.professional_id = p.id
LEFT JOIN units u ON cp.unit_id = u.id
WHERE cp.tenant_id = $1
  AND cp.status = $2
ORDER BY cp.reference_month DESC, p.nome ASC
LIMIT $3 OFFSET $4
`

type ListCommissionPeriodsByStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListCommissionPeriodsByStatusRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	UnitID           pgtype.UUID        `json:"unit_id"`
	ReferenceMonth   string             `json:"reference_month"`
	ProfessionalID   pgtype.UUID        `json:"professional_id"`
	TotalGross       decimal.Decimal    `json:"total_gross"`
	TotalCommission  decimal.Decimal    `json:"total_commission"`
	TotalAdvances    decimal.Decimal    `json:"total_advances"`
	TotalAdjustments decimal.Decimal    `json:"total_adjustments"`
	TotalNet         decimal.Decimal    `json:"total_net"`
	ItemsCount       int32              `json:"items_count"`
	Status           string             `json:"status"`
	PeriodStart      pgtype.Date        `json:"period_start"`
	PeriodEnd        pgtype.Date        `json:"period_end"`
	ClosedAt         pgtype.Timestamptz `json:"closed_at"`
	PaidAt           pgtype.Timestamptz `json:"paid_at"`
	ContaPagarID     pgtype.UUID        `json:"conta_pagar_id"`
	ClosedBy         pgtype.UUID        `json:"closed_by"`
	PaidBy           pgtype.UUID        `json:"paid_by"`
	Notes            *string            `json:"notes"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	ProfessionalName *string            `json:"professional_name"`
	UnitName         *string            `json:"unit_name"`
}

func (q *Queries) ListCommissionPeriodsByStatus(ctx context.Context, arg ListCommissionPeriodsByStatusParams) ([]ListCommissionPeriodsByStatusRow, error) {
	rows, err := q.db.Query(ctx, listCommissionPeriodsByStatus,
		arg.TenantID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommissionPeriodsByStatusRow{}
	for rows.Next() {
		var i ListCommissionPeriodsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ReferenceMonth,
			&i.ProfessionalID,
			&i.TotalGross,
			&i.TotalCommission,
			&i.TotalAdvances,
			&i.TotalAdjustments,
			&i.TotalNet,
			&i.ItemsCount,
			&i.Status,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.ClosedAt,
			&i.PaidAt,
			&i.ContaPagarID,
			&i.ClosedBy,
			&i.PaidBy,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProfessionalName,
			&i.UnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommissionPeriodsByTenant = `-- name: ListCommissionPeriodsByTenant :many
SELECT cp.id, cp.tenant_id, cp.unit_id, cp.reference_month, cp.professional_id, cp.total_gross, cp.total_commission, cp.total_advances, cp.total_adjustments, cp.total_net, cp.items_count, cp.status, cp.period_start, cp.period_end, cp.closed_at, cp.paid_at, cp.conta_pagar_id, cp.closed_by, cp.paid_by, cp.notes, cp.created_at, cp.updated_at,
       p.nome as professional_name,
       u.nome as unit_name
FROM commission_periods cp
LEFT JOIN profissionais p ON cp.professional_id = p.id
LEFT JOIN units u ON cp.unit_id = u.id
WHERE cp.tenant_id = $1
ORDER BY cp.reference_month DESC, p.nome ASC
LIMIT $2 OFFSET $3
`

type ListCommissionPeriodsByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListCommissionPeriodsByTenantRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	UnitID           pgtype.UUID        `json:"unit_id"`
	ReferenceMonth   string             `json:"reference_month"`
	ProfessionalID   pgtype.UUID        `json:"professional_id"`
	TotalGross       decimal.Decimal    `json:"total_gross"`
	TotalCommission  decimal.Decimal    `json:"total_commission"`
	TotalAdvances    decimal.Decimal    `json:"total_advances"`
	TotalAdjustments decimal.Decimal    `json:"total_adjustments"`
	TotalNet         decimal.Decimal    `json:"total_net"`
	ItemsCount       int32              `json:"items_count"`
	Status           string             `json:"status"`
	PeriodStart      pgtype.Date        `json:"period_start"`
	PeriodEnd        pgtype.Date        `json:"period_end"`
	ClosedAt         pgtype.Timestamptz `json:"closed_at"`
	PaidAt           pgtype.Timestamptz `json:"paid_at"`
	ContaPagarID     pgtype.UUID        `json:"conta_pagar_id"`
	ClosedBy         pgtype.UUID        `json:"closed_by"`
	PaidBy           pgtype.UUID        `json:"paid_by"`
	Notes            *string            `json:"notes"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	ProfessionalName *string            `json:"professional_name"`
	UnitName         *string            `json:"unit_name"`
}

func (q *Queries) ListCommissionPeriodsByTenant(ctx context.Context, arg ListCommissionPeriodsByTenantParams) ([]ListCommissionPeriodsByTenantRow, error) {
	rows, err := q.db.Query(ctx, listCommissionPeriodsByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommissionPeriodsByTenantRow{}
	for rows.Next() {
		var i ListCommissionPeriodsByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ReferenceMonth,
			&i.ProfessionalID,
			&i.TotalGross,
			&i.TotalCommission,
			&i.TotalAdvances,
			&i.TotalAdjustments,
			&i.TotalNet,
			&i.ItemsCount,
			&i.Status,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.ClosedAt,
			&i.PaidAt,
			&i.ContaPagarID,
			&i.ClosedBy,
			&i.PaidBy,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProfessionalName,
			&i.UnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOpenCommissionPeriods = `-- name: ListOpenCommissionPeriods :many
SELECT cp.id, cp.tenant_id, cp.unit_id, cp.reference_month, cp.professional_id, cp.total_gross, cp.total_commission, cp.total_advances, cp.total_adjustments, cp.total_net, cp.items_count, cp.status, cp.period_start, cp.period_end, cp.closed_at, cp.paid_at, cp.conta_pagar_id, cp.closed_by, cp.paid_by, cp.notes, cp.created_at, cp.updated_at,
       p.nome as professional_name,
       u.nome as unit_name
FROM commission_periods cp
LEFT JOIN profissionais p ON cp.professional_id = p.id
LEFT JOIN units u ON cp.unit_id = u.id
WHERE cp.tenant_id = $1
  AND cp.status = 'ABERTO'
ORDER BY cp.reference_month DESC, p.nome ASC
`

type ListOpenCommissionPeriodsRow struct {
	ID               pgtype.UUID        `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	UnitID           pgtype.UUID        `json:"unit_id"`
	ReferenceMonth   string             `json:"reference_month"`
	ProfessionalID   pgtype.UUID        `json:"professional_id"`
	TotalGross       decimal.Decimal    `json:"total_gross"`
	TotalCommission  decimal.Decimal    `json:"total_commission"`
	TotalAdvances    decimal.Decimal    `json:"total_advances"`
	TotalAdjustments decimal.Decimal    `json:"total_adjustments"`
	TotalNet         decimal.Decimal    `json:"total_net"`
	ItemsCount       int32              `json:"items_count"`
	Status           string             `json:"status"`
	PeriodStart      pgtype.Date        `json:"period_start"`
	PeriodEnd        pgtype.Date        `json:"period_end"`
	ClosedAt         pgtype.Timestamptz `json:"closed_at"`
	PaidAt           pgtype.Timestamptz `json:"paid_at"`
	ContaPagarID     pgtype.UUID        `json:"conta_pagar_id"`
	ClosedBy         pgtype.UUID        `json:"closed_by"`
	PaidBy           pgtype.UUID        `json:"paid_by"`
	Notes            *string            `json:"notes"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	ProfessionalName *string            `json:"professional_name"`
	UnitName         *string            `json:"unit_name"`
}

func (q *Queries) ListOpenCommissionPeriods(ctx context.Context, tenantID pgtype.UUID) ([]ListOpenCommissionPeriodsRow, error) {
	rows, err := q.db.Query(ctx, listOpenCommissionPeriods, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOpenCommissionPeriodsRow{}
	for rows.Next() {
		var i ListOpenCommissionPeriodsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ReferenceMonth,
			&i.ProfessionalID,
			&i.TotalGross,
			&i.TotalCommission,
			&i.TotalAdvances,
			&i.TotalAdjustments,
			&i.TotalNet,
			&i.ItemsCount,
			&i.Status,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.ClosedAt,
			&i.PaidAt,
			&i.ContaPagarID,
			&i.ClosedBy,
			&i.PaidBy,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProfessionalName,
			&i.UnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markCommissionPeriodAsPaid = `-- name: MarkCommissionPeriodAsPaid :one
UPDATE commission_periods
SET
    status = 'PAGO',
    paid_at = NOW(),
    paid_by = $3,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, unit_id, reference_month, professional_id, total_gross, total_commission, total_advances, total_adjustments, total_net, items_count, status, period_start, period_end, closed_at, paid_at, conta_pagar_id, closed_by, paid_by, notes, created_at, updated_at
`

type MarkCommissionPeriodAsPaidParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	PaidBy   pgtype.UUID `json:"paid_by"`
}

func (q *Queries) MarkCommissionPeriodAsPaid(ctx context.Context, arg MarkCommissionPeriodAsPaidParams) (CommissionPeriod, error) {
	row := q.db.QueryRow(ctx, markCommissionPeriodAsPaid, arg.ID, arg.TenantID, arg.PaidBy)
	var i CommissionPeriod
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ReferenceMonth,
		&i.ProfessionalID,
		&i.TotalGross,
		&i.TotalCommission,
		&i.TotalAdvances,
		&i.TotalAdjustments,
		&i.TotalNet,
		&i.ItemsCount,
		&i.Status,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.ClosedAt,
		&i.PaidAt,
		&i.ContaPagarID,
		&i.ClosedBy,
		&i.PaidBy,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const sumCommissionsByMonth = `-- name: SumCommissionsByMonth :one
SELECT
    COALESCE(SUM(total_commission), 0)::NUMERIC(15,2) as total_commission,
    COALESCE(SUM(total_net), 0)::NUMERIC(15,2) as total_net,
    COUNT(*) as periods_count
FROM commission_periods
WHERE tenant_id = $1
  AND reference_month = $2
`

type SumCommissionsByMonthParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ReferenceMonth string      `json:"reference_month"`
}

type SumCommissionsByMonthRow struct {
	TotalCommission decimal.Decimal `json:"total_commission"`
	TotalNet        decimal.Decimal `json:"total_net"`
	PeriodsCount    int64           `json:"periods_count"`
}

func (q *Queries) SumCommissionsByMonth(ctx context.Context, arg SumCommissionsByMonthParams) (SumCommissionsByMonthRow, error) {
	row := q.db.QueryRow(ctx, sumCommissionsByMonth, arg.TenantID, arg.ReferenceMonth)
	var i SumCommissionsByMonthRow
	err := row.Scan(&i.TotalCommission, &i.TotalNet, &i.PeriodsCount)
	return i, err
}

const sumCommissionsByPeriodRange = `-- name: SumCommissionsByPeriodRange :one
SELECT
    COALESCE(SUM(total_commission), 0)::NUMERIC(15,2) as total_commission,
    COALESCE(SUM(total_net), 0)::NUMERIC(15,2) as total_net,
    COUNT(*) as periods_count
FROM commission_periods
WHERE tenant_id = $1
  AND reference_month >= $2
  AND reference_month <= $3
`

type SumCommissionsByPeriodRangeParams struct {
	TenantID         pgtype.UUID `json:"tenant_id"`
	ReferenceMonth   string      `json:"reference_month"`
	ReferenceMonth_2 string      `json:"reference_month_2"`
}

type SumCommissionsByPeriodRangeRow struct {
	TotalCommission decimal.Decimal `json:"total_commission"`
	TotalNet        decimal.Decimal `json:"total_net"`
	PeriodsCount    int64           `json:"periods_count"`
}

func (q *Queries) SumCommissionsByPeriodRange(ctx context.Context, arg SumCommissionsByPeriodRangeParams) (SumCommissionsByPeriodRangeRow, error) {
	row := q.db.QueryRow(ctx, sumCommissionsByPeriodRange, arg.TenantID, arg.ReferenceMonth, arg.ReferenceMonth_2)
	var i SumCommissionsByPeriodRangeRow
	err := row.Scan(&i.TotalCommission, &i.TotalNet, &i.PeriodsCount)
	return i, err
}

const updateCommissionPeriodTotals = `-- name: UpdateCommissionPeriodTotals :one
UPDATE commission_periods
SET
    total_gross = $3,
    total_commission = $4,
    total_advances = $5,
    total_adjustments = $6,
    total_net = $7,
    items_count = $8,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, unit_id, reference_month, professional_id, total_gross, total_commission, total_advances, total_adjustments, total_net, items_count, status, period_start, period_end, closed_at, paid_at, conta_pagar_id, closed_by, paid_by, notes, created_at, updated_at
`

type UpdateCommissionPeriodTotalsParams struct {
	ID               pgtype.UUID     `json:"id"`
	TenantID         pgtype.UUID     `json:"tenant_id"`
	TotalGross       decimal.Decimal `json:"total_gross"`
	TotalCommission  decimal.Decimal `json:"total_commission"`
	TotalAdvances    decimal.Decimal `json:"total_advances"`
	TotalAdjustments decimal.Decimal `json:"total_adjustments"`
	TotalNet         decimal.Decimal `json:"total_net"`
	ItemsCount       int32           `json:"items_count"`
}

func (q *Queries) UpdateCommissionPeriodTotals(ctx context.Context, arg UpdateCommissionPeriodTotalsParams) (CommissionPeriod, error) {
	row := q.db.QueryRow(ctx, updateCommissionPeriodTotals,
		arg.ID,
		arg.TenantID,
		arg.TotalGross,
		arg.TotalCommission,
		arg.TotalAdvances,
		arg.TotalAdjustments,
		arg.TotalNet,
		arg.ItemsCount,
	)
	var i CommissionPeriod
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ReferenceMonth,
		&i.ProfessionalID,
		&i.TotalGross,
		&i.TotalCommission,
		&i.TotalAdvances,
		&i.TotalAdjustments,
		&i.TotalNet,
		&i.ItemsCount,
		&i.Status,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.ClosedAt,
		&i.PaidAt,
		&i.ContaPagarID,
		&i.ClosedBy,
		&i.PaidBy,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
