// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: blocked_times.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkBlockedTimeConflict = `-- name: CheckBlockedTimeConflict :one
SELECT EXISTS (
    SELECT 1 FROM blocked_times
    WHERE tenant_id = $1::uuid
      AND professional_id = $2::uuid
      AND ($3::uuid IS NULL OR id != $3::uuid)
      AND start_time < $4::timestamptz
      AND end_time > $5::timestamptz
) as has_conflict
`

type CheckBlockedTimeConflictParams struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	ProfessionalID pgtype.UUID        `json:"professional_id"`
	ExcludeID      pgtype.UUID        `json:"exclude_id"`
	EndTime        pgtype.Timestamptz `json:"end_time"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
}

// Verifica se há conflito com bloqueios existentes
func (q *Queries) CheckBlockedTimeConflict(ctx context.Context, arg CheckBlockedTimeConflictParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkBlockedTimeConflict,
		arg.TenantID,
		arg.ProfessionalID,
		arg.ExcludeID,
		arg.EndTime,
		arg.StartTime,
	)
	var has_conflict bool
	err := row.Scan(&has_conflict)
	return has_conflict, err
}

const createBlockedTime = `-- name: CreateBlockedTime :one

INSERT INTO blocked_times (
    id,
    tenant_id,
    professional_id,
    start_time,
    end_time,
    reason,
    is_recurring,
    recurrence_rule,
    created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, tenant_id, professional_id, start_time, end_time, reason, is_recurring, recurrence_rule, created_at, updated_at, created_by
`

type CreateBlockedTimeParams struct {
	ID             pgtype.UUID        `json:"id"`
	TenantID       pgtype.UUID        `json:"tenant_id"`
	ProfessionalID pgtype.UUID        `json:"professional_id"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
	EndTime        pgtype.Timestamptz `json:"end_time"`
	Reason         string             `json:"reason"`
	IsRecurring    bool               `json:"is_recurring"`
	RecurrenceRule *string            `json:"recurrence_rule"`
	CreatedBy      pgtype.UUID        `json:"created_by"`
}

// ============================================================================
// BLOCKED_TIMES QUERIES (sqlc)
// Bloqueios de horário na agenda
// ============================================================================
func (q *Queries) CreateBlockedTime(ctx context.Context, arg CreateBlockedTimeParams) (BlockedTime, error) {
	row := q.db.QueryRow(ctx, createBlockedTime,
		arg.ID,
		arg.TenantID,
		arg.ProfessionalID,
		arg.StartTime,
		arg.EndTime,
		arg.Reason,
		arg.IsRecurring,
		arg.RecurrenceRule,
		arg.CreatedBy,
	)
	var i BlockedTime
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.StartTime,
		&i.EndTime,
		&i.Reason,
		&i.IsRecurring,
		&i.RecurrenceRule,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteBlockedTime = `-- name: DeleteBlockedTime :exec
DELETE FROM blocked_times
WHERE id = $1 AND tenant_id = $2
`

type DeleteBlockedTimeParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteBlockedTime(ctx context.Context, arg DeleteBlockedTimeParams) error {
	_, err := q.db.Exec(ctx, deleteBlockedTime, arg.ID, arg.TenantID)
	return err
}

const getBlockedTimeByID = `-- name: GetBlockedTimeByID :one
SELECT id, tenant_id, professional_id, start_time, end_time, reason, is_recurring, recurrence_rule, created_at, updated_at, created_by FROM blocked_times
WHERE id = $1 AND tenant_id = $2
`

type GetBlockedTimeByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetBlockedTimeByID(ctx context.Context, arg GetBlockedTimeByIDParams) (BlockedTime, error) {
	row := q.db.QueryRow(ctx, getBlockedTimeByID, arg.ID, arg.TenantID)
	var i BlockedTime
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.StartTime,
		&i.EndTime,
		&i.Reason,
		&i.IsRecurring,
		&i.RecurrenceRule,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getBlockedTimesInRange = `-- name: GetBlockedTimesInRange :many
SELECT id, tenant_id, professional_id, start_time, end_time, reason, is_recurring, recurrence_rule, created_at, updated_at, created_by FROM blocked_times
WHERE tenant_id = $1
  AND professional_id = $2
  AND start_time < $4
  AND end_time > $3
ORDER BY start_time ASC
`

type GetBlockedTimesInRangeParams struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	ProfessionalID pgtype.UUID        `json:"professional_id"`
	EndTime        pgtype.Timestamptz `json:"end_time"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
}

// Busca bloqueios em um intervalo de tempo (para validação de agendamentos)
func (q *Queries) GetBlockedTimesInRange(ctx context.Context, arg GetBlockedTimesInRangeParams) ([]BlockedTime, error) {
	rows, err := q.db.Query(ctx, getBlockedTimesInRange,
		arg.TenantID,
		arg.ProfessionalID,
		arg.EndTime,
		arg.StartTime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BlockedTime{}
	for rows.Next() {
		var i BlockedTime
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProfessionalID,
			&i.StartTime,
			&i.EndTime,
			&i.Reason,
			&i.IsRecurring,
			&i.RecurrenceRule,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBlockedTimes = `-- name: ListBlockedTimes :many
SELECT id, tenant_id, professional_id, start_time, end_time, reason, is_recurring, recurrence_rule, created_at, updated_at, created_by FROM blocked_times
WHERE tenant_id = $1::uuid
  AND ($2::uuid IS NULL OR professional_id = $2::uuid)
  AND ($3::timestamptz IS NULL OR start_time >= $3::timestamptz)
  AND ($4::timestamptz IS NULL OR end_time <= $4::timestamptz)
ORDER BY start_time ASC
`

type ListBlockedTimesParams struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	ProfessionalID pgtype.UUID        `json:"professional_id"`
	StartDate      pgtype.Timestamptz `json:"start_date"`
	EndDate        pgtype.Timestamptz `json:"end_date"`
}

// Lista bloqueios com filtros opcionais
func (q *Queries) ListBlockedTimes(ctx context.Context, arg ListBlockedTimesParams) ([]BlockedTime, error) {
	rows, err := q.db.Query(ctx, listBlockedTimes,
		arg.TenantID,
		arg.ProfessionalID,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BlockedTime{}
	for rows.Next() {
		var i BlockedTime
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProfessionalID,
			&i.StartTime,
			&i.EndTime,
			&i.Reason,
			&i.IsRecurring,
			&i.RecurrenceRule,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBlockedTime = `-- name: UpdateBlockedTime :one
UPDATE blocked_times
SET
    start_time = $3,
    end_time = $4,
    reason = $5,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, professional_id, start_time, end_time, reason, is_recurring, recurrence_rule, created_at, updated_at, created_by
`

type UpdateBlockedTimeParams struct {
	ID        pgtype.UUID        `json:"id"`
	TenantID  pgtype.UUID        `json:"tenant_id"`
	StartTime pgtype.Timestamptz `json:"start_time"`
	EndTime   pgtype.Timestamptz `json:"end_time"`
	Reason    string             `json:"reason"`
}

func (q *Queries) UpdateBlockedTime(ctx context.Context, arg UpdateBlockedTimeParams) (BlockedTime, error) {
	row := q.db.QueryRow(ctx, updateBlockedTime,
		arg.ID,
		arg.TenantID,
		arg.StartTime,
		arg.EndTime,
		arg.Reason,
	)
	var i BlockedTime
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.StartTime,
		&i.EndTime,
		&i.Reason,
		&i.IsRecurring,
		&i.RecurrenceRule,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}
