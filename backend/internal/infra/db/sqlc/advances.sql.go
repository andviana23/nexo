// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: advances.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const approveAdvance = `-- name: ApproveAdvance :one
UPDATE advances
SET
    status = 'APPROVED',
    approved_at = NOW(),
    approved_by = $3,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2 AND status = 'PENDING'
RETURNING id, tenant_id, unit_id, professional_id, amount, request_date, reason, status, approved_at, approved_by, rejected_at, rejected_by, rejection_reason, deducted_at, deduction_period_id, created_at, updated_at, created_by
`

type ApproveAdvanceParams struct {
	ID         pgtype.UUID `json:"id"`
	TenantID   pgtype.UUID `json:"tenant_id"`
	ApprovedBy pgtype.UUID `json:"approved_by"`
}

func (q *Queries) ApproveAdvance(ctx context.Context, arg ApproveAdvanceParams) (Advance, error) {
	row := q.db.QueryRow(ctx, approveAdvance, arg.ID, arg.TenantID, arg.ApprovedBy)
	var i Advance
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ProfessionalID,
		&i.Amount,
		&i.RequestDate,
		&i.Reason,
		&i.Status,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.RejectedAt,
		&i.RejectedBy,
		&i.RejectionReason,
		&i.DeductedAt,
		&i.DeductionPeriodID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const cancelAdvance = `-- name: CancelAdvance :one
UPDATE advances
SET
    status = 'CANCELLED',
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2 AND status IN ('PENDING', 'APPROVED')
RETURNING id, tenant_id, unit_id, professional_id, amount, request_date, reason, status, approved_at, approved_by, rejected_at, rejected_by, rejection_reason, deducted_at, deduction_period_id, created_at, updated_at, created_by
`

type CancelAdvanceParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) CancelAdvance(ctx context.Context, arg CancelAdvanceParams) (Advance, error) {
	row := q.db.QueryRow(ctx, cancelAdvance, arg.ID, arg.TenantID)
	var i Advance
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ProfessionalID,
		&i.Amount,
		&i.RequestDate,
		&i.Reason,
		&i.Status,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.RejectedAt,
		&i.RejectedBy,
		&i.RejectionReason,
		&i.DeductedAt,
		&i.DeductionPeriodID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const countAdvancesByStatus = `-- name: CountAdvancesByStatus :one
SELECT
    COUNT(*) FILTER (WHERE status = 'PENDING') as pending,
    COUNT(*) FILTER (WHERE status = 'APPROVED') as approved,
    COUNT(*) FILTER (WHERE status = 'REJECTED') as rejected,
    COUNT(*) FILTER (WHERE status = 'DEDUCTED') as deducted
FROM advances
WHERE tenant_id = $1
`

type CountAdvancesByStatusRow struct {
	Pending  int64 `json:"pending"`
	Approved int64 `json:"approved"`
	Rejected int64 `json:"rejected"`
	Deducted int64 `json:"deducted"`
}

func (q *Queries) CountAdvancesByStatus(ctx context.Context, tenantID pgtype.UUID) (CountAdvancesByStatusRow, error) {
	row := q.db.QueryRow(ctx, countAdvancesByStatus, tenantID)
	var i CountAdvancesByStatusRow
	err := row.Scan(
		&i.Pending,
		&i.Approved,
		&i.Rejected,
		&i.Deducted,
	)
	return i, err
}

const createAdvance = `-- name: CreateAdvance :one

INSERT INTO advances (
    tenant_id,
    unit_id,
    professional_id,
    amount,
    request_date,
    reason,
    status,
    created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, tenant_id, unit_id, professional_id, amount, request_date, reason, status, approved_at, approved_by, rejected_at, rejected_by, rejection_reason, deducted_at, deduction_period_id, created_at, updated_at, created_by
`

type CreateAdvanceParams struct {
	TenantID       pgtype.UUID     `json:"tenant_id"`
	UnitID         pgtype.UUID     `json:"unit_id"`
	ProfessionalID pgtype.UUID     `json:"professional_id"`
	Amount         decimal.Decimal `json:"amount"`
	RequestDate    pgtype.Date     `json:"request_date"`
	Reason         *string         `json:"reason"`
	Status         string          `json:"status"`
	CreatedBy      pgtype.UUID     `json:"created_by"`
}

// ============================================================================
// QUERIES: advances
// Adiantamentos de profissionais
// ============================================================================
func (q *Queries) CreateAdvance(ctx context.Context, arg CreateAdvanceParams) (Advance, error) {
	row := q.db.QueryRow(ctx, createAdvance,
		arg.TenantID,
		arg.UnitID,
		arg.ProfessionalID,
		arg.Amount,
		arg.RequestDate,
		arg.Reason,
		arg.Status,
		arg.CreatedBy,
	)
	var i Advance
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ProfessionalID,
		&i.Amount,
		&i.RequestDate,
		&i.Reason,
		&i.Status,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.RejectedAt,
		&i.RejectedBy,
		&i.RejectionReason,
		&i.DeductedAt,
		&i.DeductionPeriodID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deductAdvance = `-- name: DeductAdvance :one
UPDATE advances
SET
    status = 'DEDUCTED',
    deducted_at = NOW(),
    deduction_period_id = $3,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2 AND status = 'APPROVED'
RETURNING id, tenant_id, unit_id, professional_id, amount, request_date, reason, status, approved_at, approved_by, rejected_at, rejected_by, rejection_reason, deducted_at, deduction_period_id, created_at, updated_at, created_by
`

type DeductAdvanceParams struct {
	ID                pgtype.UUID `json:"id"`
	TenantID          pgtype.UUID `json:"tenant_id"`
	DeductionPeriodID pgtype.UUID `json:"deduction_period_id"`
}

func (q *Queries) DeductAdvance(ctx context.Context, arg DeductAdvanceParams) (Advance, error) {
	row := q.db.QueryRow(ctx, deductAdvance, arg.ID, arg.TenantID, arg.DeductionPeriodID)
	var i Advance
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ProfessionalID,
		&i.Amount,
		&i.RequestDate,
		&i.Reason,
		&i.Status,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.RejectedAt,
		&i.RejectedBy,
		&i.RejectionReason,
		&i.DeductedAt,
		&i.DeductionPeriodID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteAdvance = `-- name: DeleteAdvance :exec
DELETE FROM advances
WHERE id = $1 AND tenant_id = $2 AND status = 'PENDING'
`

type DeleteAdvanceParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteAdvance(ctx context.Context, arg DeleteAdvanceParams) error {
	_, err := q.db.Exec(ctx, deleteAdvance, arg.ID, arg.TenantID)
	return err
}

const getAdvanceByID = `-- name: GetAdvanceByID :one
SELECT a.id, a.tenant_id, a.unit_id, a.professional_id, a.amount, a.request_date, a.reason, a.status, a.approved_at, a.approved_by, a.rejected_at, a.rejected_by, a.rejection_reason, a.deducted_at, a.deduction_period_id, a.created_at, a.updated_at, a.created_by,
       p.nome as professional_name,
       u.nome as unit_name
FROM advances a
JOIN profissionais p ON a.professional_id = p.id
LEFT JOIN units u ON a.unit_id = u.id
WHERE a.id = $1 AND a.tenant_id = $2
`

type GetAdvanceByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetAdvanceByIDRow struct {
	ID                pgtype.UUID        `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	UnitID            pgtype.UUID        `json:"unit_id"`
	ProfessionalID    pgtype.UUID        `json:"professional_id"`
	Amount            decimal.Decimal    `json:"amount"`
	RequestDate       pgtype.Date        `json:"request_date"`
	Reason            *string            `json:"reason"`
	Status            string             `json:"status"`
	ApprovedAt        pgtype.Timestamptz `json:"approved_at"`
	ApprovedBy        pgtype.UUID        `json:"approved_by"`
	RejectedAt        pgtype.Timestamptz `json:"rejected_at"`
	RejectedBy        pgtype.UUID        `json:"rejected_by"`
	RejectionReason   *string            `json:"rejection_reason"`
	DeductedAt        pgtype.Timestamptz `json:"deducted_at"`
	DeductionPeriodID pgtype.UUID        `json:"deduction_period_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	CreatedBy         pgtype.UUID        `json:"created_by"`
	ProfessionalName  string             `json:"professional_name"`
	UnitName          *string            `json:"unit_name"`
}

func (q *Queries) GetAdvanceByID(ctx context.Context, arg GetAdvanceByIDParams) (GetAdvanceByIDRow, error) {
	row := q.db.QueryRow(ctx, getAdvanceByID, arg.ID, arg.TenantID)
	var i GetAdvanceByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ProfessionalID,
		&i.Amount,
		&i.RequestDate,
		&i.Reason,
		&i.Status,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.RejectedAt,
		&i.RejectedBy,
		&i.RejectionReason,
		&i.DeductedAt,
		&i.DeductionPeriodID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.ProfessionalName,
		&i.UnitName,
	)
	return i, err
}

const listAdvancesByProfessional = `-- name: ListAdvancesByProfessional :many
SELECT a.id, a.tenant_id, a.unit_id, a.professional_id, a.amount, a.request_date, a.reason, a.status, a.approved_at, a.approved_by, a.rejected_at, a.rejected_by, a.rejection_reason, a.deducted_at, a.deduction_period_id, a.created_at, a.updated_at, a.created_by,
       u.nome as unit_name
FROM advances a
LEFT JOIN units u ON a.unit_id = u.id
WHERE a.tenant_id = $1
  AND a.professional_id = $2
ORDER BY a.created_at DESC
LIMIT $3 OFFSET $4
`

type ListAdvancesByProfessionalParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ProfessionalID pgtype.UUID `json:"professional_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

type ListAdvancesByProfessionalRow struct {
	ID                pgtype.UUID        `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	UnitID            pgtype.UUID        `json:"unit_id"`
	ProfessionalID    pgtype.UUID        `json:"professional_id"`
	Amount            decimal.Decimal    `json:"amount"`
	RequestDate       pgtype.Date        `json:"request_date"`
	Reason            *string            `json:"reason"`
	Status            string             `json:"status"`
	ApprovedAt        pgtype.Timestamptz `json:"approved_at"`
	ApprovedBy        pgtype.UUID        `json:"approved_by"`
	RejectedAt        pgtype.Timestamptz `json:"rejected_at"`
	RejectedBy        pgtype.UUID        `json:"rejected_by"`
	RejectionReason   *string            `json:"rejection_reason"`
	DeductedAt        pgtype.Timestamptz `json:"deducted_at"`
	DeductionPeriodID pgtype.UUID        `json:"deduction_period_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	CreatedBy         pgtype.UUID        `json:"created_by"`
	UnitName          *string            `json:"unit_name"`
}

func (q *Queries) ListAdvancesByProfessional(ctx context.Context, arg ListAdvancesByProfessionalParams) ([]ListAdvancesByProfessionalRow, error) {
	rows, err := q.db.Query(ctx, listAdvancesByProfessional,
		arg.TenantID,
		arg.ProfessionalID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAdvancesByProfessionalRow{}
	for rows.Next() {
		var i ListAdvancesByProfessionalRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ProfessionalID,
			&i.Amount,
			&i.RequestDate,
			&i.Reason,
			&i.Status,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.RejectedAt,
			&i.RejectedBy,
			&i.RejectionReason,
			&i.DeductedAt,
			&i.DeductionPeriodID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdvancesByStatus = `-- name: ListAdvancesByStatus :many
SELECT a.id, a.tenant_id, a.unit_id, a.professional_id, a.amount, a.request_date, a.reason, a.status, a.approved_at, a.approved_by, a.rejected_at, a.rejected_by, a.rejection_reason, a.deducted_at, a.deduction_period_id, a.created_at, a.updated_at, a.created_by,
       p.nome as professional_name,
       u.nome as unit_name
FROM advances a
JOIN profissionais p ON a.professional_id = p.id
LEFT JOIN units u ON a.unit_id = u.id
WHERE a.tenant_id = $1
  AND a.status = $2
ORDER BY a.created_at DESC
LIMIT $3 OFFSET $4
`

type ListAdvancesByStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListAdvancesByStatusRow struct {
	ID                pgtype.UUID        `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	UnitID            pgtype.UUID        `json:"unit_id"`
	ProfessionalID    pgtype.UUID        `json:"professional_id"`
	Amount            decimal.Decimal    `json:"amount"`
	RequestDate       pgtype.Date        `json:"request_date"`
	Reason            *string            `json:"reason"`
	Status            string             `json:"status"`
	ApprovedAt        pgtype.Timestamptz `json:"approved_at"`
	ApprovedBy        pgtype.UUID        `json:"approved_by"`
	RejectedAt        pgtype.Timestamptz `json:"rejected_at"`
	RejectedBy        pgtype.UUID        `json:"rejected_by"`
	RejectionReason   *string            `json:"rejection_reason"`
	DeductedAt        pgtype.Timestamptz `json:"deducted_at"`
	DeductionPeriodID pgtype.UUID        `json:"deduction_period_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	CreatedBy         pgtype.UUID        `json:"created_by"`
	ProfessionalName  string             `json:"professional_name"`
	UnitName          *string            `json:"unit_name"`
}

func (q *Queries) ListAdvancesByStatus(ctx context.Context, arg ListAdvancesByStatusParams) ([]ListAdvancesByStatusRow, error) {
	rows, err := q.db.Query(ctx, listAdvancesByStatus,
		arg.TenantID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAdvancesByStatusRow{}
	for rows.Next() {
		var i ListAdvancesByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ProfessionalID,
			&i.Amount,
			&i.RequestDate,
			&i.Reason,
			&i.Status,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.RejectedAt,
			&i.RejectedBy,
			&i.RejectionReason,
			&i.DeductedAt,
			&i.DeductionPeriodID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.ProfessionalName,
			&i.UnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAdvancesByTenant = `-- name: ListAdvancesByTenant :many
SELECT a.id, a.tenant_id, a.unit_id, a.professional_id, a.amount, a.request_date, a.reason, a.status, a.approved_at, a.approved_by, a.rejected_at, a.rejected_by, a.rejection_reason, a.deducted_at, a.deduction_period_id, a.created_at, a.updated_at, a.created_by,
       p.nome as professional_name,
       u.nome as unit_name
FROM advances a
JOIN profissionais p ON a.professional_id = p.id
LEFT JOIN units u ON a.unit_id = u.id
WHERE a.tenant_id = $1
ORDER BY a.created_at DESC
LIMIT $2 OFFSET $3
`

type ListAdvancesByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListAdvancesByTenantRow struct {
	ID                pgtype.UUID        `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	UnitID            pgtype.UUID        `json:"unit_id"`
	ProfessionalID    pgtype.UUID        `json:"professional_id"`
	Amount            decimal.Decimal    `json:"amount"`
	RequestDate       pgtype.Date        `json:"request_date"`
	Reason            *string            `json:"reason"`
	Status            string             `json:"status"`
	ApprovedAt        pgtype.Timestamptz `json:"approved_at"`
	ApprovedBy        pgtype.UUID        `json:"approved_by"`
	RejectedAt        pgtype.Timestamptz `json:"rejected_at"`
	RejectedBy        pgtype.UUID        `json:"rejected_by"`
	RejectionReason   *string            `json:"rejection_reason"`
	DeductedAt        pgtype.Timestamptz `json:"deducted_at"`
	DeductionPeriodID pgtype.UUID        `json:"deduction_period_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	CreatedBy         pgtype.UUID        `json:"created_by"`
	ProfessionalName  string             `json:"professional_name"`
	UnitName          *string            `json:"unit_name"`
}

func (q *Queries) ListAdvancesByTenant(ctx context.Context, arg ListAdvancesByTenantParams) ([]ListAdvancesByTenantRow, error) {
	rows, err := q.db.Query(ctx, listAdvancesByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAdvancesByTenantRow{}
	for rows.Next() {
		var i ListAdvancesByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ProfessionalID,
			&i.Amount,
			&i.RequestDate,
			&i.Reason,
			&i.Status,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.RejectedAt,
			&i.RejectedBy,
			&i.RejectionReason,
			&i.DeductedAt,
			&i.DeductionPeriodID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.ProfessionalName,
			&i.UnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApprovedAdvancesForProfessional = `-- name: ListApprovedAdvancesForProfessional :many
SELECT a.id, a.tenant_id, a.unit_id, a.professional_id, a.amount, a.request_date, a.reason, a.status, a.approved_at, a.approved_by, a.rejected_at, a.rejected_by, a.rejection_reason, a.deducted_at, a.deduction_period_id, a.created_at, a.updated_at, a.created_by
FROM advances a
WHERE a.tenant_id = $1
  AND a.professional_id = $2
  AND a.status = 'APPROVED'
ORDER BY a.request_date ASC
`

type ListApprovedAdvancesForProfessionalParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ProfessionalID pgtype.UUID `json:"professional_id"`
}

func (q *Queries) ListApprovedAdvancesForProfessional(ctx context.Context, arg ListApprovedAdvancesForProfessionalParams) ([]Advance, error) {
	rows, err := q.db.Query(ctx, listApprovedAdvancesForProfessional, arg.TenantID, arg.ProfessionalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Advance{}
	for rows.Next() {
		var i Advance
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ProfessionalID,
			&i.Amount,
			&i.RequestDate,
			&i.Reason,
			&i.Status,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.RejectedAt,
			&i.RejectedBy,
			&i.RejectionReason,
			&i.DeductedAt,
			&i.DeductionPeriodID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApprovedAdvancesNotDeducted = `-- name: ListApprovedAdvancesNotDeducted :many
SELECT a.id, a.tenant_id, a.unit_id, a.professional_id, a.amount, a.request_date, a.reason, a.status, a.approved_at, a.approved_by, a.rejected_at, a.rejected_by, a.rejection_reason, a.deducted_at, a.deduction_period_id, a.created_at, a.updated_at, a.created_by,
       p.nome as professional_name,
       u.nome as unit_name
FROM advances a
JOIN profissionais p ON a.professional_id = p.id
LEFT JOIN units u ON a.unit_id = u.id
WHERE a.tenant_id = $1
  AND a.status = 'APPROVED'
ORDER BY a.request_date ASC
`

type ListApprovedAdvancesNotDeductedRow struct {
	ID                pgtype.UUID        `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	UnitID            pgtype.UUID        `json:"unit_id"`
	ProfessionalID    pgtype.UUID        `json:"professional_id"`
	Amount            decimal.Decimal    `json:"amount"`
	RequestDate       pgtype.Date        `json:"request_date"`
	Reason            *string            `json:"reason"`
	Status            string             `json:"status"`
	ApprovedAt        pgtype.Timestamptz `json:"approved_at"`
	ApprovedBy        pgtype.UUID        `json:"approved_by"`
	RejectedAt        pgtype.Timestamptz `json:"rejected_at"`
	RejectedBy        pgtype.UUID        `json:"rejected_by"`
	RejectionReason   *string            `json:"rejection_reason"`
	DeductedAt        pgtype.Timestamptz `json:"deducted_at"`
	DeductionPeriodID pgtype.UUID        `json:"deduction_period_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	CreatedBy         pgtype.UUID        `json:"created_by"`
	ProfessionalName  string             `json:"professional_name"`
	UnitName          *string            `json:"unit_name"`
}

func (q *Queries) ListApprovedAdvancesNotDeducted(ctx context.Context, tenantID pgtype.UUID) ([]ListApprovedAdvancesNotDeductedRow, error) {
	rows, err := q.db.Query(ctx, listApprovedAdvancesNotDeducted, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListApprovedAdvancesNotDeductedRow{}
	for rows.Next() {
		var i ListApprovedAdvancesNotDeductedRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ProfessionalID,
			&i.Amount,
			&i.RequestDate,
			&i.Reason,
			&i.Status,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.RejectedAt,
			&i.RejectedBy,
			&i.RejectionReason,
			&i.DeductedAt,
			&i.DeductionPeriodID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.ProfessionalName,
			&i.UnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingAdvances = `-- name: ListPendingAdvances :many
SELECT a.id, a.tenant_id, a.unit_id, a.professional_id, a.amount, a.request_date, a.reason, a.status, a.approved_at, a.approved_by, a.rejected_at, a.rejected_by, a.rejection_reason, a.deducted_at, a.deduction_period_id, a.created_at, a.updated_at, a.created_by,
       p.nome as professional_name,
       u.nome as unit_name
FROM advances a
JOIN profissionais p ON a.professional_id = p.id
LEFT JOIN units u ON a.unit_id = u.id
WHERE a.tenant_id = $1
  AND a.status = 'PENDING'
ORDER BY a.request_date ASC, a.created_at ASC
`

type ListPendingAdvancesRow struct {
	ID                pgtype.UUID        `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	UnitID            pgtype.UUID        `json:"unit_id"`
	ProfessionalID    pgtype.UUID        `json:"professional_id"`
	Amount            decimal.Decimal    `json:"amount"`
	RequestDate       pgtype.Date        `json:"request_date"`
	Reason            *string            `json:"reason"`
	Status            string             `json:"status"`
	ApprovedAt        pgtype.Timestamptz `json:"approved_at"`
	ApprovedBy        pgtype.UUID        `json:"approved_by"`
	RejectedAt        pgtype.Timestamptz `json:"rejected_at"`
	RejectedBy        pgtype.UUID        `json:"rejected_by"`
	RejectionReason   *string            `json:"rejection_reason"`
	DeductedAt        pgtype.Timestamptz `json:"deducted_at"`
	DeductionPeriodID pgtype.UUID        `json:"deduction_period_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	CreatedBy         pgtype.UUID        `json:"created_by"`
	ProfessionalName  string             `json:"professional_name"`
	UnitName          *string            `json:"unit_name"`
}

func (q *Queries) ListPendingAdvances(ctx context.Context, tenantID pgtype.UUID) ([]ListPendingAdvancesRow, error) {
	rows, err := q.db.Query(ctx, listPendingAdvances, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingAdvancesRow{}
	for rows.Next() {
		var i ListPendingAdvancesRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UnitID,
			&i.ProfessionalID,
			&i.Amount,
			&i.RequestDate,
			&i.Reason,
			&i.Status,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.RejectedAt,
			&i.RejectedBy,
			&i.RejectionReason,
			&i.DeductedAt,
			&i.DeductionPeriodID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.ProfessionalName,
			&i.UnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectAdvance = `-- name: RejectAdvance :one
UPDATE advances
SET
    status = 'REJECTED',
    rejected_at = NOW(),
    rejected_by = $3,
    rejection_reason = $4,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2 AND status = 'PENDING'
RETURNING id, tenant_id, unit_id, professional_id, amount, request_date, reason, status, approved_at, approved_by, rejected_at, rejected_by, rejection_reason, deducted_at, deduction_period_id, created_at, updated_at, created_by
`

type RejectAdvanceParams struct {
	ID              pgtype.UUID `json:"id"`
	TenantID        pgtype.UUID `json:"tenant_id"`
	RejectedBy      pgtype.UUID `json:"rejected_by"`
	RejectionReason *string     `json:"rejection_reason"`
}

func (q *Queries) RejectAdvance(ctx context.Context, arg RejectAdvanceParams) (Advance, error) {
	row := q.db.QueryRow(ctx, rejectAdvance,
		arg.ID,
		arg.TenantID,
		arg.RejectedBy,
		arg.RejectionReason,
	)
	var i Advance
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UnitID,
		&i.ProfessionalID,
		&i.Amount,
		&i.RequestDate,
		&i.Reason,
		&i.Status,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.RejectedAt,
		&i.RejectedBy,
		&i.RejectionReason,
		&i.DeductedAt,
		&i.DeductionPeriodID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const sumAdvancesByPeriod = `-- name: SumAdvancesByPeriod :one
SELECT COALESCE(SUM(amount), 0)::NUMERIC(15,2) as total
FROM advances
WHERE tenant_id = $1
  AND request_date >= $2
  AND request_date <= $3
  AND status IN ('APPROVED', 'DEDUCTED')
`

type SumAdvancesByPeriodParams struct {
	TenantID      pgtype.UUID `json:"tenant_id"`
	RequestDate   pgtype.Date `json:"request_date"`
	RequestDate_2 pgtype.Date `json:"request_date_2"`
}

func (q *Queries) SumAdvancesByPeriod(ctx context.Context, arg SumAdvancesByPeriodParams) (decimal.Decimal, error) {
	row := q.db.QueryRow(ctx, sumAdvancesByPeriod, arg.TenantID, arg.RequestDate, arg.RequestDate_2)
	var total decimal.Decimal
	err := row.Scan(&total)
	return total, err
}

const sumApprovedAdvancesByProfessional = `-- name: SumApprovedAdvancesByProfessional :one
SELECT COALESCE(SUM(amount), 0)::NUMERIC(15,2) as total
FROM advances
WHERE tenant_id = $1
  AND professional_id = $2
  AND status = 'APPROVED'
`

type SumApprovedAdvancesByProfessionalParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ProfessionalID pgtype.UUID `json:"professional_id"`
}

func (q *Queries) SumApprovedAdvancesByProfessional(ctx context.Context, arg SumApprovedAdvancesByProfessionalParams) (decimal.Decimal, error) {
	row := q.db.QueryRow(ctx, sumApprovedAdvancesByProfessional, arg.TenantID, arg.ProfessionalID)
	var total decimal.Decimal
	err := row.Scan(&total)
	return total, err
}

const sumPendingAdvancesByProfessional = `-- name: SumPendingAdvancesByProfessional :one
SELECT COALESCE(SUM(amount), 0)::NUMERIC(15,2) as total
FROM advances
WHERE tenant_id = $1
  AND professional_id = $2
  AND status = 'PENDING'
`

type SumPendingAdvancesByProfessionalParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ProfessionalID pgtype.UUID `json:"professional_id"`
}

func (q *Queries) SumPendingAdvancesByProfessional(ctx context.Context, arg SumPendingAdvancesByProfessionalParams) (decimal.Decimal, error) {
	row := q.db.QueryRow(ctx, sumPendingAdvancesByProfessional, arg.TenantID, arg.ProfessionalID)
	var total decimal.Decimal
	err := row.Scan(&total)
	return total, err
}
