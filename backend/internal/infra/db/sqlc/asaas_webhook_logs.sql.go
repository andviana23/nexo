// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: asaas_webhook_logs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupOldWebhookLogs = `-- name: CleanupOldWebhookLogs :exec
DELETE FROM asaas_webhook_logs
WHERE created_at < NOW() - INTERVAL '90 days'
  AND processed_at IS NOT NULL
`

// Limpar logs antigos (manter últimos 90 dias)
func (q *Queries) CleanupOldWebhookLogs(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupOldWebhookLogs)
	return err
}

const countWebhooksByEventType = `-- name: CountWebhooksByEventType :many
SELECT 
    event_type,
    COUNT(*)::int as total,
    COUNT(*) FILTER (WHERE processed_at IS NOT NULL)::int as processed,
    COUNT(*) FILTER (WHERE processed_at IS NULL AND retry_count >= 5)::int as failed
FROM asaas_webhook_logs
WHERE created_at > NOW() - INTERVAL '30 days'
GROUP BY event_type
ORDER BY total DESC
`

type CountWebhooksByEventTypeRow struct {
	EventType string `json:"event_type"`
	Total     int32  `json:"total"`
	Processed int32  `json:"processed"`
	Failed    int32  `json:"failed"`
}

// Estatísticas de webhooks por tipo (últimos 30 dias)
func (q *Queries) CountWebhooksByEventType(ctx context.Context) ([]CountWebhooksByEventTypeRow, error) {
	rows, err := q.db.Query(ctx, countWebhooksByEventType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountWebhooksByEventTypeRow{}
	for rows.Next() {
		var i CountWebhooksByEventTypeRow
		if err := rows.Scan(
			&i.EventType,
			&i.Total,
			&i.Processed,
			&i.Failed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createReconciliationLog = `-- name: CreateReconciliationLog :one

INSERT INTO asaas_reconciliation_logs (
    tenant_id,
    period_start,
    period_end,
    total_asaas,
    total_nexo,
    divergences,
    auto_fixed,
    pending_review,
    details
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, tenant_id, period_start, period_end, total_asaas, total_nexo, divergences, auto_fixed, pending_review, details, created_at
`

type CreateReconciliationLogParams struct {
	TenantID      pgtype.UUID `json:"tenant_id"`
	PeriodStart   pgtype.Date `json:"period_start"`
	PeriodEnd     pgtype.Date `json:"period_end"`
	TotalAsaas    *int32      `json:"total_asaas"`
	TotalNexo     *int32      `json:"total_nexo"`
	Divergences   *int32      `json:"divergences"`
	AutoFixed     *int32      `json:"auto_fixed"`
	PendingReview *int32      `json:"pending_review"`
	Details       []byte      `json:"details"`
}

// ============================================================
// ASAAS_RECONCILIATION_LOGS (Auditoria de Conciliação)
// ============================================================
// Registrar execução de conciliação
func (q *Queries) CreateReconciliationLog(ctx context.Context, arg CreateReconciliationLogParams) (AsaasReconciliationLog, error) {
	row := q.db.QueryRow(ctx, createReconciliationLog,
		arg.TenantID,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.TotalAsaas,
		arg.TotalNexo,
		arg.Divergences,
		arg.AutoFixed,
		arg.PendingReview,
		arg.Details,
	)
	var i AsaasReconciliationLog
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.TotalAsaas,
		&i.TotalNexo,
		&i.Divergences,
		&i.AutoFixed,
		&i.PendingReview,
		&i.Details,
		&i.CreatedAt,
	)
	return i, err
}

const createWebhookLog = `-- name: CreateWebhookLog :one

INSERT INTO asaas_webhook_logs (
    tenant_id,
    event_type,
    asaas_payment_id,
    asaas_subscription_id,
    payload
) VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, event_type, asaas_payment_id, asaas_subscription_id, payload, processed_at, error_message, retry_count, created_at
`

type CreateWebhookLogParams struct {
	TenantID            pgtype.UUID `json:"tenant_id"`
	EventType           string      `json:"event_type"`
	AsaasPaymentID      *string     `json:"asaas_payment_id"`
	AsaasSubscriptionID *string     `json:"asaas_subscription_id"`
	Payload             []byte      `json:"payload"`
}

// ============================================================
// ASAAS_WEBHOOK_LOGS (Auditoria de Webhooks)
// ============================================================
// Registrar webhook recebido
func (q *Queries) CreateWebhookLog(ctx context.Context, arg CreateWebhookLogParams) (AsaasWebhookLog, error) {
	row := q.db.QueryRow(ctx, createWebhookLog,
		arg.TenantID,
		arg.EventType,
		arg.AsaasPaymentID,
		arg.AsaasSubscriptionID,
		arg.Payload,
	)
	var i AsaasWebhookLog
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EventType,
		&i.AsaasPaymentID,
		&i.AsaasSubscriptionID,
		&i.Payload,
		&i.ProcessedAt,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.CreatedAt,
	)
	return i, err
}

const getLastReconciliation = `-- name: GetLastReconciliation :one
SELECT id, tenant_id, period_start, period_end, total_asaas, total_nexo, divergences, auto_fixed, pending_review, details, created_at FROM asaas_reconciliation_logs
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT 1
`

// Última conciliação executada
func (q *Queries) GetLastReconciliation(ctx context.Context, tenantID pgtype.UUID) (AsaasReconciliationLog, error) {
	row := q.db.QueryRow(ctx, getLastReconciliation, tenantID)
	var i AsaasReconciliationLog
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.TotalAsaas,
		&i.TotalNexo,
		&i.Divergences,
		&i.AutoFixed,
		&i.PendingReview,
		&i.Details,
		&i.CreatedAt,
	)
	return i, err
}

const getReconciliationLogByID = `-- name: GetReconciliationLogByID :one
SELECT id, tenant_id, period_start, period_end, total_asaas, total_nexo, divergences, auto_fixed, pending_review, details, created_at FROM asaas_reconciliation_logs
WHERE id = $1 AND tenant_id = $2
`

type GetReconciliationLogByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetReconciliationLogByID(ctx context.Context, arg GetReconciliationLogByIDParams) (AsaasReconciliationLog, error) {
	row := q.db.QueryRow(ctx, getReconciliationLogByID, arg.ID, arg.TenantID)
	var i AsaasReconciliationLog
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.TotalAsaas,
		&i.TotalNexo,
		&i.Divergences,
		&i.AutoFixed,
		&i.PendingReview,
		&i.Details,
		&i.CreatedAt,
	)
	return i, err
}

const getWebhookLogByID = `-- name: GetWebhookLogByID :one
SELECT id, tenant_id, event_type, asaas_payment_id, asaas_subscription_id, payload, processed_at, error_message, retry_count, created_at FROM asaas_webhook_logs
WHERE id = $1
`

func (q *Queries) GetWebhookLogByID(ctx context.Context, id pgtype.UUID) (AsaasWebhookLog, error) {
	row := q.db.QueryRow(ctx, getWebhookLogByID, id)
	var i AsaasWebhookLog
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EventType,
		&i.AsaasPaymentID,
		&i.AsaasSubscriptionID,
		&i.Payload,
		&i.ProcessedAt,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.CreatedAt,
	)
	return i, err
}

const getWebhookLogByPaymentID = `-- name: GetWebhookLogByPaymentID :one
SELECT id, tenant_id, event_type, asaas_payment_id, asaas_subscription_id, payload, processed_at, error_message, retry_count, created_at FROM asaas_webhook_logs
WHERE asaas_payment_id = $1
  AND event_type = $2
  AND processed_at IS NOT NULL
ORDER BY created_at DESC
LIMIT 1
`

type GetWebhookLogByPaymentIDParams struct {
	AsaasPaymentID *string `json:"asaas_payment_id"`
	EventType      string  `json:"event_type"`
}

// Buscar log por payment ID (para verificar duplicatas)
func (q *Queries) GetWebhookLogByPaymentID(ctx context.Context, arg GetWebhookLogByPaymentIDParams) (AsaasWebhookLog, error) {
	row := q.db.QueryRow(ctx, getWebhookLogByPaymentID, arg.AsaasPaymentID, arg.EventType)
	var i AsaasWebhookLog
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EventType,
		&i.AsaasPaymentID,
		&i.AsaasSubscriptionID,
		&i.Payload,
		&i.ProcessedAt,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.CreatedAt,
	)
	return i, err
}

const listReconciliationLogs = `-- name: ListReconciliationLogs :many
SELECT id, tenant_id, period_start, period_end, total_asaas, total_nexo, divergences, auto_fixed, pending_review, details, created_at FROM asaas_reconciliation_logs
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListReconciliationLogsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

// Listar logs de conciliação
func (q *Queries) ListReconciliationLogs(ctx context.Context, arg ListReconciliationLogsParams) ([]AsaasReconciliationLog, error) {
	rows, err := q.db.Query(ctx, listReconciliationLogs, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AsaasReconciliationLog{}
	for rows.Next() {
		var i AsaasReconciliationLog
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.TotalAsaas,
			&i.TotalNexo,
			&i.Divergences,
			&i.AutoFixed,
			&i.PendingReview,
			&i.Details,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnprocessedWebhooks = `-- name: ListUnprocessedWebhooks :many
SELECT id, tenant_id, event_type, asaas_payment_id, asaas_subscription_id, payload, processed_at, error_message, retry_count, created_at FROM asaas_webhook_logs
WHERE processed_at IS NULL
  AND retry_count < 5
  AND created_at > NOW() - INTERVAL '7 days'
ORDER BY created_at ASC
LIMIT $1
`

// Listar webhooks não processados (para retry)
func (q *Queries) ListUnprocessedWebhooks(ctx context.Context, limit int32) ([]AsaasWebhookLog, error) {
	rows, err := q.db.Query(ctx, listUnprocessedWebhooks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AsaasWebhookLog{}
	for rows.Next() {
		var i AsaasWebhookLog
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EventType,
			&i.AsaasPaymentID,
			&i.AsaasSubscriptionID,
			&i.Payload,
			&i.ProcessedAt,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhooksByPaymentID = `-- name: ListWebhooksByPaymentID :many
SELECT id, tenant_id, event_type, asaas_payment_id, asaas_subscription_id, payload, processed_at, error_message, retry_count, created_at FROM asaas_webhook_logs
WHERE asaas_payment_id = $1
ORDER BY created_at DESC
`

// Histórico de webhooks de um payment
func (q *Queries) ListWebhooksByPaymentID(ctx context.Context, asaasPaymentID *string) ([]AsaasWebhookLog, error) {
	rows, err := q.db.Query(ctx, listWebhooksByPaymentID, asaasPaymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AsaasWebhookLog{}
	for rows.Next() {
		var i AsaasWebhookLog
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EventType,
			&i.AsaasPaymentID,
			&i.AsaasSubscriptionID,
			&i.Payload,
			&i.ProcessedAt,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhooksBySubscriptionID = `-- name: ListWebhooksBySubscriptionID :many
SELECT id, tenant_id, event_type, asaas_payment_id, asaas_subscription_id, payload, processed_at, error_message, retry_count, created_at FROM asaas_webhook_logs
WHERE asaas_subscription_id = $1
ORDER BY created_at DESC
`

// Histórico de webhooks de uma subscription
func (q *Queries) ListWebhooksBySubscriptionID(ctx context.Context, asaasSubscriptionID *string) ([]AsaasWebhookLog, error) {
	rows, err := q.db.Query(ctx, listWebhooksBySubscriptionID, asaasSubscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AsaasWebhookLog{}
	for rows.Next() {
		var i AsaasWebhookLog
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EventType,
			&i.AsaasPaymentID,
			&i.AsaasSubscriptionID,
			&i.Payload,
			&i.ProcessedAt,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhooksByTenant = `-- name: ListWebhooksByTenant :many
SELECT id, tenant_id, event_type, asaas_payment_id, asaas_subscription_id, payload, processed_at, error_message, retry_count, created_at FROM asaas_webhook_logs
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListWebhooksByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

// Listar webhooks por tenant (para auditoria)
func (q *Queries) ListWebhooksByTenant(ctx context.Context, arg ListWebhooksByTenantParams) ([]AsaasWebhookLog, error) {
	rows, err := q.db.Query(ctx, listWebhooksByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AsaasWebhookLog{}
	for rows.Next() {
		var i AsaasWebhookLog
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EventType,
			&i.AsaasPaymentID,
			&i.AsaasSubscriptionID,
			&i.Payload,
			&i.ProcessedAt,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markWebhookFailed = `-- name: MarkWebhookFailed :exec
UPDATE asaas_webhook_logs SET
    error_message = $2,
    retry_count = retry_count + 1
WHERE id = $1
`

type MarkWebhookFailedParams struct {
	ID           pgtype.UUID `json:"id"`
	ErrorMessage *string     `json:"error_message"`
}

// Marcar webhook como falha
func (q *Queries) MarkWebhookFailed(ctx context.Context, arg MarkWebhookFailedParams) error {
	_, err := q.db.Exec(ctx, markWebhookFailed, arg.ID, arg.ErrorMessage)
	return err
}

const markWebhookProcessed = `-- name: MarkWebhookProcessed :exec
UPDATE asaas_webhook_logs SET
    processed_at = NOW()
WHERE id = $1
`

// Marcar webhook como processado com sucesso
func (q *Queries) MarkWebhookProcessed(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markWebhookProcessed, id)
	return err
}

const sumReconciliationDivergences = `-- name: SumReconciliationDivergences :one
SELECT 
    COALESCE(SUM(divergences), 0)::int as total_divergences,
    COALESCE(SUM(auto_fixed), 0)::int as total_auto_fixed,
    COALESCE(SUM(pending_review), 0)::int as total_pending_review
FROM asaas_reconciliation_logs
WHERE tenant_id = $1
  AND created_at >= $2
  AND created_at <= $3
`

type SumReconciliationDivergencesParams struct {
	TenantID    pgtype.UUID        `json:"tenant_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type SumReconciliationDivergencesRow struct {
	TotalDivergences   int32 `json:"total_divergences"`
	TotalAutoFixed     int32 `json:"total_auto_fixed"`
	TotalPendingReview int32 `json:"total_pending_review"`
}

// Somar divergências do período
func (q *Queries) SumReconciliationDivergences(ctx context.Context, arg SumReconciliationDivergencesParams) (SumReconciliationDivergencesRow, error) {
	row := q.db.QueryRow(ctx, sumReconciliationDivergences, arg.TenantID, arg.CreatedAt, arg.CreatedAt_2)
	var i SumReconciliationDivergencesRow
	err := row.Scan(&i.TotalDivergences, &i.TotalAutoFixed, &i.TotalPendingReview)
	return i, err
}
