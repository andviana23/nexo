// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_units.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BulkCreateUserUnitsParams struct {
	UserID       pgtype.UUID `json:"user_id"`
	UnitID       pgtype.UUID `json:"unit_id"`
	IsDefault    bool        `json:"is_default"`
	RoleOverride *string     `json:"role_override"`
}

const checkUserUnitAccess = `-- name: CheckUserUnitAccess :one
SELECT EXISTS(
    SELECT 1 FROM user_units uu
    JOIN units u ON u.id = uu.unit_id
    WHERE uu.user_id = $1 
      AND uu.unit_id = $2
      AND u.ativa = true
) as has_access
`

type CheckUserUnitAccessParams struct {
	UserID pgtype.UUID `json:"user_id"`
	UnitID pgtype.UUID `json:"unit_id"`
}

func (q *Queries) CheckUserUnitAccess(ctx context.Context, arg CheckUserUnitAccessParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserUnitAccess, arg.UserID, arg.UnitID)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const countUnitUsers = `-- name: CountUnitUsers :one
SELECT COUNT(*) FROM user_units
WHERE unit_id = $1
`

func (q *Queries) CountUnitUsers(ctx context.Context, unitID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUnitUsers, unitID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserUnits = `-- name: CountUserUnits :one
SELECT COUNT(*) FROM user_units
WHERE user_id = $1
`

func (q *Queries) CountUserUnits(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserUnits, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUserUnit = `-- name: CreateUserUnit :one

INSERT INTO user_units (
    user_id,
    unit_id,
    is_default,
    role_override
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, user_id, unit_id, is_default, role_override, criado_em, atualizado_em
`

type CreateUserUnitParams struct {
	UserID       pgtype.UUID `json:"user_id"`
	UnitID       pgtype.UUID `json:"unit_id"`
	IsDefault    bool        `json:"is_default"`
	RoleOverride *string     `json:"role_override"`
}

// ============================================================================
// SQLC Queries: User Units (Vínculo Usuário-Unidade)
// ============================================================================
func (q *Queries) CreateUserUnit(ctx context.Context, arg CreateUserUnitParams) (UserUnit, error) {
	row := q.db.QueryRow(ctx, createUserUnit,
		arg.UserID,
		arg.UnitID,
		arg.IsDefault,
		arg.RoleOverride,
	)
	var i UserUnit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UnitID,
		&i.IsDefault,
		&i.RoleOverride,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const deleteAllUnitUsers = `-- name: DeleteAllUnitUsers :exec
DELETE FROM user_units
WHERE unit_id = $1
`

func (q *Queries) DeleteAllUnitUsers(ctx context.Context, unitID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllUnitUsers, unitID)
	return err
}

const deleteAllUserUnits = `-- name: DeleteAllUserUnits :exec
DELETE FROM user_units
WHERE user_id = $1
`

func (q *Queries) DeleteAllUserUnits(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllUserUnits, userID)
	return err
}

const deleteUserUnit = `-- name: DeleteUserUnit :exec
DELETE FROM user_units
WHERE user_id = $1 AND unit_id = $2
`

type DeleteUserUnitParams struct {
	UserID pgtype.UUID `json:"user_id"`
	UnitID pgtype.UUID `json:"unit_id"`
}

func (q *Queries) DeleteUserUnit(ctx context.Context, arg DeleteUserUnitParams) error {
	_, err := q.db.Exec(ctx, deleteUserUnit, arg.UserID, arg.UnitID)
	return err
}

const getUserDefaultUnit = `-- name: GetUserDefaultUnit :one
SELECT uu.id, uu.user_id, uu.unit_id, uu.is_default, uu.role_override, uu.criado_em, uu.atualizado_em, u.nome as unit_nome, u.apelido as unit_apelido, u.tenant_id
FROM user_units uu
JOIN units u ON u.id = uu.unit_id
WHERE uu.user_id = $1 AND uu.is_default = true
LIMIT 1
`

type GetUserDefaultUnitRow struct {
	ID           pgtype.UUID        `json:"id"`
	UserID       pgtype.UUID        `json:"user_id"`
	UnitID       pgtype.UUID        `json:"unit_id"`
	IsDefault    bool               `json:"is_default"`
	RoleOverride *string            `json:"role_override"`
	CriadoEm     pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm pgtype.Timestamptz `json:"atualizado_em"`
	UnitNome     string             `json:"unit_nome"`
	UnitApelido  *string            `json:"unit_apelido"`
	TenantID     pgtype.UUID        `json:"tenant_id"`
}

func (q *Queries) GetUserDefaultUnit(ctx context.Context, userID pgtype.UUID) (GetUserDefaultUnitRow, error) {
	row := q.db.QueryRow(ctx, getUserDefaultUnit, userID)
	var i GetUserDefaultUnitRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UnitID,
		&i.IsDefault,
		&i.RoleOverride,
		&i.CriadoEm,
		&i.AtualizadoEm,
		&i.UnitNome,
		&i.UnitApelido,
		&i.TenantID,
	)
	return i, err
}

const getUserUnit = `-- name: GetUserUnit :one
SELECT id, user_id, unit_id, is_default, role_override, criado_em, atualizado_em FROM user_units
WHERE user_id = $1 AND unit_id = $2
`

type GetUserUnitParams struct {
	UserID pgtype.UUID `json:"user_id"`
	UnitID pgtype.UUID `json:"unit_id"`
}

func (q *Queries) GetUserUnit(ctx context.Context, arg GetUserUnitParams) (UserUnit, error) {
	row := q.db.QueryRow(ctx, getUserUnit, arg.UserID, arg.UnitID)
	var i UserUnit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UnitID,
		&i.IsDefault,
		&i.RoleOverride,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const listUnitUsers = `-- name: ListUnitUsers :many
SELECT 
    uu.id, uu.user_id, uu.unit_id, uu.is_default, uu.role_override, uu.criado_em, uu.atualizado_em,
    usr.nome as user_nome,
    usr.email as user_email,
    usr.role as user_role
FROM user_units uu
JOIN users usr ON usr.id = uu.user_id
WHERE uu.unit_id = $1
ORDER BY usr.nome
`

type ListUnitUsersRow struct {
	ID           pgtype.UUID        `json:"id"`
	UserID       pgtype.UUID        `json:"user_id"`
	UnitID       pgtype.UUID        `json:"unit_id"`
	IsDefault    bool               `json:"is_default"`
	RoleOverride *string            `json:"role_override"`
	CriadoEm     pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm pgtype.Timestamptz `json:"atualizado_em"`
	UserNome     string             `json:"user_nome"`
	UserEmail    string             `json:"user_email"`
	UserRole     string             `json:"user_role"`
}

func (q *Queries) ListUnitUsers(ctx context.Context, unitID pgtype.UUID) ([]ListUnitUsersRow, error) {
	rows, err := q.db.Query(ctx, listUnitUsers, unitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUnitUsersRow{}
	for rows.Next() {
		var i ListUnitUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UnitID,
			&i.IsDefault,
			&i.RoleOverride,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.UserNome,
			&i.UserEmail,
			&i.UserRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserUnits = `-- name: ListUserUnits :many
SELECT 
    uu.id, uu.user_id, uu.unit_id, uu.is_default, uu.role_override, uu.criado_em, uu.atualizado_em,
    u.nome as unit_nome,
    u.apelido as unit_apelido,
    u.is_matriz,
    u.ativa as unit_ativa,
    u.tenant_id
FROM user_units uu
JOIN units u ON u.id = uu.unit_id
WHERE uu.user_id = $1 AND u.ativa = true
ORDER BY uu.is_default DESC, u.is_matriz DESC, u.nome
`

type ListUserUnitsRow struct {
	ID           pgtype.UUID        `json:"id"`
	UserID       pgtype.UUID        `json:"user_id"`
	UnitID       pgtype.UUID        `json:"unit_id"`
	IsDefault    bool               `json:"is_default"`
	RoleOverride *string            `json:"role_override"`
	CriadoEm     pgtype.Timestamptz `json:"criado_em"`
	AtualizadoEm pgtype.Timestamptz `json:"atualizado_em"`
	UnitNome     string             `json:"unit_nome"`
	UnitApelido  *string            `json:"unit_apelido"`
	IsMatriz     bool               `json:"is_matriz"`
	UnitAtiva    bool               `json:"unit_ativa"`
	TenantID     pgtype.UUID        `json:"tenant_id"`
}

func (q *Queries) ListUserUnits(ctx context.Context, userID pgtype.UUID) ([]ListUserUnitsRow, error) {
	rows, err := q.db.Query(ctx, listUserUnits, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserUnitsRow{}
	for rows.Next() {
		var i ListUserUnitsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UnitID,
			&i.IsDefault,
			&i.RoleOverride,
			&i.CriadoEm,
			&i.AtualizadoEm,
			&i.UnitNome,
			&i.UnitApelido,
			&i.IsMatriz,
			&i.UnitAtiva,
			&i.TenantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setUserDefaultUnit = `-- name: SetUserDefaultUnit :exec
UPDATE user_units
SET is_default = CASE WHEN unit_id = $2 THEN true ELSE false END,
    atualizado_em = NOW()
WHERE user_id = $1
`

type SetUserDefaultUnitParams struct {
	UserID pgtype.UUID `json:"user_id"`
	UnitID pgtype.UUID `json:"unit_id"`
}

func (q *Queries) SetUserDefaultUnit(ctx context.Context, arg SetUserDefaultUnitParams) error {
	_, err := q.db.Exec(ctx, setUserDefaultUnit, arg.UserID, arg.UnitID)
	return err
}

const updateUserUnitRole = `-- name: UpdateUserUnitRole :one
UPDATE user_units
SET role_override = $3, atualizado_em = NOW()
WHERE user_id = $1 AND unit_id = $2
RETURNING id, user_id, unit_id, is_default, role_override, criado_em, atualizado_em
`

type UpdateUserUnitRoleParams struct {
	UserID       pgtype.UUID `json:"user_id"`
	UnitID       pgtype.UUID `json:"unit_id"`
	RoleOverride *string     `json:"role_override"`
}

func (q *Queries) UpdateUserUnitRole(ctx context.Context, arg UpdateUserUnitRoleParams) (UserUnit, error) {
	row := q.db.QueryRow(ctx, updateUserUnitRole, arg.UserID, arg.UnitID, arg.RoleOverride)
	var i UserUnit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UnitID,
		&i.IsDefault,
		&i.RoleOverride,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}
