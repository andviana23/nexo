// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: appointments.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const checkAppointmentConflict = `-- name: CheckAppointmentConflict :one
SELECT EXISTS (
    SELECT 1 FROM appointments
    WHERE tenant_id = $1
      AND professional_id = $2
      AND id != $3
      AND status NOT IN ('CANCELED', 'NO_SHOW')
      AND start_time < $5
      AND end_time > $4
) as has_conflict
`

type CheckAppointmentConflictParams struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	ProfessionalID pgtype.UUID        `json:"professional_id"`
	ID             pgtype.UUID        `json:"id"`
	EndTime        pgtype.Timestamptz `json:"end_time"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
}

func (q *Queries) CheckAppointmentConflict(ctx context.Context, arg CheckAppointmentConflictParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkAppointmentConflict,
		arg.TenantID,
		arg.ProfessionalID,
		arg.ID,
		arg.EndTime,
		arg.StartTime,
	)
	var has_conflict bool
	err := row.Scan(&has_conflict)
	return has_conflict, err
}

const countAppointments = `-- name: CountAppointments :one
SELECT COUNT(*)
FROM appointments a
WHERE a.tenant_id = $1
  AND ($2::uuid IS NULL OR a.professional_id = $2)
  AND ($3::uuid IS NULL OR a.customer_id = $3)
  AND ($4::text IS NULL OR a.status = $4)
  AND ($5::timestamptz IS NULL OR a.start_time >= $5)
  AND ($6::timestamptz IS NULL OR a.start_time < $6)
`

type CountAppointmentsParams struct {
	TenantID pgtype.UUID        `json:"tenant_id"`
	Column2  pgtype.UUID        `json:"column_2"`
	Column3  pgtype.UUID        `json:"column_3"`
	Column4  string             `json:"column_4"`
	Column5  pgtype.Timestamptz `json:"column_5"`
	Column6  pgtype.Timestamptz `json:"column_6"`
}

func (q *Queries) CountAppointments(ctx context.Context, arg CountAppointmentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAppointments,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAppointmentsByStatus = `-- name: CountAppointmentsByStatus :one
SELECT COUNT(*)
FROM appointments
WHERE tenant_id = $1 AND status = $2
`

type CountAppointmentsByStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
}

func (q *Queries) CountAppointmentsByStatus(ctx context.Context, arg CountAppointmentsByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAppointmentsByStatus, arg.TenantID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAppointment = `-- name: CreateAppointment :one

INSERT INTO appointments (
    id,
    tenant_id,
    professional_id,
    customer_id,
    start_time,
    end_time,
    status,
    total_price,
    notes,
    canceled_reason,
    google_calendar_event_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, tenant_id, professional_id, customer_id, start_time, end_time, status, total_price, notes, canceled_reason, google_calendar_event_id, created_at, updated_at
`

type CreateAppointmentParams struct {
	ID                    pgtype.UUID        `json:"id"`
	TenantID              pgtype.UUID        `json:"tenant_id"`
	ProfessionalID        pgtype.UUID        `json:"professional_id"`
	CustomerID            pgtype.UUID        `json:"customer_id"`
	StartTime             pgtype.Timestamptz `json:"start_time"`
	EndTime               pgtype.Timestamptz `json:"end_time"`
	Status                string             `json:"status"`
	TotalPrice            decimal.Decimal    `json:"total_price"`
	Notes                 *string            `json:"notes"`
	CanceledReason        *string            `json:"canceled_reason"`
	GoogleCalendarEventID *string            `json:"google_calendar_event_id"`
}

// ============================================================================
// APPOINTMENTS QUERIES (sqlc)
// Módulo de Agendamento — NEXO v1.0
// ============================================================================
func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, createAppointment,
		arg.ID,
		arg.TenantID,
		arg.ProfessionalID,
		arg.CustomerID,
		arg.StartTime,
		arg.EndTime,
		arg.Status,
		arg.TotalPrice,
		arg.Notes,
		arg.CanceledReason,
		arg.GoogleCalendarEventID,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CustomerID,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.TotalPrice,
		&i.Notes,
		&i.CanceledReason,
		&i.GoogleCalendarEventID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createAppointmentService = `-- name: CreateAppointmentService :exec
INSERT INTO appointment_services (
    appointment_id,
    service_id,
    price_at_booking,
    duration_at_booking
) VALUES (
    $1, $2, $3, $4
)
`

type CreateAppointmentServiceParams struct {
	AppointmentID     pgtype.UUID     `json:"appointment_id"`
	ServiceID         pgtype.UUID     `json:"service_id"`
	PriceAtBooking    decimal.Decimal `json:"price_at_booking"`
	DurationAtBooking int32           `json:"duration_at_booking"`
}

func (q *Queries) CreateAppointmentService(ctx context.Context, arg CreateAppointmentServiceParams) error {
	_, err := q.db.Exec(ctx, createAppointmentService,
		arg.AppointmentID,
		arg.ServiceID,
		arg.PriceAtBooking,
		arg.DurationAtBooking,
	)
	return err
}

const customerExists = `-- name: CustomerExists :one
SELECT EXISTS (
    SELECT 1 FROM clientes
    WHERE id = $1 AND tenant_id = $2 AND ativo = true
) as exists
`

type CustomerExistsParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) CustomerExists(ctx context.Context, arg CustomerExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, customerExists, arg.ID, arg.TenantID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const deleteAppointment = `-- name: DeleteAppointment :exec
UPDATE appointments
SET
    status = 'CANCELED',
    canceled_reason = 'Removido pelo sistema',
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type DeleteAppointmentParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteAppointment(ctx context.Context, arg DeleteAppointmentParams) error {
	_, err := q.db.Exec(ctx, deleteAppointment, arg.ID, arg.TenantID)
	return err
}

const deleteAppointmentServices = `-- name: DeleteAppointmentServices :exec
DELETE FROM appointment_services
WHERE appointment_id = $1
`

func (q *Queries) DeleteAppointmentServices(ctx context.Context, appointmentID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAppointmentServices, appointmentID)
	return err
}

const getAppointmentByID = `-- name: GetAppointmentByID :one
SELECT 
    a.id, a.tenant_id, a.professional_id, a.customer_id, a.start_time, a.end_time, a.status, a.total_price, a.notes, a.canceled_reason, a.google_calendar_event_id, a.created_at, a.updated_at,
    p.nome as professional_name,
    c.nome as customer_name,
    c.telefone as customer_phone
FROM appointments a
JOIN profissionais p ON p.id = a.professional_id
JOIN clientes c ON c.id = a.customer_id
WHERE a.id = $1 AND a.tenant_id = $2
`

type GetAppointmentByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetAppointmentByIDRow struct {
	ID                    pgtype.UUID        `json:"id"`
	TenantID              pgtype.UUID        `json:"tenant_id"`
	ProfessionalID        pgtype.UUID        `json:"professional_id"`
	CustomerID            pgtype.UUID        `json:"customer_id"`
	StartTime             pgtype.Timestamptz `json:"start_time"`
	EndTime               pgtype.Timestamptz `json:"end_time"`
	Status                string             `json:"status"`
	TotalPrice            decimal.Decimal    `json:"total_price"`
	Notes                 *string            `json:"notes"`
	CanceledReason        *string            `json:"canceled_reason"`
	GoogleCalendarEventID *string            `json:"google_calendar_event_id"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	ProfessionalName      string             `json:"professional_name"`
	CustomerName          string             `json:"customer_name"`
	CustomerPhone         string             `json:"customer_phone"`
}

func (q *Queries) GetAppointmentByID(ctx context.Context, arg GetAppointmentByIDParams) (GetAppointmentByIDRow, error) {
	row := q.db.QueryRow(ctx, getAppointmentByID, arg.ID, arg.TenantID)
	var i GetAppointmentByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CustomerID,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.TotalPrice,
		&i.Notes,
		&i.CanceledReason,
		&i.GoogleCalendarEventID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProfessionalName,
		&i.CustomerName,
		&i.CustomerPhone,
	)
	return i, err
}

const getAppointmentServices = `-- name: GetAppointmentServices :many
SELECT 
    aps.appointment_id, aps.service_id, aps.price_at_booking, aps.duration_at_booking, aps.created_at,
    s.nome as service_name
FROM appointment_services aps
JOIN servicos s ON s.id = aps.service_id
WHERE aps.appointment_id = $1
`

type GetAppointmentServicesRow struct {
	AppointmentID     pgtype.UUID        `json:"appointment_id"`
	ServiceID         pgtype.UUID        `json:"service_id"`
	PriceAtBooking    decimal.Decimal    `json:"price_at_booking"`
	DurationAtBooking int32              `json:"duration_at_booking"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	ServiceName       string             `json:"service_name"`
}

func (q *Queries) GetAppointmentServices(ctx context.Context, appointmentID pgtype.UUID) ([]GetAppointmentServicesRow, error) {
	rows, err := q.db.Query(ctx, getAppointmentServices, appointmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAppointmentServicesRow{}
	for rows.Next() {
		var i GetAppointmentServicesRow
		if err := rows.Scan(
			&i.AppointmentID,
			&i.ServiceID,
			&i.PriceAtBooking,
			&i.DurationAtBooking,
			&i.CreatedAt,
			&i.ServiceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerInfo = `-- name: GetCustomerInfo :one
SELECT id, nome, telefone, email
FROM clientes
WHERE id = $1 AND tenant_id = $2
`

type GetCustomerInfoParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetCustomerInfoRow struct {
	ID       pgtype.UUID `json:"id"`
	Nome     string      `json:"nome"`
	Telefone string      `json:"telefone"`
	Email    *string     `json:"email"`
}

func (q *Queries) GetCustomerInfo(ctx context.Context, arg GetCustomerInfoParams) (GetCustomerInfoRow, error) {
	row := q.db.QueryRow(ctx, getCustomerInfo, arg.ID, arg.TenantID)
	var i GetCustomerInfoRow
	err := row.Scan(
		&i.ID,
		&i.Nome,
		&i.Telefone,
		&i.Email,
	)
	return i, err
}

const getDailyAppointmentStats = `-- name: GetDailyAppointmentStats :one
SELECT 
    COUNT(*) as total_appointments,
    COUNT(*) FILTER (WHERE status = 'DONE') as completed_count,
    COUNT(*) FILTER (WHERE status = 'CANCELED') as canceled_count,
    COUNT(*) FILTER (WHERE status = 'NO_SHOW') as no_show_count,
    COALESCE(SUM(total_price) FILTER (WHERE status = 'DONE'), 0) as total_revenue
FROM appointments
WHERE tenant_id = $1
  AND start_time >= $2
  AND start_time < $3
`

type GetDailyAppointmentStatsParams struct {
	TenantID    pgtype.UUID        `json:"tenant_id"`
	StartTime   pgtype.Timestamptz `json:"start_time"`
	StartTime_2 pgtype.Timestamptz `json:"start_time_2"`
}

type GetDailyAppointmentStatsRow struct {
	TotalAppointments int64       `json:"total_appointments"`
	CompletedCount    int64       `json:"completed_count"`
	CanceledCount     int64       `json:"canceled_count"`
	NoShowCount       int64       `json:"no_show_count"`
	TotalRevenue      interface{} `json:"total_revenue"`
}

func (q *Queries) GetDailyAppointmentStats(ctx context.Context, arg GetDailyAppointmentStatsParams) (GetDailyAppointmentStatsRow, error) {
	row := q.db.QueryRow(ctx, getDailyAppointmentStats, arg.TenantID, arg.StartTime, arg.StartTime_2)
	var i GetDailyAppointmentStatsRow
	err := row.Scan(
		&i.TotalAppointments,
		&i.CompletedCount,
		&i.CanceledCount,
		&i.NoShowCount,
		&i.TotalRevenue,
	)
	return i, err
}

const getProfessionalInfo = `-- name: GetProfessionalInfo :one
SELECT id, nome, status, cor
FROM profissionais
WHERE id = $1 AND tenant_id = $2
`

type GetProfessionalInfoParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetProfessionalInfoRow struct {
	ID     pgtype.UUID `json:"id"`
	Nome   string      `json:"nome"`
	Status *string     `json:"status"`
	Cor    *string     `json:"cor"`
}

func (q *Queries) GetProfessionalInfo(ctx context.Context, arg GetProfessionalInfoParams) (GetProfessionalInfoRow, error) {
	row := q.db.QueryRow(ctx, getProfessionalInfo, arg.ID, arg.TenantID)
	var i GetProfessionalInfoRow
	err := row.Scan(
		&i.ID,
		&i.Nome,
		&i.Status,
		&i.Cor,
	)
	return i, err
}

const getServiceInfo = `-- name: GetServiceInfo :one
SELECT id, nome, preco, duracao, ativo
FROM servicos
WHERE id = $1 AND tenant_id = $2
`

type GetServiceInfoParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetServiceInfoRow struct {
	ID      pgtype.UUID     `json:"id"`
	Nome    string          `json:"nome"`
	Preco   decimal.Decimal `json:"preco"`
	Duracao int32           `json:"duracao"`
	Ativo   *bool           `json:"ativo"`
}

func (q *Queries) GetServiceInfo(ctx context.Context, arg GetServiceInfoParams) (GetServiceInfoRow, error) {
	row := q.db.QueryRow(ctx, getServiceInfo, arg.ID, arg.TenantID)
	var i GetServiceInfoRow
	err := row.Scan(
		&i.ID,
		&i.Nome,
		&i.Preco,
		&i.Duracao,
		&i.Ativo,
	)
	return i, err
}

const getServicesByIDs = `-- name: GetServicesByIDs :many
SELECT id, nome, preco, duracao, ativo
FROM servicos
WHERE tenant_id = $1 AND id = ANY($2::uuid[])
ORDER BY nome ASC
`

type GetServicesByIDsParams struct {
	TenantID pgtype.UUID   `json:"tenant_id"`
	Column2  []pgtype.UUID `json:"column_2"`
}

type GetServicesByIDsRow struct {
	ID      pgtype.UUID     `json:"id"`
	Nome    string          `json:"nome"`
	Preco   decimal.Decimal `json:"preco"`
	Duracao int32           `json:"duracao"`
	Ativo   *bool           `json:"ativo"`
}

func (q *Queries) GetServicesByIDs(ctx context.Context, arg GetServicesByIDsParams) ([]GetServicesByIDsRow, error) {
	rows, err := q.db.Query(ctx, getServicesByIDs, arg.TenantID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetServicesByIDsRow{}
	for rows.Next() {
		var i GetServicesByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Nome,
			&i.Preco,
			&i.Duracao,
			&i.Ativo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveProfessionals = `-- name: ListActiveProfessionals :many
SELECT id, nome, status, cor
FROM profissionais
WHERE tenant_id = $1 AND status = 'ATIVO'
ORDER BY nome ASC
`

type ListActiveProfessionalsRow struct {
	ID     pgtype.UUID `json:"id"`
	Nome   string      `json:"nome"`
	Status *string     `json:"status"`
	Cor    *string     `json:"cor"`
}

func (q *Queries) ListActiveProfessionals(ctx context.Context, tenantID pgtype.UUID) ([]ListActiveProfessionalsRow, error) {
	rows, err := q.db.Query(ctx, listActiveProfessionals, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveProfessionalsRow{}
	for rows.Next() {
		var i ListActiveProfessionalsRow
		if err := rows.Scan(
			&i.ID,
			&i.Nome,
			&i.Status,
			&i.Cor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppointments = `-- name: ListAppointments :many
SELECT 
    a.id, a.tenant_id, a.professional_id, a.customer_id, a.start_time, a.end_time, a.status, a.total_price, a.notes, a.canceled_reason, a.google_calendar_event_id, a.created_at, a.updated_at,
    p.nome as professional_name,
    c.nome as customer_name,
    c.telefone as customer_phone
FROM appointments a
JOIN profissionais p ON p.id = a.professional_id
JOIN clientes c ON c.id = a.customer_id
WHERE a.tenant_id = $1
  AND ($2::uuid IS NULL OR a.professional_id = $2)
  AND ($3::uuid IS NULL OR a.customer_id = $3)
  AND ($4::text IS NULL OR a.status = $4)
  AND ($5::timestamptz IS NULL OR a.start_time >= $5)
  AND ($6::timestamptz IS NULL OR a.start_time < $6)
ORDER BY a.start_time DESC
LIMIT $7 OFFSET $8
`

type ListAppointmentsParams struct {
	TenantID pgtype.UUID        `json:"tenant_id"`
	Column2  pgtype.UUID        `json:"column_2"`
	Column3  pgtype.UUID        `json:"column_3"`
	Column4  string             `json:"column_4"`
	Column5  pgtype.Timestamptz `json:"column_5"`
	Column6  pgtype.Timestamptz `json:"column_6"`
	Limit    int32              `json:"limit"`
	Offset   int32              `json:"offset"`
}

type ListAppointmentsRow struct {
	ID                    pgtype.UUID        `json:"id"`
	TenantID              pgtype.UUID        `json:"tenant_id"`
	ProfessionalID        pgtype.UUID        `json:"professional_id"`
	CustomerID            pgtype.UUID        `json:"customer_id"`
	StartTime             pgtype.Timestamptz `json:"start_time"`
	EndTime               pgtype.Timestamptz `json:"end_time"`
	Status                string             `json:"status"`
	TotalPrice            decimal.Decimal    `json:"total_price"`
	Notes                 *string            `json:"notes"`
	CanceledReason        *string            `json:"canceled_reason"`
	GoogleCalendarEventID *string            `json:"google_calendar_event_id"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	ProfessionalName      string             `json:"professional_name"`
	CustomerName          string             `json:"customer_name"`
	CustomerPhone         string             `json:"customer_phone"`
}

func (q *Queries) ListAppointments(ctx context.Context, arg ListAppointmentsParams) ([]ListAppointmentsRow, error) {
	rows, err := q.db.Query(ctx, listAppointments,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAppointmentsRow{}
	for rows.Next() {
		var i ListAppointmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProfessionalID,
			&i.CustomerID,
			&i.StartTime,
			&i.EndTime,
			&i.Status,
			&i.TotalPrice,
			&i.Notes,
			&i.CanceledReason,
			&i.GoogleCalendarEventID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProfessionalName,
			&i.CustomerName,
			&i.CustomerPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppointmentsByCustomer = `-- name: ListAppointmentsByCustomer :many
SELECT 
    a.id, a.tenant_id, a.professional_id, a.customer_id, a.start_time, a.end_time, a.status, a.total_price, a.notes, a.canceled_reason, a.google_calendar_event_id, a.created_at, a.updated_at,
    p.nome as professional_name,
    c.nome as customer_name,
    c.telefone as customer_phone
FROM appointments a
JOIN profissionais p ON p.id = a.professional_id
JOIN clientes c ON c.id = a.customer_id
WHERE a.tenant_id = $1
  AND a.customer_id = $2
ORDER BY a.start_time DESC
LIMIT 50
`

type ListAppointmentsByCustomerParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	CustomerID pgtype.UUID `json:"customer_id"`
}

type ListAppointmentsByCustomerRow struct {
	ID                    pgtype.UUID        `json:"id"`
	TenantID              pgtype.UUID        `json:"tenant_id"`
	ProfessionalID        pgtype.UUID        `json:"professional_id"`
	CustomerID            pgtype.UUID        `json:"customer_id"`
	StartTime             pgtype.Timestamptz `json:"start_time"`
	EndTime               pgtype.Timestamptz `json:"end_time"`
	Status                string             `json:"status"`
	TotalPrice            decimal.Decimal    `json:"total_price"`
	Notes                 *string            `json:"notes"`
	CanceledReason        *string            `json:"canceled_reason"`
	GoogleCalendarEventID *string            `json:"google_calendar_event_id"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	ProfessionalName      string             `json:"professional_name"`
	CustomerName          string             `json:"customer_name"`
	CustomerPhone         string             `json:"customer_phone"`
}

func (q *Queries) ListAppointmentsByCustomer(ctx context.Context, arg ListAppointmentsByCustomerParams) ([]ListAppointmentsByCustomerRow, error) {
	rows, err := q.db.Query(ctx, listAppointmentsByCustomer, arg.TenantID, arg.CustomerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAppointmentsByCustomerRow{}
	for rows.Next() {
		var i ListAppointmentsByCustomerRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProfessionalID,
			&i.CustomerID,
			&i.StartTime,
			&i.EndTime,
			&i.Status,
			&i.TotalPrice,
			&i.Notes,
			&i.CanceledReason,
			&i.GoogleCalendarEventID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProfessionalName,
			&i.CustomerName,
			&i.CustomerPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppointmentsByProfessionalAndDateRange = `-- name: ListAppointmentsByProfessionalAndDateRange :many
SELECT 
    a.id, a.tenant_id, a.professional_id, a.customer_id, a.start_time, a.end_time, a.status, a.total_price, a.notes, a.canceled_reason, a.google_calendar_event_id, a.created_at, a.updated_at,
    p.nome as professional_name,
    c.nome as customer_name,
    c.telefone as customer_phone
FROM appointments a
JOIN profissionais p ON p.id = a.professional_id
JOIN clientes c ON c.id = a.customer_id
WHERE a.tenant_id = $1
  AND a.professional_id = $2
  AND a.start_time >= $3
  AND a.start_time < $4
  AND a.status NOT IN ('CANCELED')
ORDER BY a.start_time ASC
`

type ListAppointmentsByProfessionalAndDateRangeParams struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	ProfessionalID pgtype.UUID        `json:"professional_id"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
	StartTime_2    pgtype.Timestamptz `json:"start_time_2"`
}

type ListAppointmentsByProfessionalAndDateRangeRow struct {
	ID                    pgtype.UUID        `json:"id"`
	TenantID              pgtype.UUID        `json:"tenant_id"`
	ProfessionalID        pgtype.UUID        `json:"professional_id"`
	CustomerID            pgtype.UUID        `json:"customer_id"`
	StartTime             pgtype.Timestamptz `json:"start_time"`
	EndTime               pgtype.Timestamptz `json:"end_time"`
	Status                string             `json:"status"`
	TotalPrice            decimal.Decimal    `json:"total_price"`
	Notes                 *string            `json:"notes"`
	CanceledReason        *string            `json:"canceled_reason"`
	GoogleCalendarEventID *string            `json:"google_calendar_event_id"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	ProfessionalName      string             `json:"professional_name"`
	CustomerName          string             `json:"customer_name"`
	CustomerPhone         string             `json:"customer_phone"`
}

func (q *Queries) ListAppointmentsByProfessionalAndDateRange(ctx context.Context, arg ListAppointmentsByProfessionalAndDateRangeParams) ([]ListAppointmentsByProfessionalAndDateRangeRow, error) {
	rows, err := q.db.Query(ctx, listAppointmentsByProfessionalAndDateRange,
		arg.TenantID,
		arg.ProfessionalID,
		arg.StartTime,
		arg.StartTime_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAppointmentsByProfessionalAndDateRangeRow{}
	for rows.Next() {
		var i ListAppointmentsByProfessionalAndDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProfessionalID,
			&i.CustomerID,
			&i.StartTime,
			&i.EndTime,
			&i.Status,
			&i.TotalPrice,
			&i.Notes,
			&i.CanceledReason,
			&i.GoogleCalendarEventID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProfessionalName,
			&i.CustomerName,
			&i.CustomerPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const professionalExists = `-- name: ProfessionalExists :one

SELECT EXISTS (
    SELECT 1 FROM profissionais
    WHERE id = $1 AND tenant_id = $2 AND status = 'ATIVO'
) as exists
`

type ProfessionalExistsParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// ============================================================================
// QUERIES AUXILIARES: Profissionais, Clientes, Serviços (Read-Only)
// ============================================================================
func (q *Queries) ProfessionalExists(ctx context.Context, arg ProfessionalExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, professionalExists, arg.ID, arg.TenantID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const serviceExists = `-- name: ServiceExists :one
SELECT EXISTS (
    SELECT 1 FROM servicos
    WHERE id = $1 AND tenant_id = $2 AND ativo = true
) as exists
`

type ServiceExistsParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) ServiceExists(ctx context.Context, arg ServiceExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, serviceExists, arg.ID, arg.TenantID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateAppointment = `-- name: UpdateAppointment :one
UPDATE appointments
SET
    professional_id = $3,
    start_time = $4,
    end_time = $5,
    status = $6,
    total_price = $7,
    notes = $8,
    canceled_reason = $9,
    google_calendar_event_id = $10,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, professional_id, customer_id, start_time, end_time, status, total_price, notes, canceled_reason, google_calendar_event_id, created_at, updated_at
`

type UpdateAppointmentParams struct {
	ID                    pgtype.UUID        `json:"id"`
	TenantID              pgtype.UUID        `json:"tenant_id"`
	ProfessionalID        pgtype.UUID        `json:"professional_id"`
	StartTime             pgtype.Timestamptz `json:"start_time"`
	EndTime               pgtype.Timestamptz `json:"end_time"`
	Status                string             `json:"status"`
	TotalPrice            decimal.Decimal    `json:"total_price"`
	Notes                 *string            `json:"notes"`
	CanceledReason        *string            `json:"canceled_reason"`
	GoogleCalendarEventID *string            `json:"google_calendar_event_id"`
}

func (q *Queries) UpdateAppointment(ctx context.Context, arg UpdateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, updateAppointment,
		arg.ID,
		arg.TenantID,
		arg.ProfessionalID,
		arg.StartTime,
		arg.EndTime,
		arg.Status,
		arg.TotalPrice,
		arg.Notes,
		arg.CanceledReason,
		arg.GoogleCalendarEventID,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CustomerID,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.TotalPrice,
		&i.Notes,
		&i.CanceledReason,
		&i.GoogleCalendarEventID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAppointmentStatus = `-- name: UpdateAppointmentStatus :one
UPDATE appointments
SET
    status = $3,
    canceled_reason = $4,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, professional_id, customer_id, start_time, end_time, status, total_price, notes, canceled_reason, google_calendar_event_id, created_at, updated_at
`

type UpdateAppointmentStatusParams struct {
	ID             pgtype.UUID `json:"id"`
	TenantID       pgtype.UUID `json:"tenant_id"`
	Status         string      `json:"status"`
	CanceledReason *string     `json:"canceled_reason"`
}

func (q *Queries) UpdateAppointmentStatus(ctx context.Context, arg UpdateAppointmentStatusParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, updateAppointmentStatus,
		arg.ID,
		arg.TenantID,
		arg.Status,
		arg.CanceledReason,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProfessionalID,
		&i.CustomerID,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.TotalPrice,
		&i.Notes,
		&i.CanceledReason,
		&i.GoogleCalendarEventID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
