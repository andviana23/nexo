// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: caixa_diario.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const countCaixaDiarioHistorico = `-- name: CountCaixaDiarioHistorico :one
SELECT COUNT(*) 
FROM caixa_diario
WHERE tenant_id = $1 
    AND status = 'FECHADO'
    AND ($2::date IS NULL OR data_abertura >= $2)
    AND ($3::date IS NULL OR data_abertura <= $3)
    AND ($4::uuid IS NULL OR usuario_abertura_id = $4 OR usuario_fechamento_id = $4)
`

type CountCaixaDiarioHistoricoParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Column2  pgtype.Date `json:"column_2"`
	Column3  pgtype.Date `json:"column_3"`
	Column4  pgtype.UUID `json:"column_4"`
}

func (q *Queries) CountCaixaDiarioHistorico(ctx context.Context, arg CountCaixaDiarioHistoricoParams) (int64, error) {
	row := q.db.QueryRow(ctx, countCaixaDiarioHistorico,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCaixaDiario = `-- name: CreateCaixaDiario :one


INSERT INTO caixa_diario (
    id,
    tenant_id,
    usuario_abertura_id,
    data_abertura,
    saldo_inicial,
    total_entradas,
    total_saidas,
    total_sangrias,
    total_reforcos,
    saldo_esperado,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, tenant_id, usuario_abertura_id, usuario_fechamento_id, data_abertura, data_fechamento, saldo_inicial, total_entradas, total_saidas, total_sangrias, total_reforcos, saldo_esperado, saldo_real, divergencia, status, justificativa_divergencia, created_at, updated_at
`

type CreateCaixaDiarioParams struct {
	ID                pgtype.UUID        `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	UsuarioAberturaID pgtype.UUID        `json:"usuario_abertura_id"`
	DataAbertura      pgtype.Timestamptz `json:"data_abertura"`
	SaldoInicial      decimal.Decimal    `json:"saldo_inicial"`
	TotalEntradas     decimal.Decimal    `json:"total_entradas"`
	TotalSaidas       decimal.Decimal    `json:"total_saidas"`
	TotalSangrias     decimal.Decimal    `json:"total_sangrias"`
	TotalReforcos     decimal.Decimal    `json:"total_reforcos"`
	SaldoEsperado     decimal.Decimal    `json:"saldo_esperado"`
	Status            string             `json:"status"`
}

// =============================================
// CAIXA DIÁRIO - Queries SQLC
// Módulo de controle operacional da gaveta
// =============================================
// ========== CREATE ==========
func (q *Queries) CreateCaixaDiario(ctx context.Context, arg CreateCaixaDiarioParams) (CaixaDiario, error) {
	row := q.db.QueryRow(ctx, createCaixaDiario,
		arg.ID,
		arg.TenantID,
		arg.UsuarioAberturaID,
		arg.DataAbertura,
		arg.SaldoInicial,
		arg.TotalEntradas,
		arg.TotalSaidas,
		arg.TotalSangrias,
		arg.TotalReforcos,
		arg.SaldoEsperado,
		arg.Status,
	)
	var i CaixaDiario
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UsuarioAberturaID,
		&i.UsuarioFechamentoID,
		&i.DataAbertura,
		&i.DataFechamento,
		&i.SaldoInicial,
		&i.TotalEntradas,
		&i.TotalSaidas,
		&i.TotalSangrias,
		&i.TotalReforcos,
		&i.SaldoEsperado,
		&i.SaldoReal,
		&i.Divergencia,
		&i.Status,
		&i.JustificativaDivergencia,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOperacaoCaixa = `-- name: CreateOperacaoCaixa :one

INSERT INTO operacoes_caixa (
    id,
    caixa_id,
    tenant_id,
    tipo,
    valor,
    descricao,
    destino,
    origem,
    usuario_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, caixa_id, tenant_id, tipo, valor, descricao, destino, origem, usuario_id, created_at
`

type CreateOperacaoCaixaParams struct {
	ID        pgtype.UUID     `json:"id"`
	CaixaID   pgtype.UUID     `json:"caixa_id"`
	TenantID  pgtype.UUID     `json:"tenant_id"`
	Tipo      string          `json:"tipo"`
	Valor     decimal.Decimal `json:"valor"`
	Descricao string          `json:"descricao"`
	Destino   *string         `json:"destino"`
	Origem    *string         `json:"origem"`
	UsuarioID pgtype.UUID     `json:"usuario_id"`
}

// =============================================
// OPERAÇÕES DO CAIXA
// =============================================
func (q *Queries) CreateOperacaoCaixa(ctx context.Context, arg CreateOperacaoCaixaParams) (OperacoesCaixa, error) {
	row := q.db.QueryRow(ctx, createOperacaoCaixa,
		arg.ID,
		arg.CaixaID,
		arg.TenantID,
		arg.Tipo,
		arg.Valor,
		arg.Descricao,
		arg.Destino,
		arg.Origem,
		arg.UsuarioID,
	)
	var i OperacoesCaixa
	err := row.Scan(
		&i.ID,
		&i.CaixaID,
		&i.TenantID,
		&i.Tipo,
		&i.Valor,
		&i.Descricao,
		&i.Destino,
		&i.Origem,
		&i.UsuarioID,
		&i.CreatedAt,
	)
	return i, err
}

const existsCaixaAberto = `-- name: ExistsCaixaAberto :one
SELECT EXISTS(
    SELECT 1 FROM caixa_diario 
    WHERE tenant_id = $1 AND status = 'ABERTO'
) as exists
`

func (q *Queries) ExistsCaixaAberto(ctx context.Context, tenantID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, existsCaixaAberto, tenantID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const fecharCaixaDiario = `-- name: FecharCaixaDiario :one
UPDATE caixa_diario
SET
    usuario_fechamento_id = $3,
    data_fechamento = $4,
    saldo_real = $5,
    divergencia = $6,
    status = 'FECHADO',
    justificativa_divergencia = $7,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2 AND status = 'ABERTO'
RETURNING id, tenant_id, usuario_abertura_id, usuario_fechamento_id, data_abertura, data_fechamento, saldo_inicial, total_entradas, total_saidas, total_sangrias, total_reforcos, saldo_esperado, saldo_real, divergencia, status, justificativa_divergencia, created_at, updated_at
`

type FecharCaixaDiarioParams struct {
	ID                       pgtype.UUID        `json:"id"`
	TenantID                 pgtype.UUID        `json:"tenant_id"`
	UsuarioFechamentoID      pgtype.UUID        `json:"usuario_fechamento_id"`
	DataFechamento           pgtype.Timestamptz `json:"data_fechamento"`
	SaldoReal                pgtype.Numeric     `json:"saldo_real"`
	Divergencia              pgtype.Numeric     `json:"divergencia"`
	JustificativaDivergencia *string            `json:"justificativa_divergencia"`
}

func (q *Queries) FecharCaixaDiario(ctx context.Context, arg FecharCaixaDiarioParams) (CaixaDiario, error) {
	row := q.db.QueryRow(ctx, fecharCaixaDiario,
		arg.ID,
		arg.TenantID,
		arg.UsuarioFechamentoID,
		arg.DataFechamento,
		arg.SaldoReal,
		arg.Divergencia,
		arg.JustificativaDivergencia,
	)
	var i CaixaDiario
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UsuarioAberturaID,
		&i.UsuarioFechamentoID,
		&i.DataAbertura,
		&i.DataFechamento,
		&i.SaldoInicial,
		&i.TotalEntradas,
		&i.TotalSaidas,
		&i.TotalSangrias,
		&i.TotalReforcos,
		&i.SaldoEsperado,
		&i.SaldoReal,
		&i.Divergencia,
		&i.Status,
		&i.JustificativaDivergencia,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCaixaDiarioAberto = `-- name: GetCaixaDiarioAberto :one
SELECT 
    c.id, c.tenant_id, c.usuario_abertura_id, c.usuario_fechamento_id, c.data_abertura, c.data_fechamento, c.saldo_inicial, c.total_entradas, c.total_saidas, c.total_sangrias, c.total_reforcos, c.saldo_esperado, c.saldo_real, c.divergencia, c.status, c.justificativa_divergencia, c.created_at, c.updated_at,
    ua.nome as usuario_abertura_nome,
    '' as usuario_fechamento_nome
FROM caixa_diario c
LEFT JOIN users ua ON ua.id = c.usuario_abertura_id
WHERE c.tenant_id = $1 AND c.status = 'ABERTO'
LIMIT 1
`

type GetCaixaDiarioAbertoRow struct {
	ID                       pgtype.UUID        `json:"id"`
	TenantID                 pgtype.UUID        `json:"tenant_id"`
	UsuarioAberturaID        pgtype.UUID        `json:"usuario_abertura_id"`
	UsuarioFechamentoID      pgtype.UUID        `json:"usuario_fechamento_id"`
	DataAbertura             pgtype.Timestamptz `json:"data_abertura"`
	DataFechamento           pgtype.Timestamptz `json:"data_fechamento"`
	SaldoInicial             decimal.Decimal    `json:"saldo_inicial"`
	TotalEntradas            decimal.Decimal    `json:"total_entradas"`
	TotalSaidas              decimal.Decimal    `json:"total_saidas"`
	TotalSangrias            decimal.Decimal    `json:"total_sangrias"`
	TotalReforcos            decimal.Decimal    `json:"total_reforcos"`
	SaldoEsperado            decimal.Decimal    `json:"saldo_esperado"`
	SaldoReal                pgtype.Numeric     `json:"saldo_real"`
	Divergencia              pgtype.Numeric     `json:"divergencia"`
	Status                   string             `json:"status"`
	JustificativaDivergencia *string            `json:"justificativa_divergencia"`
	CreatedAt                pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                pgtype.Timestamptz `json:"updated_at"`
	UsuarioAberturaNome      *string            `json:"usuario_abertura_nome"`
	UsuarioFechamentoNome    string             `json:"usuario_fechamento_nome"`
}

func (q *Queries) GetCaixaDiarioAberto(ctx context.Context, tenantID pgtype.UUID) (GetCaixaDiarioAbertoRow, error) {
	row := q.db.QueryRow(ctx, getCaixaDiarioAberto, tenantID)
	var i GetCaixaDiarioAbertoRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UsuarioAberturaID,
		&i.UsuarioFechamentoID,
		&i.DataAbertura,
		&i.DataFechamento,
		&i.SaldoInicial,
		&i.TotalEntradas,
		&i.TotalSaidas,
		&i.TotalSangrias,
		&i.TotalReforcos,
		&i.SaldoEsperado,
		&i.SaldoReal,
		&i.Divergencia,
		&i.Status,
		&i.JustificativaDivergencia,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UsuarioAberturaNome,
		&i.UsuarioFechamentoNome,
	)
	return i, err
}

const getCaixaDiarioByID = `-- name: GetCaixaDiarioByID :one

SELECT 
    c.id, c.tenant_id, c.usuario_abertura_id, c.usuario_fechamento_id, c.data_abertura, c.data_fechamento, c.saldo_inicial, c.total_entradas, c.total_saidas, c.total_sangrias, c.total_reforcos, c.saldo_esperado, c.saldo_real, c.divergencia, c.status, c.justificativa_divergencia, c.created_at, c.updated_at,
    ua.nome as usuario_abertura_nome,
    COALESCE(uf.nome, '') as usuario_fechamento_nome
FROM caixa_diario c
LEFT JOIN users ua ON ua.id = c.usuario_abertura_id
LEFT JOIN users uf ON uf.id = c.usuario_fechamento_id
WHERE c.id = $1 AND c.tenant_id = $2
`

type GetCaixaDiarioByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetCaixaDiarioByIDRow struct {
	ID                       pgtype.UUID        `json:"id"`
	TenantID                 pgtype.UUID        `json:"tenant_id"`
	UsuarioAberturaID        pgtype.UUID        `json:"usuario_abertura_id"`
	UsuarioFechamentoID      pgtype.UUID        `json:"usuario_fechamento_id"`
	DataAbertura             pgtype.Timestamptz `json:"data_abertura"`
	DataFechamento           pgtype.Timestamptz `json:"data_fechamento"`
	SaldoInicial             decimal.Decimal    `json:"saldo_inicial"`
	TotalEntradas            decimal.Decimal    `json:"total_entradas"`
	TotalSaidas              decimal.Decimal    `json:"total_saidas"`
	TotalSangrias            decimal.Decimal    `json:"total_sangrias"`
	TotalReforcos            decimal.Decimal    `json:"total_reforcos"`
	SaldoEsperado            decimal.Decimal    `json:"saldo_esperado"`
	SaldoReal                pgtype.Numeric     `json:"saldo_real"`
	Divergencia              pgtype.Numeric     `json:"divergencia"`
	Status                   string             `json:"status"`
	JustificativaDivergencia *string            `json:"justificativa_divergencia"`
	CreatedAt                pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                pgtype.Timestamptz `json:"updated_at"`
	UsuarioAberturaNome      *string            `json:"usuario_abertura_nome"`
	UsuarioFechamentoNome    string             `json:"usuario_fechamento_nome"`
}

// ========== READ ==========
func (q *Queries) GetCaixaDiarioByID(ctx context.Context, arg GetCaixaDiarioByIDParams) (GetCaixaDiarioByIDRow, error) {
	row := q.db.QueryRow(ctx, getCaixaDiarioByID, arg.ID, arg.TenantID)
	var i GetCaixaDiarioByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UsuarioAberturaID,
		&i.UsuarioFechamentoID,
		&i.DataAbertura,
		&i.DataFechamento,
		&i.SaldoInicial,
		&i.TotalEntradas,
		&i.TotalSaidas,
		&i.TotalSangrias,
		&i.TotalReforcos,
		&i.SaldoEsperado,
		&i.SaldoReal,
		&i.Divergencia,
		&i.Status,
		&i.JustificativaDivergencia,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UsuarioAberturaNome,
		&i.UsuarioFechamentoNome,
	)
	return i, err
}

const getLastOperacao = `-- name: GetLastOperacao :one
SELECT 
    o.id, o.caixa_id, o.tenant_id, o.tipo, o.valor, o.descricao, o.destino, o.origem, o.usuario_id, o.created_at,
    u.nome as usuario_nome
FROM operacoes_caixa o
LEFT JOIN users u ON u.id = o.usuario_id
WHERE o.caixa_id = $1 AND o.tenant_id = $2
ORDER BY o.created_at DESC
LIMIT 1
`

type GetLastOperacaoParams struct {
	CaixaID  pgtype.UUID `json:"caixa_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetLastOperacaoRow struct {
	ID          pgtype.UUID        `json:"id"`
	CaixaID     pgtype.UUID        `json:"caixa_id"`
	TenantID    pgtype.UUID        `json:"tenant_id"`
	Tipo        string             `json:"tipo"`
	Valor       decimal.Decimal    `json:"valor"`
	Descricao   string             `json:"descricao"`
	Destino     *string            `json:"destino"`
	Origem      *string            `json:"origem"`
	UsuarioID   pgtype.UUID        `json:"usuario_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UsuarioNome *string            `json:"usuario_nome"`
}

func (q *Queries) GetLastOperacao(ctx context.Context, arg GetLastOperacaoParams) (GetLastOperacaoRow, error) {
	row := q.db.QueryRow(ctx, getLastOperacao, arg.CaixaID, arg.TenantID)
	var i GetLastOperacaoRow
	err := row.Scan(
		&i.ID,
		&i.CaixaID,
		&i.TenantID,
		&i.Tipo,
		&i.Valor,
		&i.Descricao,
		&i.Destino,
		&i.Origem,
		&i.UsuarioID,
		&i.CreatedAt,
		&i.UsuarioNome,
	)
	return i, err
}

const listCaixaDiarioHistorico = `-- name: ListCaixaDiarioHistorico :many

SELECT 
    c.id, c.tenant_id, c.usuario_abertura_id, c.usuario_fechamento_id, c.data_abertura, c.data_fechamento, c.saldo_inicial, c.total_entradas, c.total_saidas, c.total_sangrias, c.total_reforcos, c.saldo_esperado, c.saldo_real, c.divergencia, c.status, c.justificativa_divergencia, c.created_at, c.updated_at,
    ua.nome as usuario_abertura_nome,
    COALESCE(uf.nome, '') as usuario_fechamento_nome
FROM caixa_diario c
LEFT JOIN users ua ON ua.id = c.usuario_abertura_id
LEFT JOIN users uf ON uf.id = c.usuario_fechamento_id
WHERE c.tenant_id = $1 
    AND c.status = 'FECHADO'
    AND ($2::date IS NULL OR c.data_abertura >= $2)
    AND ($3::date IS NULL OR c.data_abertura <= $3)
    AND ($4::uuid IS NULL OR c.usuario_abertura_id = $4 OR c.usuario_fechamento_id = $4)
ORDER BY c.data_abertura DESC
LIMIT $5 OFFSET $6
`

type ListCaixaDiarioHistoricoParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Column2  pgtype.Date `json:"column_2"`
	Column3  pgtype.Date `json:"column_3"`
	Column4  pgtype.UUID `json:"column_4"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListCaixaDiarioHistoricoRow struct {
	ID                       pgtype.UUID        `json:"id"`
	TenantID                 pgtype.UUID        `json:"tenant_id"`
	UsuarioAberturaID        pgtype.UUID        `json:"usuario_abertura_id"`
	UsuarioFechamentoID      pgtype.UUID        `json:"usuario_fechamento_id"`
	DataAbertura             pgtype.Timestamptz `json:"data_abertura"`
	DataFechamento           pgtype.Timestamptz `json:"data_fechamento"`
	SaldoInicial             decimal.Decimal    `json:"saldo_inicial"`
	TotalEntradas            decimal.Decimal    `json:"total_entradas"`
	TotalSaidas              decimal.Decimal    `json:"total_saidas"`
	TotalSangrias            decimal.Decimal    `json:"total_sangrias"`
	TotalReforcos            decimal.Decimal    `json:"total_reforcos"`
	SaldoEsperado            decimal.Decimal    `json:"saldo_esperado"`
	SaldoReal                pgtype.Numeric     `json:"saldo_real"`
	Divergencia              pgtype.Numeric     `json:"divergencia"`
	Status                   string             `json:"status"`
	JustificativaDivergencia *string            `json:"justificativa_divergencia"`
	CreatedAt                pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                pgtype.Timestamptz `json:"updated_at"`
	UsuarioAberturaNome      *string            `json:"usuario_abertura_nome"`
	UsuarioFechamentoNome    string             `json:"usuario_fechamento_nome"`
}

// ========== LIST ==========
func (q *Queries) ListCaixaDiarioHistorico(ctx context.Context, arg ListCaixaDiarioHistoricoParams) ([]ListCaixaDiarioHistoricoRow, error) {
	rows, err := q.db.Query(ctx, listCaixaDiarioHistorico,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCaixaDiarioHistoricoRow{}
	for rows.Next() {
		var i ListCaixaDiarioHistoricoRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UsuarioAberturaID,
			&i.UsuarioFechamentoID,
			&i.DataAbertura,
			&i.DataFechamento,
			&i.SaldoInicial,
			&i.TotalEntradas,
			&i.TotalSaidas,
			&i.TotalSangrias,
			&i.TotalReforcos,
			&i.SaldoEsperado,
			&i.SaldoReal,
			&i.Divergencia,
			&i.Status,
			&i.JustificativaDivergencia,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UsuarioAberturaNome,
			&i.UsuarioFechamentoNome,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOperacoesByCaixa = `-- name: ListOperacoesByCaixa :many
SELECT 
    o.id, o.caixa_id, o.tenant_id, o.tipo, o.valor, o.descricao, o.destino, o.origem, o.usuario_id, o.created_at,
    u.nome as usuario_nome
FROM operacoes_caixa o
LEFT JOIN users u ON u.id = o.usuario_id
WHERE o.caixa_id = $1 AND o.tenant_id = $2
ORDER BY o.created_at ASC
`

type ListOperacoesByCaixaParams struct {
	CaixaID  pgtype.UUID `json:"caixa_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type ListOperacoesByCaixaRow struct {
	ID          pgtype.UUID        `json:"id"`
	CaixaID     pgtype.UUID        `json:"caixa_id"`
	TenantID    pgtype.UUID        `json:"tenant_id"`
	Tipo        string             `json:"tipo"`
	Valor       decimal.Decimal    `json:"valor"`
	Descricao   string             `json:"descricao"`
	Destino     *string            `json:"destino"`
	Origem      *string            `json:"origem"`
	UsuarioID   pgtype.UUID        `json:"usuario_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UsuarioNome *string            `json:"usuario_nome"`
}

func (q *Queries) ListOperacoesByCaixa(ctx context.Context, arg ListOperacoesByCaixaParams) ([]ListOperacoesByCaixaRow, error) {
	rows, err := q.db.Query(ctx, listOperacoesByCaixa, arg.CaixaID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOperacoesByCaixaRow{}
	for rows.Next() {
		var i ListOperacoesByCaixaRow
		if err := rows.Scan(
			&i.ID,
			&i.CaixaID,
			&i.TenantID,
			&i.Tipo,
			&i.Valor,
			&i.Descricao,
			&i.Destino,
			&i.Origem,
			&i.UsuarioID,
			&i.CreatedAt,
			&i.UsuarioNome,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOperacoesByCaixaAndTipo = `-- name: ListOperacoesByCaixaAndTipo :many
SELECT 
    o.id, o.caixa_id, o.tenant_id, o.tipo, o.valor, o.descricao, o.destino, o.origem, o.usuario_id, o.created_at,
    u.nome as usuario_nome
FROM operacoes_caixa o
LEFT JOIN users u ON u.id = o.usuario_id
WHERE o.caixa_id = $1 AND o.tenant_id = $2 AND o.tipo = $3
ORDER BY o.created_at ASC
`

type ListOperacoesByCaixaAndTipoParams struct {
	CaixaID  pgtype.UUID `json:"caixa_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Tipo     string      `json:"tipo"`
}

type ListOperacoesByCaixaAndTipoRow struct {
	ID          pgtype.UUID        `json:"id"`
	CaixaID     pgtype.UUID        `json:"caixa_id"`
	TenantID    pgtype.UUID        `json:"tenant_id"`
	Tipo        string             `json:"tipo"`
	Valor       decimal.Decimal    `json:"valor"`
	Descricao   string             `json:"descricao"`
	Destino     *string            `json:"destino"`
	Origem      *string            `json:"origem"`
	UsuarioID   pgtype.UUID        `json:"usuario_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UsuarioNome *string            `json:"usuario_nome"`
}

func (q *Queries) ListOperacoesByCaixaAndTipo(ctx context.Context, arg ListOperacoesByCaixaAndTipoParams) ([]ListOperacoesByCaixaAndTipoRow, error) {
	rows, err := q.db.Query(ctx, listOperacoesByCaixaAndTipo, arg.CaixaID, arg.TenantID, arg.Tipo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOperacoesByCaixaAndTipoRow{}
	for rows.Next() {
		var i ListOperacoesByCaixaAndTipoRow
		if err := rows.Scan(
			&i.ID,
			&i.CaixaID,
			&i.TenantID,
			&i.Tipo,
			&i.Valor,
			&i.Descricao,
			&i.Destino,
			&i.Origem,
			&i.UsuarioID,
			&i.CreatedAt,
			&i.UsuarioNome,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumOperacoesByTipo = `-- name: SumOperacoesByTipo :many
SELECT 
    tipo,
    COALESCE(SUM(valor), 0) as total
FROM operacoes_caixa
WHERE caixa_id = $1 AND tenant_id = $2
GROUP BY tipo
`

type SumOperacoesByTipoParams struct {
	CaixaID  pgtype.UUID `json:"caixa_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type SumOperacoesByTipoRow struct {
	Tipo  string      `json:"tipo"`
	Total interface{} `json:"total"`
}

func (q *Queries) SumOperacoesByTipo(ctx context.Context, arg SumOperacoesByTipoParams) ([]SumOperacoesByTipoRow, error) {
	rows, err := q.db.Query(ctx, sumOperacoesByTipo, arg.CaixaID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SumOperacoesByTipoRow{}
	for rows.Next() {
		var i SumOperacoesByTipoRow
		if err := rows.Scan(&i.Tipo, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCaixaDiario = `-- name: UpdateCaixaDiario :one

UPDATE caixa_diario
SET
    total_entradas = $3,
    total_saidas = $4,
    total_sangrias = $5,
    total_reforcos = $6,
    saldo_esperado = $7,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, usuario_abertura_id, usuario_fechamento_id, data_abertura, data_fechamento, saldo_inicial, total_entradas, total_saidas, total_sangrias, total_reforcos, saldo_esperado, saldo_real, divergencia, status, justificativa_divergencia, created_at, updated_at
`

type UpdateCaixaDiarioParams struct {
	ID            pgtype.UUID     `json:"id"`
	TenantID      pgtype.UUID     `json:"tenant_id"`
	TotalEntradas decimal.Decimal `json:"total_entradas"`
	TotalSaidas   decimal.Decimal `json:"total_saidas"`
	TotalSangrias decimal.Decimal `json:"total_sangrias"`
	TotalReforcos decimal.Decimal `json:"total_reforcos"`
	SaldoEsperado decimal.Decimal `json:"saldo_esperado"`
}

// ========== UPDATE ==========
func (q *Queries) UpdateCaixaDiario(ctx context.Context, arg UpdateCaixaDiarioParams) (CaixaDiario, error) {
	row := q.db.QueryRow(ctx, updateCaixaDiario,
		arg.ID,
		arg.TenantID,
		arg.TotalEntradas,
		arg.TotalSaidas,
		arg.TotalSangrias,
		arg.TotalReforcos,
		arg.SaldoEsperado,
	)
	var i CaixaDiario
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UsuarioAberturaID,
		&i.UsuarioFechamentoID,
		&i.DataAbertura,
		&i.DataFechamento,
		&i.SaldoInicial,
		&i.TotalEntradas,
		&i.TotalSaidas,
		&i.TotalSangrias,
		&i.TotalReforcos,
		&i.SaldoEsperado,
		&i.SaldoReal,
		&i.Divergencia,
		&i.Status,
		&i.JustificativaDivergencia,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCaixaDiarioTotais = `-- name: UpdateCaixaDiarioTotais :exec
UPDATE caixa_diario
SET
    total_sangrias = $3,
    total_reforcos = $4,
    total_entradas = $5,
    saldo_esperado = saldo_inicial + $5 - $3 + $4,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdateCaixaDiarioTotaisParams struct {
	ID            pgtype.UUID     `json:"id"`
	TenantID      pgtype.UUID     `json:"tenant_id"`
	TotalSangrias decimal.Decimal `json:"total_sangrias"`
	TotalReforcos decimal.Decimal `json:"total_reforcos"`
	TotalEntradas decimal.Decimal `json:"total_entradas"`
}

func (q *Queries) UpdateCaixaDiarioTotais(ctx context.Context, arg UpdateCaixaDiarioTotaisParams) error {
	_, err := q.db.Exec(ctx, updateCaixaDiarioTotais,
		arg.ID,
		arg.TenantID,
		arg.TotalSangrias,
		arg.TotalReforcos,
		arg.TotalEntradas,
	)
	return err
}
