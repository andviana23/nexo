// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: subscriptions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const activateSubscription = `-- name: ActivateSubscription :exec
UPDATE subscriptions SET 
    status = 'ATIVO', 
    data_ativacao = $3, 
    data_vencimento = $4,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type ActivateSubscriptionParams struct {
	ID             pgtype.UUID        `json:"id"`
	TenantID       pgtype.UUID        `json:"tenant_id"`
	DataAtivacao   pgtype.Timestamptz `json:"data_ativacao"`
	DataVencimento pgtype.Timestamptz `json:"data_vencimento"`
}

// Ativar assinatura (após pagamento confirmado)
func (q *Queries) ActivateSubscription(ctx context.Context, arg ActivateSubscriptionParams) error {
	_, err := q.db.Exec(ctx, activateSubscription,
		arg.ID,
		arg.TenantID,
		arg.DataAtivacao,
		arg.DataVencimento,
	)
	return err
}

const cancelSubscription = `-- name: CancelSubscription :exec
UPDATE subscriptions SET 
    status = 'CANCELADO', 
    data_cancelamento = NOW(), 
    cancelado_por = $3,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type CancelSubscriptionParams struct {
	ID           pgtype.UUID `json:"id"`
	TenantID     pgtype.UUID `json:"tenant_id"`
	CanceladoPor pgtype.UUID `json:"cancelado_por"`
}

// Cancelar assinatura (RN-CANC-003)
func (q *Queries) CancelSubscription(ctx context.Context, arg CancelSubscriptionParams) error {
	_, err := q.db.Exec(ctx, cancelSubscription, arg.ID, arg.TenantID, arg.CanceladoPor)
	return err
}

const checkActiveSubscriptionExists = `-- name: CheckActiveSubscriptionExists :one
SELECT EXISTS(
    SELECT 1 FROM subscriptions 
    WHERE cliente_id = $1 AND plano_id = $2 AND status = 'ATIVO'
) AS exists
`

type CheckActiveSubscriptionExistsParams struct {
	ClienteID pgtype.UUID `json:"cliente_id"`
	PlanoID   pgtype.UUID `json:"plano_id"`
}

// Verificar se já existe assinatura ativa do mesmo plano (RN-SUB-004)
func (q *Queries) CheckActiveSubscriptionExists(ctx context.Context, arg CheckActiveSubscriptionExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkActiveSubscriptionExists, arg.ClienteID, arg.PlanoID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkPlanNameExists = `-- name: CheckPlanNameExists :one
SELECT EXISTS(
    SELECT 1 FROM plans 
    WHERE tenant_id = $1 AND nome = $2 AND id != $3
) AS exists
`

type CheckPlanNameExistsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Nome     string      `json:"nome"`
	ID       pgtype.UUID `json:"id"`
}

// Verificar se nome de plano já existe no tenant (REGRA PL-005)
func (q *Queries) CheckPlanNameExists(ctx context.Context, arg CheckPlanNameExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkPlanNameExists, arg.TenantID, arg.Nome, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const confirmPayment = `-- name: ConfirmPayment :exec
UPDATE subscription_payments SET 
    status = 'CONFIRMADO',
    data_pagamento = $3
WHERE id = $1 AND tenant_id = $2
`

type ConfirmPaymentParams struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	DataPagamento pgtype.Timestamptz `json:"data_pagamento"`
}

// Confirmar pagamento (atualizar status e data)
func (q *Queries) ConfirmPayment(ctx context.Context, arg ConfirmPaymentParams) error {
	_, err := q.db.Exec(ctx, confirmPayment, arg.ID, arg.TenantID, arg.DataPagamento)
	return err
}

const countActiveSubscriptionsByCliente = `-- name: CountActiveSubscriptionsByCliente :one
SELECT COUNT(*)::int FROM subscriptions 
WHERE cliente_id = $1 AND tenant_id = $2 AND status = 'ATIVO'
`

type CountActiveSubscriptionsByClienteParams struct {
	ClienteID pgtype.UUID `json:"cliente_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

// Contar assinaturas ativas de um cliente (para RN-CLI-004)
func (q *Queries) CountActiveSubscriptionsByCliente(ctx context.Context, arg CountActiveSubscriptionsByClienteParams) (int32, error) {
	row := q.db.QueryRow(ctx, countActiveSubscriptionsByCliente, arg.ClienteID, arg.TenantID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countActiveSubscriptionsByPlan = `-- name: CountActiveSubscriptionsByPlan :one
SELECT COUNT(*)::int FROM subscriptions 
WHERE plano_id = $1 AND tenant_id = $2 AND status = 'ATIVO'
`

type CountActiveSubscriptionsByPlanParams struct {
	PlanoID  pgtype.UUID `json:"plano_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Contar assinaturas ativas de um plano (para validar REGRA PL-003)
func (q *Queries) CountActiveSubscriptionsByPlan(ctx context.Context, arg CountActiveSubscriptionsByPlanParams) (int32, error) {
	row := q.db.QueryRow(ctx, countActiveSubscriptionsByPlan, arg.PlanoID, arg.TenantID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countPaymentsByStatus = `-- name: CountPaymentsByStatus :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'PENDENTE')::int as pendentes,
    COUNT(*) FILTER (WHERE status = 'CONFIRMADO')::int as confirmados,
    COUNT(*) FILTER (WHERE status = 'RECEBIDO')::int as recebidos,
    COUNT(*) FILTER (WHERE status = 'VENCIDO')::int as vencidos,
    COUNT(*) FILTER (WHERE status = 'ESTORNADO')::int as estornados
FROM subscription_payments
WHERE tenant_id = $1
`

type CountPaymentsByStatusRow struct {
	Pendentes   int32 `json:"pendentes"`
	Confirmados int32 `json:"confirmados"`
	Recebidos   int32 `json:"recebidos"`
	Vencidos    int32 `json:"vencidos"`
	Estornados  int32 `json:"estornados"`
}

// Contar pagamentos por status
func (q *Queries) CountPaymentsByStatus(ctx context.Context, tenantID pgtype.UUID) (CountPaymentsByStatusRow, error) {
	row := q.db.QueryRow(ctx, countPaymentsByStatus, tenantID)
	var i CountPaymentsByStatusRow
	err := row.Scan(
		&i.Pendentes,
		&i.Confirmados,
		&i.Recebidos,
		&i.Vencidos,
		&i.Estornados,
	)
	return i, err
}

const createPlan = `-- name: CreatePlan :one


INSERT INTO plans (
    tenant_id, 
    nome, 
    descricao, 
    valor, 
    periodicidade, 
    qtd_servicos, 
    limite_uso_mensal, 
    ativo
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, tenant_id, nome, descricao, valor, periodicidade, qtd_servicos, limite_uso_mensal, ativo, created_at, updated_at
`

type CreatePlanParams struct {
	TenantID        pgtype.UUID     `json:"tenant_id"`
	Nome            string          `json:"nome"`
	Descricao       *string         `json:"descricao"`
	Valor           decimal.Decimal `json:"valor"`
	Periodicidade   string          `json:"periodicidade"`
	QtdServicos     *int32          `json:"qtd_servicos"`
	LimiteUsoMensal *int32          `json:"limite_uso_mensal"`
	Ativo           bool            `json:"ativo"`
}

// ============================================================
// QUERIES SQLC — MÓDULO ASSINATURAS DE CLIENTES
// Referência: FLUXO_ASSINATURA.md
// Data: 03/12/2025
// ============================================================
// ============================================================
// PLANS (Planos de Assinatura de Clientes)
// ============================================================
// Criar novo plano de assinatura
func (q *Queries) CreatePlan(ctx context.Context, arg CreatePlanParams) (Plan, error) {
	row := q.db.QueryRow(ctx, createPlan,
		arg.TenantID,
		arg.Nome,
		arg.Descricao,
		arg.Valor,
		arg.Periodicidade,
		arg.QtdServicos,
		arg.LimiteUsoMensal,
		arg.Ativo,
	)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Descricao,
		&i.Valor,
		&i.Periodicidade,
		&i.QtdServicos,
		&i.LimiteUsoMensal,
		&i.Ativo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSubscription = `-- name: CreateSubscription :one

INSERT INTO subscriptions (
    tenant_id, 
    cliente_id, 
    plano_id, 
    asaas_customer_id, 
    asaas_subscription_id,
    forma_pagamento, 
    status, 
    valor, 
    link_pagamento, 
    codigo_transacao,
    data_ativacao, 
    data_vencimento
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, tenant_id, cliente_id, plano_id, asaas_customer_id, asaas_subscription_id, forma_pagamento, status, valor, link_pagamento, codigo_transacao, data_ativacao, data_vencimento, data_cancelamento, cancelado_por, servicos_utilizados, next_due_date, cycle, asaas_status, last_confirmed_at, last_sync_at, created_at, updated_at
`

type CreateSubscriptionParams struct {
	TenantID            pgtype.UUID        `json:"tenant_id"`
	ClienteID           pgtype.UUID        `json:"cliente_id"`
	PlanoID             pgtype.UUID        `json:"plano_id"`
	AsaasCustomerID     *string            `json:"asaas_customer_id"`
	AsaasSubscriptionID *string            `json:"asaas_subscription_id"`
	FormaPagamento      string             `json:"forma_pagamento"`
	Status              string             `json:"status"`
	Valor               decimal.Decimal    `json:"valor"`
	LinkPagamento       *string            `json:"link_pagamento"`
	CodigoTransacao     *string            `json:"codigo_transacao"`
	DataAtivacao        pgtype.Timestamptz `json:"data_ativacao"`
	DataVencimento      pgtype.Timestamptz `json:"data_vencimento"`
}

// ============================================================
// SUBSCRIPTIONS (Assinaturas de Clientes)
// ============================================================
// Criar nova assinatura
func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.TenantID,
		arg.ClienteID,
		arg.PlanoID,
		arg.AsaasCustomerID,
		arg.AsaasSubscriptionID,
		arg.FormaPagamento,
		arg.Status,
		arg.Valor,
		arg.LinkPagamento,
		arg.CodigoTransacao,
		arg.DataAtivacao,
		arg.DataVencimento,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ClienteID,
		&i.PlanoID,
		&i.AsaasCustomerID,
		&i.AsaasSubscriptionID,
		&i.FormaPagamento,
		&i.Status,
		&i.Valor,
		&i.LinkPagamento,
		&i.CodigoTransacao,
		&i.DataAtivacao,
		&i.DataVencimento,
		&i.DataCancelamento,
		&i.CanceladoPor,
		&i.ServicosUtilizados,
		&i.NextDueDate,
		&i.Cycle,
		&i.AsaasStatus,
		&i.LastConfirmedAt,
		&i.LastSyncAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSubscriptionPayment = `-- name: CreateSubscriptionPayment :one

INSERT INTO subscription_payments (
    tenant_id, 
    subscription_id, 
    asaas_payment_id, 
    valor, 
    forma_pagamento, 
    status, 
    data_pagamento, 
    codigo_transacao, 
    observacao
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, tenant_id, subscription_id, asaas_payment_id, valor, forma_pagamento, status, data_pagamento, codigo_transacao, observacao, status_asaas, due_date, confirmed_date, client_payment_date, credit_date, estimated_credit_date, billing_type, net_value, invoice_url, bank_slip_url, pix_qrcode, created_at, updated_at
`

type CreateSubscriptionPaymentParams struct {
	TenantID        pgtype.UUID        `json:"tenant_id"`
	SubscriptionID  pgtype.UUID        `json:"subscription_id"`
	AsaasPaymentID  *string            `json:"asaas_payment_id"`
	Valor           decimal.Decimal    `json:"valor"`
	FormaPagamento  string             `json:"forma_pagamento"`
	Status          string             `json:"status"`
	DataPagamento   pgtype.Timestamptz `json:"data_pagamento"`
	CodigoTransacao *string            `json:"codigo_transacao"`
	Observacao      *string            `json:"observacao"`
}

// ============================================================
// SUBSCRIPTION_PAYMENTS (Histórico de Pagamentos)
// ============================================================
// Registrar novo pagamento
func (q *Queries) CreateSubscriptionPayment(ctx context.Context, arg CreateSubscriptionPaymentParams) (SubscriptionPayment, error) {
	row := q.db.QueryRow(ctx, createSubscriptionPayment,
		arg.TenantID,
		arg.SubscriptionID,
		arg.AsaasPaymentID,
		arg.Valor,
		arg.FormaPagamento,
		arg.Status,
		arg.DataPagamento,
		arg.CodigoTransacao,
		arg.Observacao,
	)
	var i SubscriptionPayment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SubscriptionID,
		&i.AsaasPaymentID,
		&i.Valor,
		&i.FormaPagamento,
		&i.Status,
		&i.DataPagamento,
		&i.CodigoTransacao,
		&i.Observacao,
		&i.StatusAsaas,
		&i.DueDate,
		&i.ConfirmedDate,
		&i.ClientPaymentDate,
		&i.CreditDate,
		&i.EstimatedCreditDate,
		&i.BillingType,
		&i.NetValue,
		&i.InvoiceUrl,
		&i.BankSlipUrl,
		&i.PixQrcode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivatePlan = `-- name: DeactivatePlan :exec
UPDATE plans SET 
    ativo = false, 
    updated_at = NOW() 
WHERE id = $1 AND tenant_id = $2
`

type DeactivatePlanParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Desativar plano (soft delete - REGRA PL-003)
func (q *Queries) DeactivatePlan(ctx context.Context, arg DeactivatePlanParams) error {
	_, err := q.db.Exec(ctx, deactivatePlan, arg.ID, arg.TenantID)
	return err
}

const getClienteByAsaasID = `-- name: GetClienteByAsaasID :one
SELECT id, tenant_id, nome, email, telefone, cpf, data_nascimento, genero, endereco_logradouro, endereco_numero, endereco_complemento, endereco_bairro, endereco_cidade, endereco_estado, endereco_cep, observacoes, tags, ativo, asaas_customer_id, is_subscriber, criado_em, atualizado_em FROM clientes
WHERE tenant_id = $1 AND asaas_customer_id = $2
LIMIT 1
`

type GetClienteByAsaasIDParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	AsaasCustomerID *string     `json:"asaas_customer_id"`
}

// Buscar cliente pelo ID do Asaas (para unificação - RN-CLI-002)
func (q *Queries) GetClienteByAsaasID(ctx context.Context, arg GetClienteByAsaasIDParams) (Cliente, error) {
	row := q.db.QueryRow(ctx, getClienteByAsaasID, arg.TenantID, arg.AsaasCustomerID)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Email,
		&i.Telefone,
		&i.Cpf,
		&i.DataNascimento,
		&i.Genero,
		&i.EnderecoLogradouro,
		&i.EnderecoNumero,
		&i.EnderecoComplemento,
		&i.EnderecoBairro,
		&i.EnderecoCidade,
		&i.EnderecoEstado,
		&i.EnderecoCep,
		&i.Observacoes,
		&i.Tags,
		&i.Ativo,
		&i.AsaasCustomerID,
		&i.IsSubscriber,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getClienteByNameAndPhone = `-- name: GetClienteByNameAndPhone :one
SELECT id, tenant_id, nome, email, telefone, cpf, data_nascimento, genero, endereco_logradouro, endereco_numero, endereco_complemento, endereco_bairro, endereco_cidade, endereco_estado, endereco_cep, observacoes, tags, ativo, asaas_customer_id, is_subscriber, criado_em, atualizado_em FROM clientes
WHERE tenant_id = $1 
  AND nome ILIKE $2 
  AND telefone = $3
LIMIT 1
`

type GetClienteByNameAndPhoneParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Nome     string      `json:"nome"`
	Telefone string      `json:"telefone"`
}

// Buscar cliente por nome e telefone (para busca no Asaas - AS-001)
func (q *Queries) GetClienteByNameAndPhone(ctx context.Context, arg GetClienteByNameAndPhoneParams) (Cliente, error) {
	row := q.db.QueryRow(ctx, getClienteByNameAndPhone, arg.TenantID, arg.Nome, arg.Telefone)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Email,
		&i.Telefone,
		&i.Cpf,
		&i.DataNascimento,
		&i.Genero,
		&i.EnderecoLogradouro,
		&i.EnderecoNumero,
		&i.EnderecoComplemento,
		&i.EnderecoBairro,
		&i.EnderecoCidade,
		&i.EnderecoEstado,
		&i.EnderecoCep,
		&i.Observacoes,
		&i.Tags,
		&i.Ativo,
		&i.AsaasCustomerID,
		&i.IsSubscriber,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getPaymentByAsaasID = `-- name: GetPaymentByAsaasID :one
SELECT id, tenant_id, subscription_id, asaas_payment_id, valor, forma_pagamento, status, data_pagamento, codigo_transacao, observacao, status_asaas, due_date, confirmed_date, client_payment_date, credit_date, estimated_credit_date, billing_type, net_value, invoice_url, bank_slip_url, pix_qrcode, created_at, updated_at FROM subscription_payments 
WHERE asaas_payment_id = $1
`

// Buscar pagamento pelo ID do Asaas (para webhooks)
func (q *Queries) GetPaymentByAsaasID(ctx context.Context, asaasPaymentID *string) (SubscriptionPayment, error) {
	row := q.db.QueryRow(ctx, getPaymentByAsaasID, asaasPaymentID)
	var i SubscriptionPayment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SubscriptionID,
		&i.AsaasPaymentID,
		&i.Valor,
		&i.FormaPagamento,
		&i.Status,
		&i.DataPagamento,
		&i.CodigoTransacao,
		&i.Observacao,
		&i.StatusAsaas,
		&i.DueDate,
		&i.ConfirmedDate,
		&i.ClientPaymentDate,
		&i.CreditDate,
		&i.EstimatedCreditDate,
		&i.BillingType,
		&i.NetValue,
		&i.InvoiceUrl,
		&i.BankSlipUrl,
		&i.PixQrcode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlanByID = `-- name: GetPlanByID :one
SELECT id, tenant_id, nome, descricao, valor, periodicidade, qtd_servicos, limite_uso_mensal, ativo, created_at, updated_at FROM plans 
WHERE id = $1 AND tenant_id = $2
`

type GetPlanByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Buscar plano por ID (sempre com tenant_id)
func (q *Queries) GetPlanByID(ctx context.Context, arg GetPlanByIDParams) (Plan, error) {
	row := q.db.QueryRow(ctx, getPlanByID, arg.ID, arg.TenantID)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Descricao,
		&i.Valor,
		&i.Periodicidade,
		&i.QtdServicos,
		&i.LimiteUsoMensal,
		&i.Ativo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubscriptionByAsaasID = `-- name: GetSubscriptionByAsaasID :one
SELECT s.id, s.tenant_id, s.cliente_id, s.plano_id, s.asaas_customer_id, s.asaas_subscription_id, s.forma_pagamento, s.status, s.valor, s.link_pagamento, s.codigo_transacao, s.data_ativacao, s.data_vencimento, s.data_cancelamento, s.cancelado_por, s.servicos_utilizados, s.next_due_date, s.cycle, s.asaas_status, s.last_confirmed_at, s.last_sync_at, s.created_at, s.updated_at, p.nome as plano_nome
FROM subscriptions s
JOIN plans p ON s.plano_id = p.id
WHERE s.asaas_subscription_id = $1
`

type GetSubscriptionByAsaasIDRow struct {
	ID                  pgtype.UUID        `json:"id"`
	TenantID            pgtype.UUID        `json:"tenant_id"`
	ClienteID           pgtype.UUID        `json:"cliente_id"`
	PlanoID             pgtype.UUID        `json:"plano_id"`
	AsaasCustomerID     *string            `json:"asaas_customer_id"`
	AsaasSubscriptionID *string            `json:"asaas_subscription_id"`
	FormaPagamento      string             `json:"forma_pagamento"`
	Status              string             `json:"status"`
	Valor               decimal.Decimal    `json:"valor"`
	LinkPagamento       *string            `json:"link_pagamento"`
	CodigoTransacao     *string            `json:"codigo_transacao"`
	DataAtivacao        pgtype.Timestamptz `json:"data_ativacao"`
	DataVencimento      pgtype.Timestamptz `json:"data_vencimento"`
	DataCancelamento    pgtype.Timestamptz `json:"data_cancelamento"`
	CanceladoPor        pgtype.UUID        `json:"cancelado_por"`
	ServicosUtilizados  int32              `json:"servicos_utilizados"`
	NextDueDate         pgtype.Date        `json:"next_due_date"`
	Cycle               *string            `json:"cycle"`
	AsaasStatus         *string            `json:"asaas_status"`
	LastConfirmedAt     pgtype.Timestamptz `json:"last_confirmed_at"`
	LastSyncAt          pgtype.Timestamptz `json:"last_sync_at"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	PlanoNome           string             `json:"plano_nome"`
}

// Buscar assinatura pelo ID do Asaas (para webhooks)
func (q *Queries) GetSubscriptionByAsaasID(ctx context.Context, asaasSubscriptionID *string) (GetSubscriptionByAsaasIDRow, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByAsaasID, asaasSubscriptionID)
	var i GetSubscriptionByAsaasIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ClienteID,
		&i.PlanoID,
		&i.AsaasCustomerID,
		&i.AsaasSubscriptionID,
		&i.FormaPagamento,
		&i.Status,
		&i.Valor,
		&i.LinkPagamento,
		&i.CodigoTransacao,
		&i.DataAtivacao,
		&i.DataVencimento,
		&i.DataCancelamento,
		&i.CanceladoPor,
		&i.ServicosUtilizados,
		&i.NextDueDate,
		&i.Cycle,
		&i.AsaasStatus,
		&i.LastConfirmedAt,
		&i.LastSyncAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PlanoNome,
	)
	return i, err
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT 
    s.id, s.tenant_id, s.cliente_id, s.plano_id, s.asaas_customer_id, s.asaas_subscription_id, s.forma_pagamento, s.status, s.valor, s.link_pagamento, s.codigo_transacao, s.data_ativacao, s.data_vencimento, s.data_cancelamento, s.cancelado_por, s.servicos_utilizados, s.next_due_date, s.cycle, s.asaas_status, s.last_confirmed_at, s.last_sync_at, s.created_at, s.updated_at,
    p.nome as plano_nome,
    p.qtd_servicos as plano_qtd_servicos,
    p.limite_uso_mensal as plano_limite_uso_mensal,
    c.nome as cliente_nome,
    c.telefone as cliente_telefone,
    c.email as cliente_email
FROM subscriptions s
JOIN plans p ON s.plano_id = p.id
JOIN clientes c ON s.cliente_id = c.id
WHERE s.id = $1 AND s.tenant_id = $2
`

type GetSubscriptionByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetSubscriptionByIDRow struct {
	ID                   pgtype.UUID        `json:"id"`
	TenantID             pgtype.UUID        `json:"tenant_id"`
	ClienteID            pgtype.UUID        `json:"cliente_id"`
	PlanoID              pgtype.UUID        `json:"plano_id"`
	AsaasCustomerID      *string            `json:"asaas_customer_id"`
	AsaasSubscriptionID  *string            `json:"asaas_subscription_id"`
	FormaPagamento       string             `json:"forma_pagamento"`
	Status               string             `json:"status"`
	Valor                decimal.Decimal    `json:"valor"`
	LinkPagamento        *string            `json:"link_pagamento"`
	CodigoTransacao      *string            `json:"codigo_transacao"`
	DataAtivacao         pgtype.Timestamptz `json:"data_ativacao"`
	DataVencimento       pgtype.Timestamptz `json:"data_vencimento"`
	DataCancelamento     pgtype.Timestamptz `json:"data_cancelamento"`
	CanceladoPor         pgtype.UUID        `json:"cancelado_por"`
	ServicosUtilizados   int32              `json:"servicos_utilizados"`
	NextDueDate          pgtype.Date        `json:"next_due_date"`
	Cycle                *string            `json:"cycle"`
	AsaasStatus          *string            `json:"asaas_status"`
	LastConfirmedAt      pgtype.Timestamptz `json:"last_confirmed_at"`
	LastSyncAt           pgtype.Timestamptz `json:"last_sync_at"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	PlanoNome            string             `json:"plano_nome"`
	PlanoQtdServicos     *int32             `json:"plano_qtd_servicos"`
	PlanoLimiteUsoMensal *int32             `json:"plano_limite_uso_mensal"`
	ClienteNome          string             `json:"cliente_nome"`
	ClienteTelefone      string             `json:"cliente_telefone"`
	ClienteEmail         *string            `json:"cliente_email"`
}

// Buscar assinatura por ID com dados de plano e cliente (JOIN)
func (q *Queries) GetSubscriptionByID(ctx context.Context, arg GetSubscriptionByIDParams) (GetSubscriptionByIDRow, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByID, arg.ID, arg.TenantID)
	var i GetSubscriptionByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ClienteID,
		&i.PlanoID,
		&i.AsaasCustomerID,
		&i.AsaasSubscriptionID,
		&i.FormaPagamento,
		&i.Status,
		&i.Valor,
		&i.LinkPagamento,
		&i.CodigoTransacao,
		&i.DataAtivacao,
		&i.DataVencimento,
		&i.DataCancelamento,
		&i.CanceladoPor,
		&i.ServicosUtilizados,
		&i.NextDueDate,
		&i.Cycle,
		&i.AsaasStatus,
		&i.LastConfirmedAt,
		&i.LastSyncAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PlanoNome,
		&i.PlanoQtdServicos,
		&i.PlanoLimiteUsoMensal,
		&i.ClienteNome,
		&i.ClienteTelefone,
		&i.ClienteEmail,
	)
	return i, err
}

const getSubscriptionMetrics = `-- name: GetSubscriptionMetrics :one
SELECT 
    COUNT(*) FILTER (WHERE s.status = 'ATIVO')::int as total_ativas,
    COUNT(*) FILTER (WHERE s.status IN ('INATIVO', 'CANCELADO'))::int as total_inativas,
    COUNT(*) FILTER (WHERE s.status = 'INADIMPLENTE')::int as total_inadimplentes,
    (SELECT COUNT(*) FROM plans p2 WHERE p2.tenant_id = $1 AND p2.ativo = true)::int as total_planos_ativos,
    COALESCE(SUM(s.valor) FILTER (WHERE s.status = 'ATIVO'), 0)::decimal(15,2) as receita_mensal,
    -- Taxa de renovação: assinaturas renovadas nos últimos 30 dias / total ativas * 100
    CASE 
        WHEN COUNT(*) FILTER (WHERE s.status = 'ATIVO') > 0 
        THEN ROUND(
            (COUNT(*) FILTER (WHERE s.data_ativacao >= NOW() - INTERVAL '30 days' AND s.status = 'ATIVO')::numeric 
            / NULLIF(COUNT(*) FILTER (WHERE s.status = 'ATIVO'), 0)::numeric) * 100, 1
        )
        ELSE 0
    END::float as taxa_renovacao,
    -- Renovações próximos 7 dias: assinaturas com vencimento próximo
    COUNT(*) FILTER (
        WHERE s.status = 'ATIVO' 
        AND s.data_vencimento IS NOT NULL 
        AND s.data_vencimento BETWEEN NOW() AND NOW() + INTERVAL '7 days'
    )::int as renovacoes_proximos_7_dias
FROM subscriptions s
WHERE s.tenant_id = $1
`

type GetSubscriptionMetricsRow struct {
	TotalAtivas             int32           `json:"total_ativas"`
	TotalInativas           int32           `json:"total_inativas"`
	TotalInadimplentes      int32           `json:"total_inadimplentes"`
	TotalPlanosAtivos       int32           `json:"total_planos_ativos"`
	ReceitaMensal           decimal.Decimal `json:"receita_mensal"`
	TaxaRenovacao           float64         `json:"taxa_renovacao"`
	RenovacoesProximos7Dias int32           `json:"renovacoes_proximos_7_dias"`
}

// Métricas para relatórios (Seção 5.1)
func (q *Queries) GetSubscriptionMetrics(ctx context.Context, tenantID pgtype.UUID) (GetSubscriptionMetricsRow, error) {
	row := q.db.QueryRow(ctx, getSubscriptionMetrics, tenantID)
	var i GetSubscriptionMetricsRow
	err := row.Scan(
		&i.TotalAtivas,
		&i.TotalInativas,
		&i.TotalInadimplentes,
		&i.TotalPlanosAtivos,
		&i.ReceitaMensal,
		&i.TaxaRenovacao,
		&i.RenovacoesProximos7Dias,
	)
	return i, err
}

const getSubscriptionsByPaymentMethodBreakdown = `-- name: GetSubscriptionsByPaymentMethodBreakdown :many
SELECT 
    forma_pagamento,
    COUNT(*)::int as total,
    COALESCE(SUM(valor), 0)::decimal(15,2) as receita
FROM subscriptions
WHERE tenant_id = $1 AND status = 'ATIVO'
GROUP BY forma_pagamento
ORDER BY total DESC
`

type GetSubscriptionsByPaymentMethodBreakdownRow struct {
	FormaPagamento string          `json:"forma_pagamento"`
	Total          int32           `json:"total"`
	Receita        decimal.Decimal `json:"receita"`
}

// Breakdown por forma de pagamento (Seção 5.1)
func (q *Queries) GetSubscriptionsByPaymentMethodBreakdown(ctx context.Context, tenantID pgtype.UUID) ([]GetSubscriptionsByPaymentMethodBreakdownRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsByPaymentMethodBreakdown, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSubscriptionsByPaymentMethodBreakdownRow{}
	for rows.Next() {
		var i GetSubscriptionsByPaymentMethodBreakdownRow
		if err := rows.Scan(&i.FormaPagamento, &i.Total, &i.Receita); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionsByPlanBreakdown = `-- name: GetSubscriptionsByPlanBreakdown :many
SELECT 
    p.id as plano_id,
    p.nome as plano_nome,
    COUNT(*)::int as total,
    COALESCE(SUM(s.valor), 0)::decimal(15,2) as receita
FROM subscriptions s
JOIN plans p ON s.plano_id = p.id
WHERE s.tenant_id = $1 AND s.status = 'ATIVO'
GROUP BY p.id, p.nome
ORDER BY total DESC
`

type GetSubscriptionsByPlanBreakdownRow struct {
	PlanoID   pgtype.UUID     `json:"plano_id"`
	PlanoNome string          `json:"plano_nome"`
	Total     int32           `json:"total"`
	Receita   decimal.Decimal `json:"receita"`
}

// Breakdown por plano (Seção 5.1)
func (q *Queries) GetSubscriptionsByPlanBreakdown(ctx context.Context, tenantID pgtype.UUID) ([]GetSubscriptionsByPlanBreakdownRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsByPlanBreakdown, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSubscriptionsByPlanBreakdownRow{}
	for rows.Next() {
		var i GetSubscriptionsByPlanBreakdownRow
		if err := rows.Scan(
			&i.PlanoID,
			&i.PlanoNome,
			&i.Total,
			&i.Receita,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementServicosUtilizados = `-- name: IncrementServicosUtilizados :exec
UPDATE subscriptions SET 
    servicos_utilizados = servicos_utilizados + 1,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type IncrementServicosUtilizadosParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Incrementar contador de serviços utilizados (RN-BEN-002)
func (q *Queries) IncrementServicosUtilizados(ctx context.Context, arg IncrementServicosUtilizadosParams) error {
	_, err := q.db.Exec(ctx, incrementServicosUtilizados, arg.ID, arg.TenantID)
	return err
}

const listActivePlansByTenant = `-- name: ListActivePlansByTenant :many
SELECT id, tenant_id, nome, descricao, valor, periodicidade, qtd_servicos, limite_uso_mensal, ativo, created_at, updated_at FROM plans 
WHERE tenant_id = $1 AND ativo = true 
ORDER BY nome
`

// Listar apenas planos ativos (para seleção em nova assinatura - REGRA PL-002)
func (q *Queries) ListActivePlansByTenant(ctx context.Context, tenantID pgtype.UUID) ([]Plan, error) {
	rows, err := q.db.Query(ctx, listActivePlansByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Plan{}
	for rows.Next() {
		var i Plan
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Nome,
			&i.Descricao,
			&i.Valor,
			&i.Periodicidade,
			&i.QtdServicos,
			&i.LimiteUsoMensal,
			&i.Ativo,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpiringSoon = `-- name: ListExpiringSoon :many
SELECT 
    s.id, s.tenant_id, s.cliente_id, s.plano_id, s.asaas_customer_id, s.asaas_subscription_id, s.forma_pagamento, s.status, s.valor, s.link_pagamento, s.codigo_transacao, s.data_ativacao, s.data_vencimento, s.data_cancelamento, s.cancelado_por, s.servicos_utilizados, s.next_due_date, s.cycle, s.asaas_status, s.last_confirmed_at, s.last_sync_at, s.created_at, s.updated_at,
    p.nome as plano_nome,
    c.nome as cliente_nome,
    c.telefone as cliente_telefone
FROM subscriptions s
JOIN plans p ON s.plano_id = p.id
JOIN clientes c ON s.cliente_id = c.id
WHERE s.tenant_id = $1
  AND s.status = 'ATIVO' 
  AND s.data_vencimento BETWEEN NOW() AND NOW() + ($2 || ' days')::INTERVAL
`

type ListExpiringSoonParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Column2  *string     `json:"column_2"`
}

type ListExpiringSoonRow struct {
	ID                  pgtype.UUID        `json:"id"`
	TenantID            pgtype.UUID        `json:"tenant_id"`
	ClienteID           pgtype.UUID        `json:"cliente_id"`
	PlanoID             pgtype.UUID        `json:"plano_id"`
	AsaasCustomerID     *string            `json:"asaas_customer_id"`
	AsaasSubscriptionID *string            `json:"asaas_subscription_id"`
	FormaPagamento      string             `json:"forma_pagamento"`
	Status              string             `json:"status"`
	Valor               decimal.Decimal    `json:"valor"`
	LinkPagamento       *string            `json:"link_pagamento"`
	CodigoTransacao     *string            `json:"codigo_transacao"`
	DataAtivacao        pgtype.Timestamptz `json:"data_ativacao"`
	DataVencimento      pgtype.Timestamptz `json:"data_vencimento"`
	DataCancelamento    pgtype.Timestamptz `json:"data_cancelamento"`
	CanceladoPor        pgtype.UUID        `json:"cancelado_por"`
	ServicosUtilizados  int32              `json:"servicos_utilizados"`
	NextDueDate         pgtype.Date        `json:"next_due_date"`
	Cycle               *string            `json:"cycle"`
	AsaasStatus         *string            `json:"asaas_status"`
	LastConfirmedAt     pgtype.Timestamptz `json:"last_confirmed_at"`
	LastSyncAt          pgtype.Timestamptz `json:"last_sync_at"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	PlanoNome           string             `json:"plano_nome"`
	ClienteNome         string             `json:"cliente_nome"`
	ClienteTelefone     string             `json:"cliente_telefone"`
}

// Buscar assinaturas que vencem nos próximos N dias (para notificações)
func (q *Queries) ListExpiringSoon(ctx context.Context, arg ListExpiringSoonParams) ([]ListExpiringSoonRow, error) {
	rows, err := q.db.Query(ctx, listExpiringSoon, arg.TenantID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExpiringSoonRow{}
	for rows.Next() {
		var i ListExpiringSoonRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ClienteID,
			&i.PlanoID,
			&i.AsaasCustomerID,
			&i.AsaasSubscriptionID,
			&i.FormaPagamento,
			&i.Status,
			&i.Valor,
			&i.LinkPagamento,
			&i.CodigoTransacao,
			&i.DataAtivacao,
			&i.DataVencimento,
			&i.DataCancelamento,
			&i.CanceladoPor,
			&i.ServicosUtilizados,
			&i.NextDueDate,
			&i.Cycle,
			&i.AsaasStatus,
			&i.LastConfirmedAt,
			&i.LastSyncAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PlanoNome,
			&i.ClienteNome,
			&i.ClienteTelefone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOverdueSubscriptions = `-- name: ListOverdueSubscriptions :many
SELECT 
    s.id, s.tenant_id, s.cliente_id, s.plano_id, s.asaas_customer_id, s.asaas_subscription_id, s.forma_pagamento, s.status, s.valor, s.link_pagamento, s.codigo_transacao, s.data_ativacao, s.data_vencimento, s.data_cancelamento, s.cancelado_por, s.servicos_utilizados, s.next_due_date, s.cycle, s.asaas_status, s.last_confirmed_at, s.last_sync_at, s.created_at, s.updated_at,
    p.nome as plano_nome,
    c.nome as cliente_nome,
    c.id as cliente_id
FROM subscriptions s
JOIN plans p ON s.plano_id = p.id
JOIN clientes c ON s.cliente_id = c.id
WHERE s.status = 'ATIVO' 
  AND s.data_vencimento < NOW() - INTERVAL '3 days'
`

type ListOverdueSubscriptionsRow struct {
	ID                  pgtype.UUID        `json:"id"`
	TenantID            pgtype.UUID        `json:"tenant_id"`
	ClienteID           pgtype.UUID        `json:"cliente_id"`
	PlanoID             pgtype.UUID        `json:"plano_id"`
	AsaasCustomerID     *string            `json:"asaas_customer_id"`
	AsaasSubscriptionID *string            `json:"asaas_subscription_id"`
	FormaPagamento      string             `json:"forma_pagamento"`
	Status              string             `json:"status"`
	Valor               decimal.Decimal    `json:"valor"`
	LinkPagamento       *string            `json:"link_pagamento"`
	CodigoTransacao     *string            `json:"codigo_transacao"`
	DataAtivacao        pgtype.Timestamptz `json:"data_ativacao"`
	DataVencimento      pgtype.Timestamptz `json:"data_vencimento"`
	DataCancelamento    pgtype.Timestamptz `json:"data_cancelamento"`
	CanceladoPor        pgtype.UUID        `json:"cancelado_por"`
	ServicosUtilizados  int32              `json:"servicos_utilizados"`
	NextDueDate         pgtype.Date        `json:"next_due_date"`
	Cycle               *string            `json:"cycle"`
	AsaasStatus         *string            `json:"asaas_status"`
	LastConfirmedAt     pgtype.Timestamptz `json:"last_confirmed_at"`
	LastSyncAt          pgtype.Timestamptz `json:"last_sync_at"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	PlanoNome           string             `json:"plano_nome"`
	ClienteNome         string             `json:"cliente_nome"`
	ClienteID_2         pgtype.UUID        `json:"cliente_id_2"`
}

// Buscar assinaturas vencidas para o cron job (RN-VENC-003, RN-VENC-004)
func (q *Queries) ListOverdueSubscriptions(ctx context.Context) ([]ListOverdueSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, listOverdueSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOverdueSubscriptionsRow{}
	for rows.Next() {
		var i ListOverdueSubscriptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ClienteID,
			&i.PlanoID,
			&i.AsaasCustomerID,
			&i.AsaasSubscriptionID,
			&i.FormaPagamento,
			&i.Status,
			&i.Valor,
			&i.LinkPagamento,
			&i.CodigoTransacao,
			&i.DataAtivacao,
			&i.DataVencimento,
			&i.DataCancelamento,
			&i.CanceladoPor,
			&i.ServicosUtilizados,
			&i.NextDueDate,
			&i.Cycle,
			&i.AsaasStatus,
			&i.LastConfirmedAt,
			&i.LastSyncAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PlanoNome,
			&i.ClienteNome,
			&i.ClienteID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsBySubscription = `-- name: ListPaymentsBySubscription :many
SELECT id, tenant_id, subscription_id, asaas_payment_id, valor, forma_pagamento, status, data_pagamento, codigo_transacao, observacao, status_asaas, due_date, confirmed_date, client_payment_date, credit_date, estimated_credit_date, billing_type, net_value, invoice_url, bank_slip_url, pix_qrcode, created_at, updated_at FROM subscription_payments 
WHERE subscription_id = $1 AND tenant_id = $2
ORDER BY created_at DESC
`

type ListPaymentsBySubscriptionParams struct {
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	TenantID       pgtype.UUID `json:"tenant_id"`
}

// Listar histórico de pagamentos de uma assinatura
func (q *Queries) ListPaymentsBySubscription(ctx context.Context, arg ListPaymentsBySubscriptionParams) ([]SubscriptionPayment, error) {
	rows, err := q.db.Query(ctx, listPaymentsBySubscription, arg.SubscriptionID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SubscriptionPayment{}
	for rows.Next() {
		var i SubscriptionPayment
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SubscriptionID,
			&i.AsaasPaymentID,
			&i.Valor,
			&i.FormaPagamento,
			&i.Status,
			&i.DataPagamento,
			&i.CodigoTransacao,
			&i.Observacao,
			&i.StatusAsaas,
			&i.DueDate,
			&i.ConfirmedDate,
			&i.ClientPaymentDate,
			&i.CreditDate,
			&i.EstimatedCreditDate,
			&i.BillingType,
			&i.NetValue,
			&i.InvoiceUrl,
			&i.BankSlipUrl,
			&i.PixQrcode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsBySubscriptionPaginated = `-- name: ListPaymentsBySubscriptionPaginated :many
SELECT id, tenant_id, subscription_id, asaas_payment_id, valor, forma_pagamento, status, data_pagamento, codigo_transacao, observacao, status_asaas, due_date, confirmed_date, client_payment_date, credit_date, estimated_credit_date, billing_type, net_value, invoice_url, bank_slip_url, pix_qrcode, created_at, updated_at FROM subscription_payments 
WHERE subscription_id = $1 AND tenant_id = $2
ORDER BY due_date DESC NULLS LAST, created_at DESC
LIMIT $3 OFFSET $4
`

type ListPaymentsBySubscriptionPaginatedParams struct {
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	TenantID       pgtype.UUID `json:"tenant_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

// Listar pagamentos com paginação e filtros
func (q *Queries) ListPaymentsBySubscriptionPaginated(ctx context.Context, arg ListPaymentsBySubscriptionPaginatedParams) ([]SubscriptionPayment, error) {
	rows, err := q.db.Query(ctx, listPaymentsBySubscriptionPaginated,
		arg.SubscriptionID,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SubscriptionPayment{}
	for rows.Next() {
		var i SubscriptionPayment
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SubscriptionID,
			&i.AsaasPaymentID,
			&i.Valor,
			&i.FormaPagamento,
			&i.Status,
			&i.DataPagamento,
			&i.CodigoTransacao,
			&i.Observacao,
			&i.StatusAsaas,
			&i.DueDate,
			&i.ConfirmedDate,
			&i.ClientPaymentDate,
			&i.CreditDate,
			&i.EstimatedCreditDate,
			&i.BillingType,
			&i.NetValue,
			&i.InvoiceUrl,
			&i.BankSlipUrl,
			&i.PixQrcode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsNeedingReconciliation = `-- name: ListPaymentsNeedingReconciliation :many
SELECT id, tenant_id, subscription_id, asaas_payment_id, valor, forma_pagamento, status, data_pagamento, codigo_transacao, observacao, status_asaas, due_date, confirmed_date, client_payment_date, credit_date, estimated_credit_date, billing_type, net_value, invoice_url, bank_slip_url, pix_qrcode, created_at, updated_at FROM subscription_payments
WHERE tenant_id = $1 
  AND status IN ('CONFIRMADO', 'RECEBIDO')
  AND asaas_payment_id IS NOT NULL
ORDER BY created_at DESC
LIMIT 1000
`

// Listar pagamentos confirmados que podem precisar de conciliação
// (status CONFIRMADO ou RECEBIDO com asaas_payment_id)
func (q *Queries) ListPaymentsNeedingReconciliation(ctx context.Context, tenantID pgtype.UUID) ([]SubscriptionPayment, error) {
	rows, err := q.db.Query(ctx, listPaymentsNeedingReconciliation, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SubscriptionPayment{}
	for rows.Next() {
		var i SubscriptionPayment
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SubscriptionID,
			&i.AsaasPaymentID,
			&i.Valor,
			&i.FormaPagamento,
			&i.Status,
			&i.DataPagamento,
			&i.CodigoTransacao,
			&i.Observacao,
			&i.StatusAsaas,
			&i.DueDate,
			&i.ConfirmedDate,
			&i.ClientPaymentDate,
			&i.CreditDate,
			&i.EstimatedCreditDate,
			&i.BillingType,
			&i.NetValue,
			&i.InvoiceUrl,
			&i.BankSlipUrl,
			&i.PixQrcode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsOverdueByTenant = `-- name: ListPaymentsOverdueByTenant :many
SELECT sp.id, sp.tenant_id, sp.subscription_id, sp.asaas_payment_id, sp.valor, sp.forma_pagamento, sp.status, sp.data_pagamento, sp.codigo_transacao, sp.observacao, sp.status_asaas, sp.due_date, sp.confirmed_date, sp.client_payment_date, sp.credit_date, sp.estimated_credit_date, sp.billing_type, sp.net_value, sp.invoice_url, sp.bank_slip_url, sp.pix_qrcode, sp.created_at, sp.updated_at, s.asaas_subscription_id, c.nome as cliente_nome
FROM subscription_payments sp
JOIN subscriptions s ON sp.subscription_id = s.id
JOIN clientes c ON s.cliente_id = c.id
WHERE sp.tenant_id = $1 
  AND sp.status = 'VENCIDO'
ORDER BY sp.due_date ASC
LIMIT $2 OFFSET $3
`

type ListPaymentsOverdueByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListPaymentsOverdueByTenantRow struct {
	ID                  pgtype.UUID        `json:"id"`
	TenantID            pgtype.UUID        `json:"tenant_id"`
	SubscriptionID      pgtype.UUID        `json:"subscription_id"`
	AsaasPaymentID      *string            `json:"asaas_payment_id"`
	Valor               decimal.Decimal    `json:"valor"`
	FormaPagamento      string             `json:"forma_pagamento"`
	Status              string             `json:"status"`
	DataPagamento       pgtype.Timestamptz `json:"data_pagamento"`
	CodigoTransacao     *string            `json:"codigo_transacao"`
	Observacao          *string            `json:"observacao"`
	StatusAsaas         *string            `json:"status_asaas"`
	DueDate             pgtype.Date        `json:"due_date"`
	ConfirmedDate       pgtype.Timestamptz `json:"confirmed_date"`
	ClientPaymentDate   pgtype.Date        `json:"client_payment_date"`
	CreditDate          pgtype.Date        `json:"credit_date"`
	EstimatedCreditDate pgtype.Date        `json:"estimated_credit_date"`
	BillingType         *string            `json:"billing_type"`
	NetValue            pgtype.Numeric     `json:"net_value"`
	InvoiceUrl          *string            `json:"invoice_url"`
	BankSlipUrl         *string            `json:"bank_slip_url"`
	PixQrcode           *string            `json:"pix_qrcode"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	AsaasSubscriptionID *string            `json:"asaas_subscription_id"`
	ClienteNome         string             `json:"cliente_nome"`
}

// Listar pagamentos vencidos por tenant
func (q *Queries) ListPaymentsOverdueByTenant(ctx context.Context, arg ListPaymentsOverdueByTenantParams) ([]ListPaymentsOverdueByTenantRow, error) {
	rows, err := q.db.Query(ctx, listPaymentsOverdueByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPaymentsOverdueByTenantRow{}
	for rows.Next() {
		var i ListPaymentsOverdueByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SubscriptionID,
			&i.AsaasPaymentID,
			&i.Valor,
			&i.FormaPagamento,
			&i.Status,
			&i.DataPagamento,
			&i.CodigoTransacao,
			&i.Observacao,
			&i.StatusAsaas,
			&i.DueDate,
			&i.ConfirmedDate,
			&i.ClientPaymentDate,
			&i.CreditDate,
			&i.EstimatedCreditDate,
			&i.BillingType,
			&i.NetValue,
			&i.InvoiceUrl,
			&i.BankSlipUrl,
			&i.PixQrcode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AsaasSubscriptionID,
			&i.ClienteNome,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsPendingByTenant = `-- name: ListPaymentsPendingByTenant :many
SELECT sp.id, sp.tenant_id, sp.subscription_id, sp.asaas_payment_id, sp.valor, sp.forma_pagamento, sp.status, sp.data_pagamento, sp.codigo_transacao, sp.observacao, sp.status_asaas, sp.due_date, sp.confirmed_date, sp.client_payment_date, sp.credit_date, sp.estimated_credit_date, sp.billing_type, sp.net_value, sp.invoice_url, sp.bank_slip_url, sp.pix_qrcode, sp.created_at, sp.updated_at, s.asaas_subscription_id, c.nome as cliente_nome
FROM subscription_payments sp
JOIN subscriptions s ON sp.subscription_id = s.id
JOIN clientes c ON s.cliente_id = c.id
WHERE sp.tenant_id = $1 
  AND sp.status IN ('PENDENTE', 'CONFIRMADO')
ORDER BY sp.due_date ASC
LIMIT $2 OFFSET $3
`

type ListPaymentsPendingByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListPaymentsPendingByTenantRow struct {
	ID                  pgtype.UUID        `json:"id"`
	TenantID            pgtype.UUID        `json:"tenant_id"`
	SubscriptionID      pgtype.UUID        `json:"subscription_id"`
	AsaasPaymentID      *string            `json:"asaas_payment_id"`
	Valor               decimal.Decimal    `json:"valor"`
	FormaPagamento      string             `json:"forma_pagamento"`
	Status              string             `json:"status"`
	DataPagamento       pgtype.Timestamptz `json:"data_pagamento"`
	CodigoTransacao     *string            `json:"codigo_transacao"`
	Observacao          *string            `json:"observacao"`
	StatusAsaas         *string            `json:"status_asaas"`
	DueDate             pgtype.Date        `json:"due_date"`
	ConfirmedDate       pgtype.Timestamptz `json:"confirmed_date"`
	ClientPaymentDate   pgtype.Date        `json:"client_payment_date"`
	CreditDate          pgtype.Date        `json:"credit_date"`
	EstimatedCreditDate pgtype.Date        `json:"estimated_credit_date"`
	BillingType         *string            `json:"billing_type"`
	NetValue            pgtype.Numeric     `json:"net_value"`
	InvoiceUrl          *string            `json:"invoice_url"`
	BankSlipUrl         *string            `json:"bank_slip_url"`
	PixQrcode           *string            `json:"pix_qrcode"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	AsaasSubscriptionID *string            `json:"asaas_subscription_id"`
	ClienteNome         string             `json:"cliente_nome"`
}

// Listar pagamentos pendentes por tenant
func (q *Queries) ListPaymentsPendingByTenant(ctx context.Context, arg ListPaymentsPendingByTenantParams) ([]ListPaymentsPendingByTenantRow, error) {
	rows, err := q.db.Query(ctx, listPaymentsPendingByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPaymentsPendingByTenantRow{}
	for rows.Next() {
		var i ListPaymentsPendingByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SubscriptionID,
			&i.AsaasPaymentID,
			&i.Valor,
			&i.FormaPagamento,
			&i.Status,
			&i.DataPagamento,
			&i.CodigoTransacao,
			&i.Observacao,
			&i.StatusAsaas,
			&i.DueDate,
			&i.ConfirmedDate,
			&i.ClientPaymentDate,
			&i.CreditDate,
			&i.EstimatedCreditDate,
			&i.BillingType,
			&i.NetValue,
			&i.InvoiceUrl,
			&i.BankSlipUrl,
			&i.PixQrcode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AsaasSubscriptionID,
			&i.ClienteNome,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlansByTenant = `-- name: ListPlansByTenant :many
SELECT id, tenant_id, nome, descricao, valor, periodicidade, qtd_servicos, limite_uso_mensal, ativo, created_at, updated_at FROM plans 
WHERE tenant_id = $1 
ORDER BY nome
`

// Listar todos os planos de um tenant
func (q *Queries) ListPlansByTenant(ctx context.Context, tenantID pgtype.UUID) ([]Plan, error) {
	rows, err := q.db.Query(ctx, listPlansByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Plan{}
	for rows.Next() {
		var i Plan
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Nome,
			&i.Descricao,
			&i.Valor,
			&i.Periodicidade,
			&i.QtdServicos,
			&i.LimiteUsoMensal,
			&i.Ativo,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscribers = `-- name: ListSubscribers :many
SELECT id, tenant_id, nome, email, telefone, cpf, data_nascimento, genero, endereco_logradouro, endereco_numero, endereco_complemento, endereco_bairro, endereco_cidade, endereco_estado, endereco_cep, observacoes, tags, ativo, asaas_customer_id, is_subscriber, criado_em, atualizado_em FROM clientes
WHERE tenant_id = $1 AND is_subscriber = true
ORDER BY nome
`

// Listar todos os clientes assinantes
func (q *Queries) ListSubscribers(ctx context.Context, tenantID pgtype.UUID) ([]Cliente, error) {
	rows, err := q.db.Query(ctx, listSubscribers, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Cliente{}
	for rows.Next() {
		var i Cliente
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Nome,
			&i.Email,
			&i.Telefone,
			&i.Cpf,
			&i.DataNascimento,
			&i.Genero,
			&i.EnderecoLogradouro,
			&i.EnderecoNumero,
			&i.EnderecoComplemento,
			&i.EnderecoBairro,
			&i.EnderecoCidade,
			&i.EnderecoEstado,
			&i.EnderecoCep,
			&i.Observacoes,
			&i.Tags,
			&i.Ativo,
			&i.AsaasCustomerID,
			&i.IsSubscriber,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsByAsaasStatus = `-- name: ListSubscriptionsByAsaasStatus :many
SELECT s.id, s.tenant_id, s.cliente_id, s.plano_id, s.asaas_customer_id, s.asaas_subscription_id, s.forma_pagamento, s.status, s.valor, s.link_pagamento, s.codigo_transacao, s.data_ativacao, s.data_vencimento, s.data_cancelamento, s.cancelado_por, s.servicos_utilizados, s.next_due_date, s.cycle, s.asaas_status, s.last_confirmed_at, s.last_sync_at, s.created_at, s.updated_at, p.nome as plano_nome, c.nome as cliente_nome
FROM subscriptions s
JOIN plans p ON s.plano_id = p.id
JOIN clientes c ON s.cliente_id = c.id
WHERE s.tenant_id = $1 AND s.asaas_status = $2
ORDER BY s.created_at DESC
LIMIT $3 OFFSET $4
`

type ListSubscriptionsByAsaasStatusParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	AsaasStatus *string     `json:"asaas_status"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
}

type ListSubscriptionsByAsaasStatusRow struct {
	ID                  pgtype.UUID        `json:"id"`
	TenantID            pgtype.UUID        `json:"tenant_id"`
	ClienteID           pgtype.UUID        `json:"cliente_id"`
	PlanoID             pgtype.UUID        `json:"plano_id"`
	AsaasCustomerID     *string            `json:"asaas_customer_id"`
	AsaasSubscriptionID *string            `json:"asaas_subscription_id"`
	FormaPagamento      string             `json:"forma_pagamento"`
	Status              string             `json:"status"`
	Valor               decimal.Decimal    `json:"valor"`
	LinkPagamento       *string            `json:"link_pagamento"`
	CodigoTransacao     *string            `json:"codigo_transacao"`
	DataAtivacao        pgtype.Timestamptz `json:"data_ativacao"`
	DataVencimento      pgtype.Timestamptz `json:"data_vencimento"`
	DataCancelamento    pgtype.Timestamptz `json:"data_cancelamento"`
	CanceladoPor        pgtype.UUID        `json:"cancelado_por"`
	ServicosUtilizados  int32              `json:"servicos_utilizados"`
	NextDueDate         pgtype.Date        `json:"next_due_date"`
	Cycle               *string            `json:"cycle"`
	AsaasStatus         *string            `json:"asaas_status"`
	LastConfirmedAt     pgtype.Timestamptz `json:"last_confirmed_at"`
	LastSyncAt          pgtype.Timestamptz `json:"last_sync_at"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	PlanoNome           string             `json:"plano_nome"`
	ClienteNome         string             `json:"cliente_nome"`
}

// Listar assinaturas por status Asaas
func (q *Queries) ListSubscriptionsByAsaasStatus(ctx context.Context, arg ListSubscriptionsByAsaasStatusParams) ([]ListSubscriptionsByAsaasStatusRow, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsByAsaasStatus,
		arg.TenantID,
		arg.AsaasStatus,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubscriptionsByAsaasStatusRow{}
	for rows.Next() {
		var i ListSubscriptionsByAsaasStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ClienteID,
			&i.PlanoID,
			&i.AsaasCustomerID,
			&i.AsaasSubscriptionID,
			&i.FormaPagamento,
			&i.Status,
			&i.Valor,
			&i.LinkPagamento,
			&i.CodigoTransacao,
			&i.DataAtivacao,
			&i.DataVencimento,
			&i.DataCancelamento,
			&i.CanceladoPor,
			&i.ServicosUtilizados,
			&i.NextDueDate,
			&i.Cycle,
			&i.AsaasStatus,
			&i.LastConfirmedAt,
			&i.LastSyncAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PlanoNome,
			&i.ClienteNome,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsByCliente = `-- name: ListSubscriptionsByCliente :many
SELECT 
    s.id, s.tenant_id, s.cliente_id, s.plano_id, s.asaas_customer_id, s.asaas_subscription_id, s.forma_pagamento, s.status, s.valor, s.link_pagamento, s.codigo_transacao, s.data_ativacao, s.data_vencimento, s.data_cancelamento, s.cancelado_por, s.servicos_utilizados, s.next_due_date, s.cycle, s.asaas_status, s.last_confirmed_at, s.last_sync_at, s.created_at, s.updated_at,
    p.nome as plano_nome
FROM subscriptions s
JOIN plans p ON s.plano_id = p.id
WHERE s.cliente_id = $1 AND s.tenant_id = $2
ORDER BY s.created_at DESC
`

type ListSubscriptionsByClienteParams struct {
	ClienteID pgtype.UUID `json:"cliente_id"`
	TenantID  pgtype.UUID `json:"tenant_id"`
}

type ListSubscriptionsByClienteRow struct {
	ID                  pgtype.UUID        `json:"id"`
	TenantID            pgtype.UUID        `json:"tenant_id"`
	ClienteID           pgtype.UUID        `json:"cliente_id"`
	PlanoID             pgtype.UUID        `json:"plano_id"`
	AsaasCustomerID     *string            `json:"asaas_customer_id"`
	AsaasSubscriptionID *string            `json:"asaas_subscription_id"`
	FormaPagamento      string             `json:"forma_pagamento"`
	Status              string             `json:"status"`
	Valor               decimal.Decimal    `json:"valor"`
	LinkPagamento       *string            `json:"link_pagamento"`
	CodigoTransacao     *string            `json:"codigo_transacao"`
	DataAtivacao        pgtype.Timestamptz `json:"data_ativacao"`
	DataVencimento      pgtype.Timestamptz `json:"data_vencimento"`
	DataCancelamento    pgtype.Timestamptz `json:"data_cancelamento"`
	CanceladoPor        pgtype.UUID        `json:"cancelado_por"`
	ServicosUtilizados  int32              `json:"servicos_utilizados"`
	NextDueDate         pgtype.Date        `json:"next_due_date"`
	Cycle               *string            `json:"cycle"`
	AsaasStatus         *string            `json:"asaas_status"`
	LastConfirmedAt     pgtype.Timestamptz `json:"last_confirmed_at"`
	LastSyncAt          pgtype.Timestamptz `json:"last_sync_at"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	PlanoNome           string             `json:"plano_nome"`
}

// Listar assinaturas de um cliente específico
func (q *Queries) ListSubscriptionsByCliente(ctx context.Context, arg ListSubscriptionsByClienteParams) ([]ListSubscriptionsByClienteRow, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsByCliente, arg.ClienteID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubscriptionsByClienteRow{}
	for rows.Next() {
		var i ListSubscriptionsByClienteRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ClienteID,
			&i.PlanoID,
			&i.AsaasCustomerID,
			&i.AsaasSubscriptionID,
			&i.FormaPagamento,
			&i.Status,
			&i.Valor,
			&i.LinkPagamento,
			&i.CodigoTransacao,
			&i.DataAtivacao,
			&i.DataVencimento,
			&i.DataCancelamento,
			&i.CanceladoPor,
			&i.ServicosUtilizados,
			&i.NextDueDate,
			&i.Cycle,
			&i.AsaasStatus,
			&i.LastConfirmedAt,
			&i.LastSyncAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PlanoNome,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsByStatus = `-- name: ListSubscriptionsByStatus :many
SELECT 
    s.id, s.tenant_id, s.cliente_id, s.plano_id, s.asaas_customer_id, s.asaas_subscription_id, s.forma_pagamento, s.status, s.valor, s.link_pagamento, s.codigo_transacao, s.data_ativacao, s.data_vencimento, s.data_cancelamento, s.cancelado_por, s.servicos_utilizados, s.next_due_date, s.cycle, s.asaas_status, s.last_confirmed_at, s.last_sync_at, s.created_at, s.updated_at,
    p.nome as plano_nome,
    c.nome as cliente_nome,
    c.telefone as cliente_telefone
FROM subscriptions s
JOIN plans p ON s.plano_id = p.id
JOIN clientes c ON s.cliente_id = c.id
WHERE s.tenant_id = $1 AND s.status = $2
ORDER BY s.created_at DESC
`

type ListSubscriptionsByStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
}

type ListSubscriptionsByStatusRow struct {
	ID                  pgtype.UUID        `json:"id"`
	TenantID            pgtype.UUID        `json:"tenant_id"`
	ClienteID           pgtype.UUID        `json:"cliente_id"`
	PlanoID             pgtype.UUID        `json:"plano_id"`
	AsaasCustomerID     *string            `json:"asaas_customer_id"`
	AsaasSubscriptionID *string            `json:"asaas_subscription_id"`
	FormaPagamento      string             `json:"forma_pagamento"`
	Status              string             `json:"status"`
	Valor               decimal.Decimal    `json:"valor"`
	LinkPagamento       *string            `json:"link_pagamento"`
	CodigoTransacao     *string            `json:"codigo_transacao"`
	DataAtivacao        pgtype.Timestamptz `json:"data_ativacao"`
	DataVencimento      pgtype.Timestamptz `json:"data_vencimento"`
	DataCancelamento    pgtype.Timestamptz `json:"data_cancelamento"`
	CanceladoPor        pgtype.UUID        `json:"cancelado_por"`
	ServicosUtilizados  int32              `json:"servicos_utilizados"`
	NextDueDate         pgtype.Date        `json:"next_due_date"`
	Cycle               *string            `json:"cycle"`
	AsaasStatus         *string            `json:"asaas_status"`
	LastConfirmedAt     pgtype.Timestamptz `json:"last_confirmed_at"`
	LastSyncAt          pgtype.Timestamptz `json:"last_sync_at"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	PlanoNome           string             `json:"plano_nome"`
	ClienteNome         string             `json:"cliente_nome"`
	ClienteTelefone     string             `json:"cliente_telefone"`
}

// Listar assinaturas por status específico
func (q *Queries) ListSubscriptionsByStatus(ctx context.Context, arg ListSubscriptionsByStatusParams) ([]ListSubscriptionsByStatusRow, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsByStatus, arg.TenantID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubscriptionsByStatusRow{}
	for rows.Next() {
		var i ListSubscriptionsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ClienteID,
			&i.PlanoID,
			&i.AsaasCustomerID,
			&i.AsaasSubscriptionID,
			&i.FormaPagamento,
			&i.Status,
			&i.Valor,
			&i.LinkPagamento,
			&i.CodigoTransacao,
			&i.DataAtivacao,
			&i.DataVencimento,
			&i.DataCancelamento,
			&i.CanceladoPor,
			&i.ServicosUtilizados,
			&i.NextDueDate,
			&i.Cycle,
			&i.AsaasStatus,
			&i.LastConfirmedAt,
			&i.LastSyncAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PlanoNome,
			&i.ClienteNome,
			&i.ClienteTelefone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsByTenant = `-- name: ListSubscriptionsByTenant :many
SELECT 
    s.id, s.tenant_id, s.cliente_id, s.plano_id, s.asaas_customer_id, s.asaas_subscription_id, s.forma_pagamento, s.status, s.valor, s.link_pagamento, s.codigo_transacao, s.data_ativacao, s.data_vencimento, s.data_cancelamento, s.cancelado_por, s.servicos_utilizados, s.next_due_date, s.cycle, s.asaas_status, s.last_confirmed_at, s.last_sync_at, s.created_at, s.updated_at,
    p.nome as plano_nome,
    c.nome as cliente_nome,
    c.telefone as cliente_telefone
FROM subscriptions s
JOIN plans p ON s.plano_id = p.id
JOIN clientes c ON s.cliente_id = c.id
WHERE s.tenant_id = $1
ORDER BY s.created_at DESC
`

type ListSubscriptionsByTenantRow struct {
	ID                  pgtype.UUID        `json:"id"`
	TenantID            pgtype.UUID        `json:"tenant_id"`
	ClienteID           pgtype.UUID        `json:"cliente_id"`
	PlanoID             pgtype.UUID        `json:"plano_id"`
	AsaasCustomerID     *string            `json:"asaas_customer_id"`
	AsaasSubscriptionID *string            `json:"asaas_subscription_id"`
	FormaPagamento      string             `json:"forma_pagamento"`
	Status              string             `json:"status"`
	Valor               decimal.Decimal    `json:"valor"`
	LinkPagamento       *string            `json:"link_pagamento"`
	CodigoTransacao     *string            `json:"codigo_transacao"`
	DataAtivacao        pgtype.Timestamptz `json:"data_ativacao"`
	DataVencimento      pgtype.Timestamptz `json:"data_vencimento"`
	DataCancelamento    pgtype.Timestamptz `json:"data_cancelamento"`
	CanceladoPor        pgtype.UUID        `json:"cancelado_por"`
	ServicosUtilizados  int32              `json:"servicos_utilizados"`
	NextDueDate         pgtype.Date        `json:"next_due_date"`
	Cycle               *string            `json:"cycle"`
	AsaasStatus         *string            `json:"asaas_status"`
	LastConfirmedAt     pgtype.Timestamptz `json:"last_confirmed_at"`
	LastSyncAt          pgtype.Timestamptz `json:"last_sync_at"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	PlanoNome           string             `json:"plano_nome"`
	ClienteNome         string             `json:"cliente_nome"`
	ClienteTelefone     string             `json:"cliente_telefone"`
}

// Listar todas as assinaturas de um tenant com dados de plano e cliente
func (q *Queries) ListSubscriptionsByTenant(ctx context.Context, tenantID pgtype.UUID) ([]ListSubscriptionsByTenantRow, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubscriptionsByTenantRow{}
	for rows.Next() {
		var i ListSubscriptionsByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ClienteID,
			&i.PlanoID,
			&i.AsaasCustomerID,
			&i.AsaasSubscriptionID,
			&i.FormaPagamento,
			&i.Status,
			&i.Valor,
			&i.LinkPagamento,
			&i.CodigoTransacao,
			&i.DataAtivacao,
			&i.DataVencimento,
			&i.DataCancelamento,
			&i.CanceladoPor,
			&i.ServicosUtilizados,
			&i.NextDueDate,
			&i.Cycle,
			&i.AsaasStatus,
			&i.LastConfirmedAt,
			&i.LastSyncAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PlanoNome,
			&i.ClienteNome,
			&i.ClienteTelefone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsNeedingSync = `-- name: ListSubscriptionsNeedingSync :many
SELECT id, tenant_id, cliente_id, plano_id, asaas_customer_id, asaas_subscription_id, forma_pagamento, status, valor, link_pagamento, codigo_transacao, data_ativacao, data_vencimento, data_cancelamento, cancelado_por, servicos_utilizados, next_due_date, cycle, asaas_status, last_confirmed_at, last_sync_at, created_at, updated_at FROM subscriptions
WHERE tenant_id = $1 
  AND status = 'ATIVO'
  AND (last_sync_at IS NULL OR last_sync_at < NOW() - INTERVAL '24 hours')
ORDER BY last_sync_at ASC NULLS FIRST
LIMIT $2
`

type ListSubscriptionsNeedingSyncParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
}

// Listar assinaturas que precisam de sync (última sync > 24h)
func (q *Queries) ListSubscriptionsNeedingSync(ctx context.Context, arg ListSubscriptionsNeedingSyncParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsNeedingSync, arg.TenantID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ClienteID,
			&i.PlanoID,
			&i.AsaasCustomerID,
			&i.AsaasSubscriptionID,
			&i.FormaPagamento,
			&i.Status,
			&i.Valor,
			&i.LinkPagamento,
			&i.CodigoTransacao,
			&i.DataAtivacao,
			&i.DataVencimento,
			&i.DataCancelamento,
			&i.CanceladoPor,
			&i.ServicosUtilizados,
			&i.NextDueDate,
			&i.Cycle,
			&i.AsaasStatus,
			&i.LastConfirmedAt,
			&i.LastSyncAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const renewSubscription = `-- name: RenewSubscription :exec
UPDATE subscriptions SET 
    status = 'ATIVO',
    data_ativacao = $3,
    data_vencimento = $4,
    servicos_utilizados = 0,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type RenewSubscriptionParams struct {
	ID             pgtype.UUID        `json:"id"`
	TenantID       pgtype.UUID        `json:"tenant_id"`
	DataAtivacao   pgtype.Timestamptz `json:"data_ativacao"`
	DataVencimento pgtype.Timestamptz `json:"data_vencimento"`
}

// Renovar assinatura manualmente (PIX/Dinheiro) - Seção 6.4
func (q *Queries) RenewSubscription(ctx context.Context, arg RenewSubscriptionParams) error {
	_, err := q.db.Exec(ctx, renewSubscription,
		arg.ID,
		arg.TenantID,
		arg.DataAtivacao,
		arg.DataVencimento,
	)
	return err
}

const resetServicosUtilizados = `-- name: ResetServicosUtilizados :exec
UPDATE subscriptions SET 
    servicos_utilizados = 0, 
    updated_at = NOW() 
WHERE id = $1 AND tenant_id = $2
`

type ResetServicosUtilizadosParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Resetar contador de serviços na renovação (RN-BEN-004)
func (q *Queries) ResetServicosUtilizados(ctx context.Context, arg ResetServicosUtilizadosParams) error {
	_, err := q.db.Exec(ctx, resetServicosUtilizados, arg.ID, arg.TenantID)
	return err
}

const setClienteAsSubscriber = `-- name: SetClienteAsSubscriber :exec
UPDATE clientes
SET is_subscriber = $3,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
`

type SetClienteAsSubscriberParams struct {
	ID           pgtype.UUID `json:"id"`
	TenantID     pgtype.UUID `json:"tenant_id"`
	IsSubscriber bool        `json:"is_subscriber"`
}

// Marcar/desmarcar cliente como assinante (RN-CLI-003, RN-CLI-004)
func (q *Queries) SetClienteAsSubscriber(ctx context.Context, arg SetClienteAsSubscriberParams) error {
	_, err := q.db.Exec(ctx, setClienteAsSubscriber, arg.ID, arg.TenantID, arg.IsSubscriber)
	return err
}

const sumPaymentsByStatusAndPeriod = `-- name: SumPaymentsByStatusAndPeriod :one
SELECT 
    COALESCE(SUM(valor) FILTER (WHERE status = 'CONFIRMADO'), 0)::decimal(15,2) as confirmado_bruto,
    COALESCE(SUM(net_value) FILTER (WHERE status = 'CONFIRMADO'), 0)::decimal(15,2) as confirmado_liquido,
    COALESCE(SUM(valor) FILTER (WHERE status = 'RECEBIDO'), 0)::decimal(15,2) as recebido_bruto,
    COALESCE(SUM(net_value) FILTER (WHERE status = 'RECEBIDO'), 0)::decimal(15,2) as recebido_liquido
FROM subscription_payments
WHERE tenant_id = $1 
  AND due_date >= $2 
  AND due_date <= $3
`

type SumPaymentsByStatusAndPeriodParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	DueDate   pgtype.Date `json:"due_date"`
	DueDate_2 pgtype.Date `json:"due_date_2"`
}

type SumPaymentsByStatusAndPeriodRow struct {
	ConfirmadoBruto   decimal.Decimal `json:"confirmado_bruto"`
	ConfirmadoLiquido decimal.Decimal `json:"confirmado_liquido"`
	RecebidoBruto     decimal.Decimal `json:"recebido_bruto"`
	RecebidoLiquido   decimal.Decimal `json:"recebido_liquido"`
}

// Somar valores por status e período (para DRE)
func (q *Queries) SumPaymentsByStatusAndPeriod(ctx context.Context, arg SumPaymentsByStatusAndPeriodParams) (SumPaymentsByStatusAndPeriodRow, error) {
	row := q.db.QueryRow(ctx, sumPaymentsByStatusAndPeriod, arg.TenantID, arg.DueDate, arg.DueDate_2)
	var i SumPaymentsByStatusAndPeriodRow
	err := row.Scan(
		&i.ConfirmadoBruto,
		&i.ConfirmadoLiquido,
		&i.RecebidoBruto,
		&i.RecebidoLiquido,
	)
	return i, err
}

const updateClienteAsaasID = `-- name: UpdateClienteAsaasID :exec

UPDATE clientes
SET asaas_customer_id = $3,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdateClienteAsaasIDParams struct {
	ID              pgtype.UUID `json:"id"`
	TenantID        pgtype.UUID `json:"tenant_id"`
	AsaasCustomerID *string     `json:"asaas_customer_id"`
}

// ============================================================
// CLIENTES (Campos de Assinatura)
// ============================================================
// Atualizar ID do Asaas no cliente
func (q *Queries) UpdateClienteAsaasID(ctx context.Context, arg UpdateClienteAsaasIDParams) error {
	_, err := q.db.Exec(ctx, updateClienteAsaasID, arg.ID, arg.TenantID, arg.AsaasCustomerID)
	return err
}

const updatePaymentConfirmed = `-- name: UpdatePaymentConfirmed :exec
UPDATE subscription_payments SET 
    status = 'CONFIRMADO',
    status_asaas = $3,
    confirmed_date = $4,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdatePaymentConfirmedParams struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	StatusAsaas   *string            `json:"status_asaas"`
	ConfirmedDate pgtype.Timestamptz `json:"confirmed_date"`
}

// Marcar pagamento como confirmado (CONFIRMED webhook)
func (q *Queries) UpdatePaymentConfirmed(ctx context.Context, arg UpdatePaymentConfirmedParams) error {
	_, err := q.db.Exec(ctx, updatePaymentConfirmed,
		arg.ID,
		arg.TenantID,
		arg.StatusAsaas,
		arg.ConfirmedDate,
	)
	return err
}

const updatePaymentOverdue = `-- name: UpdatePaymentOverdue :exec
UPDATE subscription_payments SET 
    status = 'VENCIDO',
    status_asaas = $3,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdatePaymentOverdueParams struct {
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	StatusAsaas *string     `json:"status_asaas"`
}

// Marcar pagamento como vencido (OVERDUE webhook)
func (q *Queries) UpdatePaymentOverdue(ctx context.Context, arg UpdatePaymentOverdueParams) error {
	_, err := q.db.Exec(ctx, updatePaymentOverdue, arg.ID, arg.TenantID, arg.StatusAsaas)
	return err
}

const updatePaymentReceived = `-- name: UpdatePaymentReceived :exec
UPDATE subscription_payments SET 
    status = 'RECEBIDO',
    status_asaas = $3,
    client_payment_date = $4,
    credit_date = $5,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdatePaymentReceivedParams struct {
	ID                pgtype.UUID `json:"id"`
	TenantID          pgtype.UUID `json:"tenant_id"`
	StatusAsaas       *string     `json:"status_asaas"`
	ClientPaymentDate pgtype.Date `json:"client_payment_date"`
	CreditDate        pgtype.Date `json:"credit_date"`
}

// Marcar pagamento como recebido (RECEIVED webhook)
func (q *Queries) UpdatePaymentReceived(ctx context.Context, arg UpdatePaymentReceivedParams) error {
	_, err := q.db.Exec(ctx, updatePaymentReceived,
		arg.ID,
		arg.TenantID,
		arg.StatusAsaas,
		arg.ClientPaymentDate,
		arg.CreditDate,
	)
	return err
}

const updatePaymentRefunded = `-- name: UpdatePaymentRefunded :exec
UPDATE subscription_payments SET 
    status = 'ESTORNADO',
    status_asaas = $3,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdatePaymentRefundedParams struct {
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	StatusAsaas *string     `json:"status_asaas"`
}

// Marcar pagamento como estornado (REFUNDED webhook)
func (q *Queries) UpdatePaymentRefunded(ctx context.Context, arg UpdatePaymentRefundedParams) error {
	_, err := q.db.Exec(ctx, updatePaymentRefunded, arg.ID, arg.TenantID, arg.StatusAsaas)
	return err
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :exec
UPDATE subscription_payments SET 
    status = $3 
WHERE id = $1 AND tenant_id = $2
`

type UpdatePaymentStatusParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
}

// Atualizar status de um pagamento
func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) error {
	_, err := q.db.Exec(ctx, updatePaymentStatus, arg.ID, arg.TenantID, arg.Status)
	return err
}

const updatePaymentStatusAsaas = `-- name: UpdatePaymentStatusAsaas :exec
UPDATE subscription_payments SET 
    status = $3,
    status_asaas = $4,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdatePaymentStatusAsaasParams struct {
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	Status      string      `json:"status"`
	StatusAsaas *string     `json:"status_asaas"`
}

// Atualizar status interno e status Asaas
func (q *Queries) UpdatePaymentStatusAsaas(ctx context.Context, arg UpdatePaymentStatusAsaasParams) error {
	_, err := q.db.Exec(ctx, updatePaymentStatusAsaas,
		arg.ID,
		arg.TenantID,
		arg.Status,
		arg.StatusAsaas,
	)
	return err
}

const updatePlan = `-- name: UpdatePlan :one
UPDATE plans SET 
    nome = $3, 
    descricao = $4, 
    valor = $5, 
    qtd_servicos = $6, 
    limite_uso_mensal = $7, 
    ativo = $8,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, nome, descricao, valor, periodicidade, qtd_servicos, limite_uso_mensal, ativo, created_at, updated_at
`

type UpdatePlanParams struct {
	ID              pgtype.UUID     `json:"id"`
	TenantID        pgtype.UUID     `json:"tenant_id"`
	Nome            string          `json:"nome"`
	Descricao       *string         `json:"descricao"`
	Valor           decimal.Decimal `json:"valor"`
	QtdServicos     *int32          `json:"qtd_servicos"`
	LimiteUsoMensal *int32          `json:"limite_uso_mensal"`
	Ativo           bool            `json:"ativo"`
}

// Atualizar plano existente
func (q *Queries) UpdatePlan(ctx context.Context, arg UpdatePlanParams) (Plan, error) {
	row := q.db.QueryRow(ctx, updatePlan,
		arg.ID,
		arg.TenantID,
		arg.Nome,
		arg.Descricao,
		arg.Valor,
		arg.QtdServicos,
		arg.LimiteUsoMensal,
		arg.Ativo,
	)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Nome,
		&i.Descricao,
		&i.Valor,
		&i.Periodicidade,
		&i.QtdServicos,
		&i.LimiteUsoMensal,
		&i.Ativo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubscription = `-- name: UpdateSubscription :exec
UPDATE subscriptions SET 
    plano_id = $3,
    forma_pagamento = $4,
    status = $5,
    valor = $6,
    data_ativacao = $7,
    data_vencimento = $8,
    asaas_customer_id = $9,
    asaas_subscription_id = $10,
    link_pagamento = $11,
    codigo_transacao = $12,
    servicos_utilizados = $13,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdateSubscriptionParams struct {
	ID                  pgtype.UUID        `json:"id"`
	TenantID            pgtype.UUID        `json:"tenant_id"`
	PlanoID             pgtype.UUID        `json:"plano_id"`
	FormaPagamento      string             `json:"forma_pagamento"`
	Status              string             `json:"status"`
	Valor               decimal.Decimal    `json:"valor"`
	DataAtivacao        pgtype.Timestamptz `json:"data_ativacao"`
	DataVencimento      pgtype.Timestamptz `json:"data_vencimento"`
	AsaasCustomerID     *string            `json:"asaas_customer_id"`
	AsaasSubscriptionID *string            `json:"asaas_subscription_id"`
	LinkPagamento       *string            `json:"link_pagamento"`
	CodigoTransacao     *string            `json:"codigo_transacao"`
	ServicosUtilizados  int32              `json:"servicos_utilizados"`
}

// Atualizar assinatura completa (usado pelo webhook após pagamento)
func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) error {
	_, err := q.db.Exec(ctx, updateSubscription,
		arg.ID,
		arg.TenantID,
		arg.PlanoID,
		arg.FormaPagamento,
		arg.Status,
		arg.Valor,
		arg.DataAtivacao,
		arg.DataVencimento,
		arg.AsaasCustomerID,
		arg.AsaasSubscriptionID,
		arg.LinkPagamento,
		arg.CodigoTransacao,
		arg.ServicosUtilizados,
	)
	return err
}

const updateSubscriptionAsaasFields = `-- name: UpdateSubscriptionAsaasFields :exec

UPDATE subscriptions SET 
    next_due_date = $3,
    asaas_status = $4,
    last_confirmed_at = $5,
    last_sync_at = NOW(),
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdateSubscriptionAsaasFieldsParams struct {
	ID              pgtype.UUID        `json:"id"`
	TenantID        pgtype.UUID        `json:"tenant_id"`
	NextDueDate     pgtype.Date        `json:"next_due_date"`
	AsaasStatus     *string            `json:"asaas_status"`
	LastConfirmedAt pgtype.Timestamptz `json:"last_confirmed_at"`
}

// ============================================================
// SUBSCRIPTIONS - Queries v2 (Campos Asaas)
// ============================================================
// Atualizar campos Asaas da assinatura (após webhook)
func (q *Queries) UpdateSubscriptionAsaasFields(ctx context.Context, arg UpdateSubscriptionAsaasFieldsParams) error {
	_, err := q.db.Exec(ctx, updateSubscriptionAsaasFields,
		arg.ID,
		arg.TenantID,
		arg.NextDueDate,
		arg.AsaasStatus,
		arg.LastConfirmedAt,
	)
	return err
}

const updateSubscriptionAsaasIDs = `-- name: UpdateSubscriptionAsaasIDs :exec
UPDATE subscriptions SET 
    asaas_customer_id = $3, 
    asaas_subscription_id = $4, 
    link_pagamento = $5,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdateSubscriptionAsaasIDsParams struct {
	ID                  pgtype.UUID `json:"id"`
	TenantID            pgtype.UUID `json:"tenant_id"`
	AsaasCustomerID     *string     `json:"asaas_customer_id"`
	AsaasSubscriptionID *string     `json:"asaas_subscription_id"`
	LinkPagamento       *string     `json:"link_pagamento"`
}

// Atualizar IDs do Asaas após criação no gateway
func (q *Queries) UpdateSubscriptionAsaasIDs(ctx context.Context, arg UpdateSubscriptionAsaasIDsParams) error {
	_, err := q.db.Exec(ctx, updateSubscriptionAsaasIDs,
		arg.ID,
		arg.TenantID,
		arg.AsaasCustomerID,
		arg.AsaasSubscriptionID,
		arg.LinkPagamento,
	)
	return err
}

const updateSubscriptionNextDueDate = `-- name: UpdateSubscriptionNextDueDate :exec
UPDATE subscriptions SET 
    next_due_date = $3,
    data_vencimento = $3,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdateSubscriptionNextDueDateParams struct {
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	NextDueDate pgtype.Date `json:"next_due_date"`
}

// Atualizar próximo vencimento
func (q *Queries) UpdateSubscriptionNextDueDate(ctx context.Context, arg UpdateSubscriptionNextDueDateParams) error {
	_, err := q.db.Exec(ctx, updateSubscriptionNextDueDate, arg.ID, arg.TenantID, arg.NextDueDate)
	return err
}

const updateSubscriptionStatus = `-- name: UpdateSubscriptionStatus :exec
UPDATE subscriptions SET 
    status = $3, 
    updated_at = NOW() 
WHERE id = $1 AND tenant_id = $2
`

type UpdateSubscriptionStatusParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
}

// Atualizar apenas o status de uma assinatura
func (q *Queries) UpdateSubscriptionStatus(ctx context.Context, arg UpdateSubscriptionStatusParams) error {
	_, err := q.db.Exec(ctx, updateSubscriptionStatus, arg.ID, arg.TenantID, arg.Status)
	return err
}

const updateSubscriptionStatusWithAsaas = `-- name: UpdateSubscriptionStatusWithAsaas :exec
UPDATE subscriptions SET 
    status = $3,
    asaas_status = $4,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdateSubscriptionStatusWithAsaasParams struct {
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	Status      string      `json:"status"`
	AsaasStatus *string     `json:"asaas_status"`
}

// Atualizar status interno e status Asaas juntos
func (q *Queries) UpdateSubscriptionStatusWithAsaas(ctx context.Context, arg UpdateSubscriptionStatusWithAsaasParams) error {
	_, err := q.db.Exec(ctx, updateSubscriptionStatusWithAsaas,
		arg.ID,
		arg.TenantID,
		arg.Status,
		arg.AsaasStatus,
	)
	return err
}

const upsertPaymentByAsaasID = `-- name: UpsertPaymentByAsaasID :one

INSERT INTO subscription_payments (
    tenant_id, 
    subscription_id, 
    asaas_payment_id, 
    valor, 
    forma_pagamento, 
    status,
    status_asaas,
    due_date,
    confirmed_date,
    client_payment_date,
    credit_date,
    estimated_credit_date,
    billing_type,
    net_value,
    invoice_url,
    bank_slip_url,
    pix_qrcode,
    data_pagamento, 
    codigo_transacao, 
    observacao
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20)
ON CONFLICT (asaas_payment_id) 
DO UPDATE SET
    status = EXCLUDED.status,
    status_asaas = EXCLUDED.status_asaas,
    due_date = COALESCE(EXCLUDED.due_date, subscription_payments.due_date),
    confirmed_date = COALESCE(EXCLUDED.confirmed_date, subscription_payments.confirmed_date),
    client_payment_date = COALESCE(EXCLUDED.client_payment_date, subscription_payments.client_payment_date),
    credit_date = COALESCE(EXCLUDED.credit_date, subscription_payments.credit_date),
    estimated_credit_date = COALESCE(EXCLUDED.estimated_credit_date, subscription_payments.estimated_credit_date),
    billing_type = COALESCE(EXCLUDED.billing_type, subscription_payments.billing_type),
    net_value = COALESCE(EXCLUDED.net_value, subscription_payments.net_value),
    invoice_url = COALESCE(EXCLUDED.invoice_url, subscription_payments.invoice_url),
    bank_slip_url = COALESCE(EXCLUDED.bank_slip_url, subscription_payments.bank_slip_url),
    pix_qrcode = COALESCE(EXCLUDED.pix_qrcode, subscription_payments.pix_qrcode),
    data_pagamento = COALESCE(EXCLUDED.data_pagamento, subscription_payments.data_pagamento),
    observacao = COALESCE(EXCLUDED.observacao, subscription_payments.observacao),
    updated_at = NOW()
RETURNING id, tenant_id, subscription_id, asaas_payment_id, valor, forma_pagamento, status, data_pagamento, codigo_transacao, observacao, status_asaas, due_date, confirmed_date, client_payment_date, credit_date, estimated_credit_date, billing_type, net_value, invoice_url, bank_slip_url, pix_qrcode, created_at, updated_at
`

type UpsertPaymentByAsaasIDParams struct {
	TenantID            pgtype.UUID        `json:"tenant_id"`
	SubscriptionID      pgtype.UUID        `json:"subscription_id"`
	AsaasPaymentID      *string            `json:"asaas_payment_id"`
	Valor               decimal.Decimal    `json:"valor"`
	FormaPagamento      string             `json:"forma_pagamento"`
	Status              string             `json:"status"`
	StatusAsaas         *string            `json:"status_asaas"`
	DueDate             pgtype.Date        `json:"due_date"`
	ConfirmedDate       pgtype.Timestamptz `json:"confirmed_date"`
	ClientPaymentDate   pgtype.Date        `json:"client_payment_date"`
	CreditDate          pgtype.Date        `json:"credit_date"`
	EstimatedCreditDate pgtype.Date        `json:"estimated_credit_date"`
	BillingType         *string            `json:"billing_type"`
	NetValue            pgtype.Numeric     `json:"net_value"`
	InvoiceUrl          *string            `json:"invoice_url"`
	BankSlipUrl         *string            `json:"bank_slip_url"`
	PixQrcode           *string            `json:"pix_qrcode"`
	DataPagamento       pgtype.Timestamptz `json:"data_pagamento"`
	CodigoTransacao     *string            `json:"codigo_transacao"`
	Observacao          *string            `json:"observacao"`
}

// ============================================================
// SUBSCRIPTION_PAYMENTS - Queries v2 (Integração Asaas)
// ============================================================
// Criar ou atualizar pagamento via webhook (idempotente)
func (q *Queries) UpsertPaymentByAsaasID(ctx context.Context, arg UpsertPaymentByAsaasIDParams) (SubscriptionPayment, error) {
	row := q.db.QueryRow(ctx, upsertPaymentByAsaasID,
		arg.TenantID,
		arg.SubscriptionID,
		arg.AsaasPaymentID,
		arg.Valor,
		arg.FormaPagamento,
		arg.Status,
		arg.StatusAsaas,
		arg.DueDate,
		arg.ConfirmedDate,
		arg.ClientPaymentDate,
		arg.CreditDate,
		arg.EstimatedCreditDate,
		arg.BillingType,
		arg.NetValue,
		arg.InvoiceUrl,
		arg.BankSlipUrl,
		arg.PixQrcode,
		arg.DataPagamento,
		arg.CodigoTransacao,
		arg.Observacao,
	)
	var i SubscriptionPayment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SubscriptionID,
		&i.AsaasPaymentID,
		&i.Valor,
		&i.FormaPagamento,
		&i.Status,
		&i.DataPagamento,
		&i.CodigoTransacao,
		&i.Observacao,
		&i.StatusAsaas,
		&i.DueDate,
		&i.ConfirmedDate,
		&i.ClientPaymentDate,
		&i.CreditDate,
		&i.EstimatedCreditDate,
		&i.BillingType,
		&i.NetValue,
		&i.InvoiceUrl,
		&i.BankSlipUrl,
		&i.PixQrcode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
